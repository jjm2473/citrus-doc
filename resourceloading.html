<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>第 5 章 Resource Loading服务指南</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="home" href="index.html" title="Webx框架指南"/><link rel="up" href="pt02.html" title="部分 II. Webx基础设施服务"/><link rel="prev" href="pt02.html" title="部分 II. Webx基础设施服务"/><link rel="next" href="filter.html" title="第 6 章 Filter、Request Contexts和Pipeline"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 5 章 Resource Loading服务指南</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pt02.html">上一页</a> </td><th width="60%" align="center">部分 II. Webx基础设施服务</th><td width="20%" align="right"> <a accesskey="n" href="filter.html">下一页</a></td></tr></table><hr/></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.resource"><!--anchor webx.resource--></a>第 5 章 Resource Loading服务指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="resourceloading.html#d0e2690">5.1. 资源概述</a></span></dt><dd><dl><dt><span class="section"><a href="resourceloading.html#d0e2693">5.1.1. 什么是资源？</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e2738">5.1.2. 如何表示资源？</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e2867">5.1.3. 如何访问资源？</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e2932">5.1.4. 如何遍历资源？</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e2970">5.1.5. 有什么问题？</a></span></dt></dl></dd><dt><span class="section"><a href="resourceloading.html#d0e3004">5.2. Spring的<code class="code">ResourceLoader</code>机制</a></span></dt><dd><dl><dt><span class="section"><a href="resourceloading.html#d0e3015">5.2.1. <code class="code">Resource</code>接口</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e3064">5.2.2. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e3091">5.2.3. 在代码中取得资源</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e3210">5.2.4. Spring如何装载资源？</a></span></dt><dt><span class="section"><a href="resourceloading.html#d0e3390">5.2.5. Spring <code class="code">ResourceLoader</code>的缺点</a></span></dt></dl></dd><dt><span class="section"><a href="resourceloading.html#d0e3457">5.3. Resource Loading服务</a></span></dt><dd><dl><dt><span class="section"><a href="resourceloading.html#d0e3460">5.3.1. 替换Spring <code class="code">ResourceLoader</code></a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.define.newres">5.3.2. 定义新资源</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.rename.res">5.3.3. 重命名资源</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.redirect.res">5.3.4. 重定向资源</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.matching">5.3.5. 匹配资源</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.multi.loaders">5.3.6. 在多个<code class="code">ResourceLoader</code>中查找</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.load.parent">5.3.7. 装载parent容器中的资源</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.modify.res">5.3.8. 修改资源文件的内容</a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.using.service">5.3.9. 直接使用<code class="code">ResourceLoadingService</code></a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.using.service.nonweb">5.3.10. 在非Web环境中使用Resource Loading服务</a></span></dt></dl></dd><dt><span class="section"><a href="resourceloading.html#webx.resource.loaders">5.4. ResourceLoader参考</a></span></dt><dd><dl><dt><span class="section"><a href="resourceloading.html#webx.resource.loader.file">5.4.1. <code class="code">FileResourceLoader</code></a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.loader.webapp">5.4.2. <code class="code">WebappResourceLoader</code></a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.loader.classpath">5.4.3. <code class="code">ClasspathResourceLoader</code></a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.loader.super">5.4.4. <code class="code">SuperResourceLoader</code></a></span></dt><dt><span class="section"><a href="resourceloading.html#webx.resource.loader.other">5.4.5. 关于<code class="code">ResourceLoader</code>的其它考虑</a></span></dt></dl></dd><dt><span class="section"><a href="resourceloading.html#d0e4876">5.5. 本章总结</a></span></dt></dl></div><p>Webx框架中，包含了一套用来查找和装载资源的服务 —— Resource Loading服务。</p><p>Resource Loading服务从Spring
        <code class="code">ResourceLoader</code>机制中扩展而来，并且和Spring框架融为一体。因此，你不需要写特别的Java代码，就可以让所有利用Spring
            <code class="code">ResourceLoader</code>机制的代码，直接享用Webx所提供的新的Resource Loading机制。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2690"><!--anchor d0e2690--></a>5.1. 资源概述</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2693"><!--anchor d0e2693--></a>5.1.1. 什么是资源？</h3></div></div></div><p>在一个稍具规模的应用程序中，经常要做的一件事，就是查找资源、读取资源的内容。这里所谓的“资源”，是指<span class="emphasis"><em>存放在某一介质中，可以被程序利用的文件、数据</em></span>。例如，基于Java的WEB应用中，常用到下面的资源：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>配置文件：<code class="filename">*.xml</code>、<code class="filename">*.properties</code>等。</p></li><li class="listitem"><p>Java类文件：<code class="filename">*.class</code>。</p></li><li class="listitem"><p>JSP页面、Velocity模板文件：<code class="filename">*.jsp</code>、<code class="filename">*.vm</code>等。</p></li><li class="listitem"><p>图片、CSS、JavaScript文件：<code class="filename">*.jpg</code>、<code class="filename">*.css</code>、<code class="filename">*.js</code>等。
                        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2738"><!--anchor d0e2738--></a>5.1.2. 如何表示资源？</h3></div></div></div><p>在Java中，有多种形式可以表示一个资源：</p><div class="table"><a id="d0e2743"><!--anchor d0e2743--></a><p class="title"><strong>表 5.1. 资源的表示</strong></p><div class="table-contents"><table summary="资源的表示" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c1"/><col width="80%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">可表示资源的对象</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">java.io.​File</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>可代表文件系统中的文件或目录。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>文件系统中的文件：“<code class="filename">c:\config.sys</code>”。</p></li><li class="listitem"><p>文件系统中的目录：“<code class="filename">c:\windows\</code>”。
                                            </p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">java.net.​URL</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>统一资源定位符。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>文件系统中的文件：<code class="filename">c:\config.sys</code>，可以表示成URL：“<code class="code">file:///c:/config.sys</code>”。</p></li><li class="listitem"><p>文件系统中的目录：<code class="filename">c:\windows\</code>，可以表示成URL：“<code class="code">file:///c:/windows/</code>”。</p></li><li class="listitem"><p>远程WEB服务器上的文件：“<code class="code">http://www.springframework.org/schema/beans.xml</code>”。</p></li><li class="listitem"><p>Jar包中的某个文件，可以表示成URL：“<code class="code">jar:file:///c:/my.jar!/my/file.txt</code>”。
                                            </p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">java.io.​InputStream</code></td><td style="" valign="middle">
                                <p>输入流对象，可用来直接访问资源的内容。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>文件系统中的文件：<code class="filename">c:\config.sys</code>，可以用下面的代码来转换成输入流：</p><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">new</strong> FileInputStream(<strong class="hl-string"><em style="color:navy">"c:\\config.sys"</em></strong>);</pre></li><li class="listitem"><p>远程WEB服务器上的文件，可以用下面的代码来转换成输入流：</p><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">new</strong> URL(<strong class="hl-string"><em style="color:navy">"http://www.springframework.org/schema/beans.xml"</em></strong>)​.openStream();</pre></li><li class="listitem"><p>Jar包中的某个文件，可以用下面的代码来转换成输入流： </p><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">new</strong> URL(<strong class="hl-string"><em style="color:navy">"jar:file:///c:/my.jar!/my/file.txt"</em></strong>)​.openStream();</pre></li></ul></div>
                            </td></tr></tbody></table></div></div><p>然而，并不是所有的资源，都可以表现成上述所有的形式。比如，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Windows文件系统中的目录，无法表现为输入流。</p></li><li class="listitem"><p>而远程WEB服务器上的文件无法转换成<code class="code">File</code>对象。</p></li><li class="listitem"><p>多数资源都可以表现成<code class="code">URL</code>形式。但也有例外，例如，如果把数据库中的数据看作资源，那么一般来说这种资源无法表示成<code class="code">URL</code>。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2867"><!--anchor d0e2867--></a>5.1.3. 如何访问资源？</h3></div></div></div><p>不同类型的资源，需要用不同的方法来访问。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">访问CLASSPATH中的资源</span></dt><dd><p>将资源放在CLASSPATH是最简单的做法。我们只要把所需的资源文件打包到Jar文件中，或是在运行java时，用<code class="code">-classpath</code>参数中指定的路径中。接下来我们就可以用下面的代码来访问这些资源：</p><div class="example"><a id="d0e2882"><!--anchor d0e2882--></a><p class="title"><strong>例 5.1. 访问CLASSPATH中的资源</strong></p><div class="example-contents"><pre class="programlisting">URL resourceURL = getClassLoader().getResource(<strong class="hl-string"><em style="color:navy">"java/lang/String.class"</em></strong>); <em class="hl-comment" style="color: green">// 取得URL</em>
InputStream resourceContent = getClassLoader().getResourceAsStream(<strong class="hl-string"><em style="color:navy">"java/lang/String.class"</em></strong>); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问文件系统中的资源</span></dt><dd><p>下面的代码从文件资源中读取信息：</p><div class="example"><a id="d0e2893"><!--anchor d0e2893--></a><p class="title"><strong>例 5.2. 访问文件系统中的资源</strong></p><div class="example-contents"><pre class="programlisting">File resourceFile = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"c:\\test.txt"</em></strong>); <em class="hl-comment" style="color: green">// 取得File</em>
InputStream resourceContent = <strong class="hl-keyword" style="color: maroon">new</strong> FileInputStream(resourceFile); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问Web应用中的资源</span></dt><dd><p>Web应用既可以打包成war文件，也可以展开到任意目录中。因此Web应用中的资源（JSP、模板、图片、Java类、配置文件）不总是可以用文件的方式存取。虽然Servlet
                                API提供了<code class="code">ServletContext.getRealPath()</code>方法，用来取得某个资源的实际文件路径，但该方法很可能返回<code class="code">null</code>
                            —— 这取决于应用服务器的实现，以及Web应用的部署方式。更好的获取WEB应用资源的方法如下：</p><div class="example"><a id="d0e2910"><!--anchor d0e2910--></a><p class="title"><strong>例 5.3. 访问Web应用中的资源</strong></p><div class="example-contents"><pre class="programlisting">URL resourceURL = servletContext.getResource(<strong class="hl-string"><em style="color:navy">"/WEB-INF/web.xml"</em></strong>); <em class="hl-comment" style="color: green">// 取得URL</em>
InputStream resourceContent = servletContext.getResourceAsStream(<strong class="hl-string"><em style="color:navy">"/WEB-INF/web.xml"</em></strong>); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问Jar/Zip文件中的资源</span></dt><dd><p>下面的代码读取被打包在Jar文件中的资源信息：</p><div class="example"><a id="d0e2921"><!--anchor d0e2921--></a><p class="title"><strong>例 5.4. 访问Jar/Zip文件中的资源</strong></p><div class="example-contents"><pre class="programlisting">URL jarURL = <strong class="hl-keyword" style="color: maroon">new</strong> File(System.getProperty(<strong class="hl-string"><em style="color:navy">"java.home"</em></strong>) + <strong class="hl-string"><em style="color:navy">"/lib/rt.jar"</em></strong>).toURI().toURL();
URL resourceURL = <strong class="hl-keyword" style="color: maroon">new</strong> URL(<strong class="hl-string"><em style="color:navy">"jar:"</em></strong> + jarURL + <strong class="hl-string"><em style="color:navy">"!/java/lang/String.class"</em></strong>); <em class="hl-comment" style="color: green">// 取得URL</em>
InputStream resourceContent = resourceURL.openStream(); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问其它资源</span></dt><dd><p>还可以想到一些访问资源的方法，例如从数据库中取得资源数据。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2932"><!--anchor d0e2932--></a>5.1.4. 如何遍历资源？</h3></div></div></div><p>有时候，我们不知道资源的路径，但希望能找出所有符合条件的资源，这个操作叫作遍历。例如，找出所有符合pattern
                    “<code class="code">/WEB-INF/webx-*.xml</code>”的配置文件。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">遍历文件系统</span></dt><dd><div class="example"><a id="d0e2945"><!--anchor d0e2945--></a><p class="title"><strong>例 5.5. 遍历文件系统</strong></p><div class="example-contents"><pre class="programlisting">File parentResource = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"c:\\windows"</em></strong>);
File[] subResources = parentResource.listFiles();</pre></div></div></dd><dt><span class="term">遍历WEB应用中的资源</span></dt><dd><div class="example"><a id="d0e2954"><!--anchor d0e2954--></a><p class="title"><strong>例 5.6. 遍历WEB应用中的资源</strong></p><div class="example-contents"><pre class="programlisting">Set&lt;String&gt; subResources = servletContext.getResourcePaths(<strong class="hl-string"><em style="color:navy">"/WEB-INF/"</em></strong>);</pre></div></div></dd><dt><span class="term">遍历Jar/zip文件中的资源</span></dt><dd><div class="example"><a id="d0e2963"><!--anchor d0e2963--></a><p class="title"><strong>例 5.7. 遍历Jar/zip文件中的资源</strong></p><div class="example-contents"><pre class="programlisting">File jar = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"myfile.jar"</em></strong>);
ZipInputStream zis = <strong class="hl-keyword" style="color: maroon">new</strong> ZipInputStream(<strong class="hl-keyword" style="color: maroon">new</strong> FileInputStream(jar));

<strong class="hl-keyword" style="color: maroon">try</strong> {
    <strong class="hl-keyword" style="color: maroon">for</strong> (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {
        <em class="hl-comment" style="color: green">// visit entry</em>
    }
} <strong class="hl-keyword" style="color: maroon">finally</strong> {
    zis.close();
}</pre></div></div></dd></dl></div><p>并非所有类型的资源都支持遍历操作。通常遍历操作会涉及比较复杂的递归算法。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2970"><!--anchor d0e2970--></a>5.1.5. 有什么问题？</h3></div></div></div><p>应用程序访问资源时，有什么问题呢？</p><p>首先，资源表现形式的多样性，给应用程序的接口设计带来一点麻烦。假如，我写一个<code class="code">ConfigReader</code>类，用来读各种配置文件。那么我可能需要在接口中列出所有的资源的形式：</p><div class="example"><a id="d0e2980"><!--anchor d0e2980--></a><p class="title"><strong>例 5.8. 用来读取配置文件的接口</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> ConfigReader {
    Object readConfig(File configFile);
    Object readConfig(URL configURL);
    Object readConfig(InputStream configStream);
}</pre></div></div><p>特别是当一个通用的框架，如Spring和Webx，需要在对象之间传递各种形式的资源的时候，这种多样性将导致很大的编程困难。</p><p>其次，有这么多种查找资源和遍历资源的方法，使我们的应用程序和资源所在的环境高度耦合。这种耦合会妨碍代码的可移植性和可测试性。</p><p>比如，我希望在非WEB的环境下测试一个模块，但这个模块因为要存取Web应用下的资源，而引用了<code class="code">ServletContext</code>对象。在测试环境中并不存在<code class="code">ServletContext</code>而导致该模块难以被测试。再比如，我希望测试的一个模块，引用了classpath下的某个配置文件（这也是一种耦合）。而我希望用另一个专为该测试打造的配置文件来代替这个文件。由于原配置文件是在classpath中，因此是难以替换的。</p><p>对于不打算重用的应用程序来说，这个问题还不太严重：大不了我预先设定好，就从这个地方，以固定的方式存取资源。然而就算这样，也是挺麻烦的。有的人喜欢把资源放在某个子目录下，有的人喜欢把资源放在CLASSPATH下，又有人总是通过<code class="code">ServletContext</code>来存取Web应用下的资源。当你要把这些不同人写的模块整合起来时，你会发现很难管理。</p><p>一种可能发生的情形是，因为某些原因，环境发生改变，导致资源的位置、存取方式不得不跟着改变。比如将老系统升级为新系统。但一些不得不继续使用的老代码，由于引用了旧环境的资源而不能工作
                ——
                除非你去修改这些代码。有时修改老代码是很危险的，可能导致不可预知的错误。又比如，由于存储硬件的改变或管理的需要，我们需要将部分资源移到另一个地方（我们曾经将Web页面模板中的某个子目录，移动到一个新的地方，因为这些模板必须由新的CMS系统自动生成）。想要不影响现有代码来完成这些事，是很困难的。
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e3004"><!--anchor d0e3004--></a>5.2. Spring的<code class="code">ResourceLoader</code>机制</h2></div></div></div><p>Spring内置了一套<code class="code">ResourceLoader</code>机制，很好地解决了访问资源的大部分问题。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3015"><!--anchor d0e3015--></a>5.2.1. <code class="code">Resource</code>接口</h3></div></div></div><p>Spring将所有形式的资源表现概括成一个<code class="code">Resource</code>接口。如下所示（下面的接口定义是被简化的，有意省略了一些东西，以便突出重点）：</p><div class="example"><a id="d0e3025"><!--anchor d0e3025--></a><p class="title"><strong>例 5.9. Spring的<code class="code">Resource</code>接口（简化）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> Resource {
    InputStream getInputStream();
    URL getURL();
    File getFile();
    <strong class="hl-keyword" style="color: maroon">boolean</strong> exists();
}</pre></div></div><p><code class="code">Resource</code>接口向应用程序屏蔽了资源表现形式的多样性。于是，前面例子中的<code class="code">ConfigReader</code>就可以被简化成下面的样子：</p><div class="example"><a id="d0e3040"><!--anchor d0e3040--></a><p class="title"><strong>例 5.10. 用来读取配置文件的接口（简化后）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> ConfigReader {
    Object readConfig(Resource configResource);
}</pre></div></div><p>事实上，Spring正是利用<code class="code">Resource</code>接口来初始化它的<code class="code">ApplicationContext</code>的：</p><div class="example"><a id="d0e3053"><!--anchor d0e3053--></a><p class="title"><strong>例 5.11. Spring用<code class="code">Resource</code>接口来代表用来初始化<code class="code">ApplicationContext</code>的配置文件</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">abstract</strong> <strong class="hl-keyword" style="color: maroon">class</strong> AbstractXmlApplicationContext <strong class="hl-keyword" style="color: maroon">extends</strong> ... {
    ...
    <strong class="hl-keyword" style="color: maroon">protected</strong> <strong class="hl-keyword" style="color: maroon">void</strong> loadBeanDefinitions(XmlBeanDefinitionReader reader) {
        Resource[] configResources = getConfigResources();
        ...
    }

    <strong class="hl-keyword" style="color: maroon">protected</strong> Resource[] getConfigResources();
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3064"><!--anchor d0e3064--></a>5.2.2. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</h3></div></div></div><p>Spring不仅可以通过<code class="code">ResourceLoader</code>接口来取得单一的资源对象，还可以通过<code class="code">ResourcePatternResolver</code>遍历并取得多个符合指定pattern的资源对象。这个设计向应用程序屏蔽了查找和遍历资源的复杂性。</p><div class="figure"><a id="d0e3080"><!--anchor d0e3080--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/spring-interfaces.png" alt="ResourceLoader和ResourcePatternResolver接口"/></div></div><p class="title"><strong>图 5.1. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3091"><!--anchor d0e3091--></a>5.2.3. 在代码中取得资源</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3094"><!--anchor d0e3094--></a>5.2.3.1. 通过<code class="code">ResourceLoader</code>取得资源</h4></div></div></div><div class="example"><a id="d0e3100"><!--anchor d0e3100--></a><p class="title"><strong>例 5.12. 通过<code class="code">ResourceLoader</code>取得资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyBean <strong class="hl-keyword" style="color: maroon">implements</strong> ResourceLoaderAware <a id="co.rl.aware"><!--anchor co.rl.aware--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> {
    <strong class="hl-keyword" style="color: maroon">private</strong> ResourceLoader loader;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setResourceLoader(ResourceLoader loader) <a id="co.rl.aware2"><!--anchor co.rl.aware2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> {
        <strong class="hl-keyword" style="color: maroon">this</strong>.loader = loader;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> func() {
        Resource resource = loader.getResource(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>); <a id="co.rl.aware.getres"><!--anchor co.rl.aware.getres--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        ...
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.aware"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.rl.aware2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>实现了<code class="code">ResourceLoaderAware</code>接口。要取得资源，必须要拿到<code class="code">ResourceLoader</code>对象。而通过<code class="code">ResourceLoaderAware</code>接口拿到<code class="code">ResourceLoader</code>是最简单的方法。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.aware.getres"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>调用所取得的<code class="code">ResourceLoader</code>来取得资源。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3136"><!--anchor d0e3136--></a>5.2.3.2. 直接注入资源</h4></div></div></div><p>另一种更简便的方法是，将资源直接“注入”到bean中 ——
                    你不需要手工调用<code class="code">ResourceLoader</code>来取得资源的方式来设置资源。例如：</p><div class="example"><a id="d0e3144"><!--anchor d0e3144--></a><p class="title"><strong>例 5.13. 直接注入资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyBean {
    <strong class="hl-keyword" style="color: maroon">private</strong> URL resource;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setLocation(URL resource) <a id="co.rl.inject.url"><!--anchor co.rl.inject.url--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> {
        <strong class="hl-keyword" style="color: maroon">this</strong>.resource = resource;
    }

    ……
}</pre><p>Spring配置文件可以这样写：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"myBean"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"MyBean"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"location"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"myFile.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.inject.url"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处注入资源的URL</p></td></tr></table></div></div></div><p>这样，Spring就会把适当的<code class="filename">myFile.xml</code>所对应的资源注入到<code class="code">myBean</code>对象中。此外，Spring会自动把<code class="code">Resource</code>对象转换成<code class="code">URL</code>、<code class="code">File</code>等普通对象。在上面的例子中，<code class="code">MyBean</code>并不依赖于<code class="code">Resource</code>接口，只依赖于<code class="code">URL</code>类。</p><p>将代码稍作修改，就可以注入一组资源：</p><div class="example"><a id="d0e3187"><!--anchor d0e3187--></a><p class="title"><strong>例 5.14. 注入一组资源</strong></p><div class="example-contents"><pre class="programlisting">    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setLocations(URL[] resources) <a id="co.rl.inject.urls"><!--anchor co.rl.inject.urls--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> {
        <strong class="hl-keyword" style="color: maroon">this</strong>.resources = resources;
    }</pre><p>配置文件：</p><pre class="programlisting">    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"locations"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"WEB-INF/webx-*.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.inject.urls"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处注入资源的URL的数组。</p></td></tr></table></div></div></div><p>上例中，可以直接得到所有符合pattern
                        “<code class="code">WEB-INF/webx-*.xml</code>”的配置文件。显然这是通过<code class="code">ResourcePatternResolver</code>取得的。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3210"><!--anchor d0e3210--></a>5.2.4. Spring如何装载资源？</h3></div></div></div><p>Spring是如何装载资源文件的呢？Spring装载资源的方案是由<code class="code">ApplicationContext</code>决定的。不同的<code class="code">ApplicationContext</code>类，实现了不同的资源装载方案。</p><div class="figure"><a id="d0e3221"><!--anchor d0e3221--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/spring-rl-impl.png" alt="Spring ApplicationContext实现了资源装载的具体方案"/></div></div><p class="title"><strong>图 5.2. Spring <code class="code">ApplicationContext</code>实现了资源装载的具体方案</strong></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3230"><!--anchor d0e3230--></a>5.2.4.1. <code class="code">ClassPathXmlApplicationContext</code></h4></div></div></div><p><code class="code">ClassPathXmlApplicationContext</code>支持从classpath中装载资源。</p><div class="example"><a id="d0e3238"><!--anchor d0e3238--></a><p class="title"><strong>例 5.15. <code class="code">ClassPathXmlApplicationContext</code> - 从classpath中装载资源</strong></p><div class="example-contents"><p>假如我以下面的方式启动Spring，那么系统将支持从<span class="emphasis"><em>classpath中</em></span>装载资源。</p><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> ClassPathXmlApplicationContext(<strong class="hl-string"><em style="color:navy">"beans.xml"</em></strong>);</pre><p><code class="code">ClassPathXmlApplicationContext</code>装载资源文件<code class="filename">myFile.xml</code>的逻辑，相当于如下代码：</p><pre class="programlisting">URL resource = getClassLoader().getResource(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3259"><!--anchor d0e3259--></a>5.2.4.2. <code class="code">FileSystemXmlApplicationContext</code></h4></div></div></div><p><code class="code">FileSystemXmlApplicationContext</code>支持从文件系统中装载资源。</p><div class="example"><a id="d0e3267"><!--anchor d0e3267--></a><p class="title"><strong>例 5.16. <code class="code">FileSystemXmlApplicationContext</code> - 从文件系统中装载资源</strong></p><div class="example-contents"><p>假如我以下面的方式启动Spring，那么系统将支持从<span class="emphasis"><em>文件系统中</em></span>装载资源。</p><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> FileSystemXmlApplicationContext(<strong class="hl-string"><em style="color:navy">"beans.xml"</em></strong>);</pre><p><code class="code">FileSystemXmlApplicationContext</code>装载资源文件<code class="filename">myFile.xml</code>的逻辑，相当于如下代码：</p><pre class="programlisting">File resource = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3288"><!--anchor d0e3288--></a>5.2.4.3. <code class="code">XmlWebApplicationContext</code></h4></div></div></div><p><code class="code">XmlWebApplicationContext</code>支持从webapp上下文中（也就是<code class="code">ServletContext</code>对象中）装载资源。</p><div class="example"><a id="d0e3299"><!--anchor d0e3299--></a><p class="title"><strong>例 5.17. <code class="code">XmlWebApplicationContext</code> - 从Web应用的根目录中装载资源</strong></p><div class="example-contents"><p>假如我以下面的方式启动Spring，那么系统将支持从<span class="emphasis"><em>Web应用的根目录中</em></span>装载资源。</p><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> XmlWebApplicationContext();

context.setConfigLocation(<strong class="hl-string"><em style="color:navy">"/WEB-INF/beans.xml"</em></strong>);
context.setServletContext(servletContext);
context.refresh();</pre><p>也可以让<code class="code">ContextLoaderListener</code>来创建<code class="code">XmlWebApplicationContext</code>，只需要在<code class="filename">/WEB-INF/web.xml</code>中添加如下配置：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>contextConfigLocation<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>/WEB-INF/beans.xml<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong>org.springframework.web.context.ContextLoaderListener<strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong></pre><p><code class="code">XmlWebApplicationContext</code>装载资源文件<code class="filename">myFile.xml</code>的逻辑，相当于如下代码：</p><pre class="programlisting">URL resource = servletContext.getResource(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3333"><!--anchor d0e3333--></a>5.2.4.4. <code class="code">Classpath</code>和<code class="code">Classpath*</code>前缀</h4></div></div></div><p>除了用<code class="code">ClassPathXmlApplicationContext</code>以外，事实上所有的Spring
                        <code class="code">ApplicationContext</code>实现也都支持装载classpath中的资源。可以用下面两种方法：</p><div class="table"><a id="d0e3349"><!--anchor d0e3349--></a><p class="title"><strong>表 5.2. Spring <code class="code">ApplicationContext</code>装载classpath资源的方法</strong></p><div class="table-contents"><table summary="Spring ApplicationContext装载classpath资源的方法" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="74%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">方法</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">使用<code class="code">classpath:</code>前缀</td><td style="border-bottom: 0.5pt solid #6666cc; ">例如：“<code class="code">classpath:myFile.xml</code>” ——
                                        在classpath中装载资源<code class="code">myFile.xml</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">使用<code class="code">classpath*:</code>前缀</td><td style="">例如：“<code class="code">classpath*:/META-INF/my*.xml</code>” ——
                                    在classpath中装载所有符合pattern的资源。</td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3390"><!--anchor d0e3390--></a>5.2.5. Spring <code class="code">ResourceLoader</code>的缺点</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">鱼和熊掌不可得兼</span></dt><dd><p>Spring
                                <code class="code">ResourceLoader</code>是由<code class="code">ApplicationContext</code>来实现的。而你一次只能选择一种<code class="code">ApplicationContext</code>的实现
                            ——
                                如果你选择了<code class="code">XmlWebApplicationContext</code>，你就放弃了<code class="code">FileSystemXmlApplicationContext</code>；反之亦然。</p><p>在WEB应用中，由于Spring使用了<code class="code">XmlWebApplicationContext</code>，因此你就无法装载文件系统下的资源。</p></dd><dt><span class="term">不透明性</span></dt><dd><p>你必须用“绝对路径”来引用Spring中的资源。</p><p>假如你使用<code class="code">FileSystemXmlApplicationContext</code>来访问资源，你必须使用绝对路径来访问文件或目录资源。这妨碍了应用程序在不同系统中部署的自由。因为在不同的系统中，例如Windows和Linux，文件的绝对路径是不同的。为了系统管理的需要，有时也需要将文件或目录放在不同于开发环境的地方。</p><p>即便是访问WEB应用下的资源，或者是classpath下的资源，你也必须明确指出它们的位置，例如：<code class="code">WEB-INF/myFile.xml</code>、<code class="code">classpath:myFile.xml</code>等。如果我希望把<code class="code">classpath:myFile.xml</code>挪到另一个物理位置，就必须修改所有的引用。</p></dd><dt><span class="term">无扩展性</span></dt><dd><p>我无法在Spring
                                <code class="code">ResourceLoader</code>机制中增加一种新的装载资源的方法。例如，我希望把资源文件保存在数据库中，并用<code class="code">ResourceLoader</code>来取得它。用Spring很难做到这点。</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e3457"><!--anchor d0e3457--></a>5.3. Resource Loading服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3460"><!--anchor d0e3460--></a>5.3.1. 替换Spring <code class="code">ResourceLoader</code></h3></div></div></div><p>Webx Resource Loading服务可作为Spring <code class="code">ResourceLoader</code>机制的替代品（Drop-in Replacement，投入既替换）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>当你不使用它时，Spring原有的<code class="code">ResourceLoader</code>功能不受影响；</p></li><li class="listitem"><p>当你在spring配置文件中添加Resource
                            Loading服务时，<code class="code">ResourceLoader</code>即被切换到新的机制。新的机制可兼容原有的Spring配置和代码，但支持更多的资源装载方式，以及更多的功能，如资源重命名、资源重定向等。</p></li></ul></div><p>你只需要在配置文件中增加以下内容，就可以将Spring <code class="code">ResourceLoader</code>机制替换成Webx的Resource
                Loading服务：</p><div class="example"><a id="d0e3488"><!--anchor d0e3488--></a><p class="title"><strong>例 5.18. Resource Loading服务的基本配置（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.basic.alias.root"><!--anchor co.rl.basic.alias.root--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.basic.def.webroot"><!--anchor co.rl.basic.def.webroot--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong> <a id="co.rl.basic.webroot"><!--anchor co.rl.basic.webroot--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/classpath"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.basic.def.classpath"><!--anchor co.rl.basic.def.classpath--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong> <a id="co.rl.basic.classpath"><!--anchor co.rl.basic.classpath--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/ resource-loading&gt;</strong></pre><div class="calloutlist"><p>关于这段配置的具体含义，请参见本章其它小节：</p><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.alias.root"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="resourceloading.html#webx.resource.rename.res" title="5.3.3. 重命名资源">第 5.3.3 节 “重命名资源”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.def.webroot"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.rl.basic.def.classpath"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="resourceloading.html#webx.resource.define.newres" title="5.3.2. 定义新资源">第 5.3.2 节 “定义新资源”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.webroot"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="resourceloading.html#webx.resource.loader.webapp" title="5.4.2. WebappResourceLoader">第 5.4.2 节 “<code class="code">WebappResourceLoader</code>”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.classpath"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="resourceloading.html#webx.resource.loader.classpath" title="5.4.3. ClasspathResourceLoader">第 5.4.3 节 “<code class="code">ClasspathResourceLoader</code>”</a>。</p></td></tr></table></div></div></div><p>这段配置使得Resource Loading服务的行为和原来的Spring <code class="code">ResourceLoader</code>完全兼容：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>仍然支持<code class="code">classpath:</code>和<code class="code">classpath*:</code>前缀所定义的资源。</p></li><li class="listitem"><p>如不加前缀，则代表访问WEB应用根目录下的文件。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="filename">/myFile.xml</code>代表着Web应用根目录下的<code class="filename">/myFile.xml</code>。</p></li><li class="listitem"><p><code class="filename">/WEB-INF/myFile.xml</code>代表着Web应用根目录下的<code class="filename">/WEB-INF/myFile.xml</code>。</p></li></ul></div></li></ul></div><p>加上这段配置以后，虽然功能和原来相比并没有变化，然而它已经准备好向系统中添加新的资源装载的功能了。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.define.newres"><!--anchor webx.resource.define.newres--></a>5.3.2. 定义新资源</h3></div></div></div><p>定义一种新资源，需要回答两个问题：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>资源的名称是什么？</p></li><li class="listitem"><p>资源在哪里（或如何装载资源）？</p></li></ol></div><p>下面的例子定义了一种新的资源，它的名称是“<code class="code">/jdk/*</code>”，通过“<code class="code">file-loader</code>”从文件系统<code class="code">${java.home}</code>文件夹中装载。</p><div class="example"><a id="d0e3589"><!--anchor d0e3589--></a><p class="title"><strong>例 5.19. 定义新资源：<code class="code">/jdk/*</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/jdk"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.define.res.jdk"><!--anchor co.rl.define.res.jdk--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${java.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.loader.file"><!--anchor co.rl.loader.file--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.define.res.jdk"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义新资源，资源名以<code class="code">/jdk</code>为前缀。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.loader.file"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;file-loader&gt;</code>表示从文件系统中装载资源。详见：<a class="xref" href="resourceloading.html#webx.resource.loader.file" title="5.4.1. FileResourceLoader">第 5.4.1 节 “<code class="code">FileResourceLoader</code>”</a>。</p><p><code class="code">${java.home}</code>是Java提供的system
                            property，它的值指向当前Java运行环境的根目录。</p></td></tr></table></div></div></div><p>前文讲过，Spring可以直接把资源注入到对象中。使用Resource
                    Loading服务以后，你仍然可以这样做。下面的配置把JDK目录下的<code class="code">tools.jar</code>文件（如果存在的话）的URL注入到<code class="code">myBean</code>中：</p><div class="example"><a id="d0e3626"><!--anchor d0e3626--></a><p class="title"><strong>例 5.20. 注入<code class="code">JAVA_HOME/lib/tools.jar</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"myBean"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"MyBean"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"location"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"/jdk/lib/tools.jar"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.rename.res"><!--anchor webx.resource.rename.res--></a>5.3.3. 重命名资源</h3></div></div></div><p>重命名资源是指对于即有的资源，改变其名字。</p><p>为什么需要修改资源的名字？理由是：<span class="emphasis"><em>取消资源名称和环境的关联性</em></span>。有一些资源的名称，具有明显的环境相关性，比如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">classpath:myFile.xml</code>或者<code class="code">/classpath/myFile.xml</code>
                            —— 从资源的名称就可以看出，这些资源是从classpath中装载的。</p></li><li class="listitem"><p><code class="code">/WEB-INF/myFile.xml</code>或者<code class="code">/webroot/WEB-INF/myFile.xml</code>
                            —— 从资源的名称可以看出，这些资源是从web应用中装载的。</p></li></ul></div><p>使用和环境相关的资源名称有什么问题？问题就是，当环境改变时，应用代码会受到影响。最常见的一种状况是：单元测试时，用于测试的资源文件往往被放在专供测试的目录中，这些目录和应用运行时的环境是不同的
                ——
                    你可能希望将<code class="code">classpath:myFile.xml</code>或<code class="code">/WEB-INF/myFile.xml</code>改成<code class="code">/src/test/config/myFile.xml</code>。</p><p>对资源重命名就可以解决这类问题：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>将<code class="code">classpath:myFile.xml</code>或者<code class="code">/WEB-INF/myFile.xml</code>重命名成：<code class="code">myapp/conf/myFile.xml</code>。</p></li><li class="listitem"><p>在测试环境中，将<code class="code">myapp/conf/myFile.xml</code>名称指向另一个物理地址<code class="code">src/test/config/myFile.xml</code>。
                        </p></li></ul></div><p>重命名资源是通过alias别名实现的：</p><div class="example"><a id="d0e3697"><!--anchor d0e3697--></a><p class="title"><strong>例 5.21. 重命名资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.alias.conf"><!--anchor co.rl.alias.conf--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.res.webroot"><!--anchor co.rl.res.webroot--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong> <a id="co.rl.res.webroot.loader"><!--anchor co.rl.res.webroot.loader--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.alias.conf"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义了一个资源的别名：<code class="code">/myapp/conf</code>。</p><p>当你查找<code class="code">/myapp/conf/myFile.xml</code>时，Resource
                                Loading服务实际上会去找<code class="code">/webroot/WEB-INF/myFile.xml</code>。而<code class="code">/webroot/*</code>则是由
                                <a id="co.rl.res.webroot"><!--anchor co.rl.res.webroot--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> 所定义的资源。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.res.webroot"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义以<code class="code">/webroot</code>为前缀的新资源。</p><p>其中，attribute
                                <span class="emphasis"><em><code class="code">internal=true</code></em></span>是一个可选项，当它的值为<code class="code">true</code>时，代表它所修饰的资源是不能被外界所直接访问的。例如，你想直接在<code class="code">myBean</code>中注入<code class="code">/webroot/WEB-INF/myFile.xml</code>是不行的。把<code class="code">internal</code>选项设成<code class="code">true</code>，可以让强制用户转向新的资源名称。<code class="code">Internal</code>参数的默认值为<code class="code">false</code>，意味着，新旧两种名称同时可用。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.res.webroot.loader"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;webapp-loader&gt;</code>表示从Web应用中装载资源。详见：<a class="xref" href="resourceloading.html#webx.resource.loader.webapp" title="5.4.2. WebappResourceLoader">第 5.4.2 节 “<code class="code">WebappResourceLoader</code>”</a>。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.redirect.res"><!--anchor webx.resource.redirect.res--></a>5.3.4. 重定向资源</h3></div></div></div><p>重定向资源的意思是，将部分资源名称，指向另外的地址。</p><p>一个常见的需求是这样的：通常我们会把页面模板保存在WEB应用的<code class="code">/templates</code>目录下。但是有一批模板是由外部的CMS系统生成的，这些模板文件不可能和WEB应用打包在一起，而是存放在某个外部的目录下的。我们希望用<code class="code">/templates/cms</code>来引用这些模板。</p><p>由于<code class="code">/templates/cms</code>只不过是<code class="code">/templates</code>的子目录，所以如果没有Resource
                Loading服务所提供的重定向功能，是不可能实现上述功能的。用Resource Loading服务重定向的配置如下：</p><div class="example"><a id="d0e3789"><!--anchor d0e3789--></a><p class="title"><strong>例 5.22. 重定向资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/templates"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/templates"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.alias.templates"><!--anchor co.rl.alias.templates--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/templates/cms"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.define.templates.cms"><!--anchor co.rl.define.templates.cms--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${cms_root}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    ...
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.alias.templates"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义了一个资源的别名：<code class="code">/templates</code>，指向internal资源：<code class="code">/webroot/templates</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.define.templates.cms"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将<code class="code">/templates</code>的子目录<code class="code">/templates/cms</code>重定向到某个外部的文件目录<code class="code">${cms_root}</code>中。</p><p>其中<code class="code">cms_root</code>是启动服务器时所指定的system
                                property（<code class="code">-Dcms_root=...</code>）或者spring所定义的placeholder。</p></td></tr></table></div></div></div><p>通过上述配置，可以达到如下效果：</p><div class="table"><a id="d0e3830"><!--anchor d0e3830--></a><p class="title"><strong>表 5.3. 访问<code class="code">/templates</code>目录下的资源</strong></p><div class="table-contents"><table summary="访问/templates目录下的资源" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">资源名</th><th style="border-bottom: 0.5pt solid #6666cc; ">如何装载？</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">/templates/xxx.vm</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">不受重定向影响。访问<code class="code">/webroot/templates/xxx.vm</code>，继而通过<code class="code">webapp-loader</code>访问Web应用根目录下的<code class="filename">/templates/xxx.vm</code>文件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">/templates/cms/yyy.vm</code></td><td style="border-bottom: 0.5pt solid #6666cc; "><span class="emphasis"><em>被重定向</em></span>。通过<code class="code">file-loader</code>访问<code class="code">${cms_root}</code>目录下的文件：<code class="filename">${cms_root}/yyy.vm</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">/templates/subdir/zzz.vm</code></td><td style="">不受重定向影响。访问<code class="code">/webroot/templates/subdir/zzz.vm</code>，继而通过<code class="code">webapp-loader</code>访问Web应用根目录下的<code class="filename">/templates/subdir/zzz.vm</code>文件。</td></tr></tbody></table></div></div><p>最重要的是，<span class="emphasis"><em>访问<code class="code">/templates</code>目录的应用程序并不知道这个资源重定向的存在</em></span>，当cms所对应的实际目录被改变时，应用程序也不会受到任何影响
                —— 这个正是Resource Loading服务的“魔法”。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.matching"><!--anchor webx.resource.matching--></a>5.3.5. 匹配资源</h3></div></div></div><p>无论是定义新资源（<code class="code">&lt;resource&gt;</code>）或是重命名资源（资源别名、<code class="code">&lt;resource-alias&gt;</code>），都需要指定一个<code class="code">pattern</code>
                attribute来匹配资源的名称。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.resource.matching.type"><!--anchor webx.resource.matching.type--></a>5.3.5.1. 匹配绝对路径和相对路径</h4></div></div></div><p>资源或资源别名的pattern支持对绝对路径和相对路径的匹配：</p><div class="table"><a id="d0e3920"><!--anchor d0e3920--></a><p class="title"><strong>表 5.4. 资源或别名的<code class="code">pattern</code>格式</strong></p><div class="table-contents"><table summary="资源或别名的pattern格式" cellpadding="10" style="border: none;"><colgroup><col width="14%" class="c1"/><col width="20%" class="c2"/><col width="66%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">pattern类型</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">格式</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">匹配绝对路径</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p><code class="code">/absolute/path</code></p></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p><span class="emphasis"><em>以<code class="code">/</code>开头的pattern</em></span>代表一个绝对路径的匹配。</p>
                                    <p>例如：<code class="code">pattern="/absolute/path"</code>可以匹配资源名<code class="code">/abslute/path/xxx/yyy</code>，但不能匹配资源名<code class="code">/xxx/abslute/path/yyy</code>。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">匹配相对路径</td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">
                                    <p><code class="code">relative/path</code></p>
                                </td><td style="" valign="middle">
                                    <p><span class="emphasis"><em>不以<code class="code">/</code>开头的pattern</em></span>代表一个相对路径的匹配。</p>
                                    <p>例如：<code class="code">pattern="relative/path"</code>可以匹配资源名<code class="code">/relative/path/xxx/yyy</code>，也可以匹配资源名<code class="code">/xxx/relative/path/yyy</code>。</p>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.resource.matching.wildcard"><!--anchor webx.resource.matching.wildcard--></a>5.3.5.2. 匹配通配符</h4></div></div></div><div class="table"><a id="d0e4003"><!--anchor d0e4003--></a><p class="title"><strong>表 5.5. 通配符格式</strong></p><div class="table-contents"><table summary="通配符格式" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c2"/><col width="80%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">格式</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">星号 <code class="code">*</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">匹配0-n个字符，但不包括“<code class="code">/</code>”。即，“<code class="code">*</code>”只匹配一级目录或文件中的零个或多个字符。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">双星号 <code class="code">**</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">匹配0-n个字符，包括“<code class="code">/</code>”。即，“<code class="code">**</code>”匹配多级目录或文件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">问号 <code class="code">?</code></td><td style="" valign="middle">匹配0-1个字符，但不包括“<code class="code">/</code>”。即，“<code class="code">?</code>”匹配一级目录或文件中的零个或一个字符。</td></tr></tbody></table></div></div><p>所有被通配符匹配的内容，将被按顺序赋给变量“<code class="code">$1</code>”、“<code class="code">$2</code>”、“<code class="code">$3</code>”、“<code class="code">$4</code>”、……。这些变量可以在其它地方被引用。</p><p>通配符匹配的名称既可以是绝对路径，也可以是相对路径。把相对路径和通配符结合起来的最常见用法，就是匹配文件名后缀，例如：<code class="code">pattern="*.xml"</code>。</p><p>下面是一些使用通配符的例子：</p><div class="example"><a id="d0e4076"><!--anchor d0e4076--></a><p class="title"><strong>例 5.23. 用通配符来匹配资源名称或资源别名</strong></p><div class="example-contents"><div class="variablelist"><dl class="variablelist"><dt><span class="term">重命名<code class="code">WEB-INF</code>及其子目录下的所有的xml文件</span></dt><dd><p>例如，将<code class="code">/myapp/conf/my/file.xml</code>转换成<code class="code">/webroot/WEB-INF/my/file.xml</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf/**/*.xml"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF/$1/$2.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></dd><dt><span class="term">修改文件名后缀</span></dt><dd><p>例如，将<code class="code">/myapp/conf/myfile.conf</code>转换成<code class="code">/webroot/WEB-INF/myfile.xml</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf/*.conf"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/WEB-INF/$1.xml"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong></pre></dd><dt><span class="term">按首字母划分子目录</span></dt><dd><p>将<code class="code">a</code>开头的文件名放到<code class="code">a</code>子目录下，<code class="code">b</code>开头的文件名放到<code class="code">b</code>子目录下，以此类推。</p><p>例如，将<code class="code">/profiles/myname</code>转换成文件路径<code class="code">${profile_root}/m/myname</code>；将<code class="code">/profiles/othername</code>转换成文件路径<code class="code">${profile_root}/o/othername</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/profiles/?*"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${profile_root}"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:path&gt;</strong>$1/$1$2<strong class="hl-tag" style="color: #000096">&lt;/res-loaders:path&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/res-loaders:file-loader&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></dd></dl></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.multi.loaders"><!--anchor webx.resource.multi.loaders--></a>5.3.6. 在多个<code class="code">ResourceLoader</code>中查找</h3></div></div></div><p>假如，在我的Web应用中，我有一些配置文件放在<code class="code">/WEB-INF</code>目录中，另外一部分配置放在classpath中。我可以这样做：</p><div class="example"><a id="d0e4156"><!--anchor d0e4156--></a><p class="title"><strong>例 5.24. 在多个<code class="code">ResourceLoader</code>中查找</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.multi.loaders.1.webroot"><!--anchor co.rl.multi.loaders.1.webroot--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/classpath"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.multi.loaders.2.classpath"><!--anchor co.rl.multi.loaders.2.classpath--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.multi.loaders.define.webroot"><!--anchor co.rl.multi.loaders.define.webroot--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/classpath"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.multi.loaders.define.classpath"><!--anchor co.rl.multi.loaders.define.classpath--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    ...
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.multi.loaders.1.webroot"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.rl.multi.loaders.2.classpath"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>依次尝试两个loaders。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.multi.loaders.define.webroot"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义internal资源<code class="code">/webroot/*</code>，从Web应用中装载资源。详见<a class="xref" href="resourceloading.html#webx.resource.loader.webapp" title="5.4.2. WebappResourceLoader">第 5.4.2 节 “<code class="code">WebappResourceLoader</code>”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.multi.loaders.define.classpath"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义internal资源<code class="code">/classpath/*</code>，从classpath中装载资源。详见<a class="xref" href="resourceloading.html#webx.resource.loader.classpath" title="5.4.3. ClasspathResourceLoader">第 5.4.3 节 “<code class="code">ClasspathResourceLoader</code>”</a>。</p></td></tr></table></div></div></div><p>Resource Loading服务根据上面的配置，会这样查找资源“<code class="code">/myapp/conf/myFile.xml</code>”：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>先查找：<code class="code">/webroot/WEB-INF/myFile.xml</code>，如果找不到，</p></li><li class="listitem"><p>则再查找：<code class="code">/classpath/myFile.xml</code>，如果找不到，则放弃。</p></li></ol></div><p>在上例中，<code class="code">&lt;super-loader&gt;</code>（详见<a class="xref" href="resourceloading.html#webx.resource.loader.super" title="5.4.4. SuperResourceLoader">第 5.4.4 节 “<code class="code">SuperResourceLoader</code>”</a>）是一种特殊的<code class="code">ResourceLoader</code>，它等同于<code class="code">&lt;resource-alias&gt;</code>。下面的两种写法是完全等同的：</p><div class="example"><a id="d0e4223"><!--anchor d0e4223--></a><p class="title"><strong>例 5.25. <code class="code">&lt;super-loader&gt;</code>和等效的<code class="code">&lt;resource-alias&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf "</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>但是用<code class="code">&lt;resource-alias&gt;</code>没有办法实现上面所述的多重查找的功能。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.load.parent"><!--anchor webx.resource.load.parent--></a>5.3.7. 装载parent容器中的资源</h3></div></div></div><p>在Webx中，Spring容器被安排成级联的结构。</p><div class="figure"><a id="d0e4242"><!--anchor d0e4242--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/context-hierarchy.png" alt="Spring容器的级联结构"/></div></div><p class="title"><strong>图 5.3. Spring容器的级联结构</strong></p></div><p>如图所示，每个Spring容器都可以配置自己的Resource Loading服务。当调用子容器的Resource Loading服务时，遵循这样的逻辑：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>先在子容器的Resource Loading服务中查找资源，如果找不到，</p></li><li class="listitem"><p>则再到parent容器的Resource Loading服务中查找，如果找不到，则放弃。</p></li></ol></div><p>运用这种级联装载资源的方法，子应用可以把共享的资源定义在root context中，而把自己独享的资源定义在自己的容器当中。</p><p>前文所述的<code class="code">&lt;super-loader&gt;</code>也支持级联装载资源。<code class="code">&lt;super-loader&gt;</code>会先在当前容器的Resource
                Loading服务中查找，如果找不到，就到parent容器的Resource
                Loading服务中查找。利用<code class="code">&lt;super-loader&gt;</code>，你甚至可以改变资源搜索的顺序。例如，你可以命令Resource
                Loading服务先查找parent容器中的Resource
                Loading服务，再查找当前容器中的<code class="code">ResourceLoader</code>s：</p><div class="example"><a id="d0e4273"><!--anchor d0e4273--></a><p class="title"><strong>例 5.26. 利用<code class="code">&lt;super-loader&gt;</code>改变资源搜索的顺序</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader /&gt;</strong> <a id="co.rl.load.parent.1.super"><!--anchor co.rl.load.parent.1.super--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader /&gt;</strong> <a id="co.rl.load.parent.2.file"><!--anchor co.rl.load.parent.2.file--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.load.parent.1.super"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>先找parent容器中的Resource Loading服务。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.load.parent.2.file"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>再找当前容器中的<code class="code">ResourceLoader</code>s。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.modify.res"><!--anchor webx.resource.modify.res--></a>5.3.8. 修改资源文件的内容</h3></div></div></div><p>Resource Loading服务支持内容过滤 ——
                你可以在获取资源以前读取甚至修改资源文件的内容。一种常见的情形是，将XML格式的资源文件用XSLT转换格式：</p><div class="example"><a id="d0e4300"><!--anchor d0e4300--></a><p class="title"><strong>例 5.27. 将XML格式的资源文件用XSLT转换格式</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        xmlns:res-filters="http://www.alibaba.com/schema/services/resource-loading/filters"&gt;
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource-filters</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"test-*.xml"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-filters:xslt-filter</strong> <span class="hl-attribute" style="color: #F5844C">xslt</span>=<span class="hl-value" style="color: #993300">"/stylesheet.for.test/test.xsl"</span> <span class="hl-attribute" style="color: #F5844C">saveTo</span>=<span class="hl-value" style="color: #993300">"/tempdir"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.filter.xslt"><!--anchor co.rl.filter.xslt--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource-filters&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/tempdir"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.filter.tempdir"><!--anchor co.rl.filter.tempdir--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${project.home}/target/test"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.filter.xslt"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将<span class="emphasis"><em>所有目录下</em></span>（因为是相对路径）的名称为<code class="filename">test-*.xml</code>文件，用指定的XSL文件进行转换。</p><p>这里引进了一种新的扩展点：<code class="code">ResourceFilter</code>。<code class="code">ResourceFilter</code>可以在应用获取资源之前，取得控制，以便对资源做一点事。</p><p><code class="code">&lt;xslt-filter&gt;</code>是对<code class="code">ResourceFilter</code>的扩展，它能够把XML资源用指定的xsl文件转换成新的格式。假如指定了<code class="code">saveTo</code>参数，就可以把转换的结果保存下来，避免每次访问都重新转换。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.filter.tempdir"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处定义<code class="code">tempdir</code>目录资源，以便保存xslt转换的结果。</p></td></tr></table></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="code">&lt;xslt-filter&gt;</code>的参数<code class="code">xslt</code>所指向的xsl文件，以及参数<code class="code">saveTo</code>所指向的目录，它们本身也是由Resource
                    Loading服务装载的。</p></td></tr></table></div><p>有哪些情况需要这种内容过滤的功能呢？</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>单元测试 —— 我们可能需要对单元测试的资源文件进行特殊的转换。</p></li><li class="listitem"><p>高速缓存 ——
                                有一些<code class="code">ResourceLoader</code>可能会有性能的开销，例如：从数据库中装载资源。利用<code class="code">ResourceFilter</code>功能，就可以把装载的资源缓存在高速cache中，以提高系统的性能。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.using.service"><!--anchor webx.resource.using.service--></a>5.3.9. 直接使用<code class="code">ResourceLoadingService</code></h3></div></div></div><p>前面所讲的Resource Loading服务的用法，对应用程序而言，是完全透明的。也就是说，应用程序并不需要关心Resource
                Loading服务的存在，而是按照Spring <code class="code">ResourceLoader</code>的老用法，就可以工作。</p><p>但是你也可以直接注入<code class="code">ResourceLoadingService</code>对象，以取得更多的功能。</p><div class="example"><a id="d0e4384"><!--anchor d0e4384--></a><p class="title"><strong>例 5.28. 注入<code class="code">ResourceLoadingService</code>对象</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> ResourceLoadingService resourceLoadingService;
}</pre></div></div><p>下面列举了可通过<code class="code">ResourceLoadingService</code>接口实现的功能。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">取得资源</span></dt><dd><div class="example"><a id="d0e4402"><!--anchor d0e4402--></a><p class="title"><strong>例 5.29. 通过<code class="code">ResourceLoadingService</code>接口取得资源</strong></p><div class="example-contents"><pre class="programlisting">Resource resource = resourceLoadingService.getResource(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>); <a id="co.rl.service.getres"><!--anchor co.rl.service.getres--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
Resource resource = resourceLoadingService.getResource(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>,
                                                       ResourceLoadingService.FOR_CREATE); <a id="co.rl.service.getres2"><!--anchor co.rl.service.getres2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.service.getres"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>和Spring不同的是，如果你直接调用<code class="code">ResourceLoadingService</code>取得资源，当资源文件不存在时，你会得到一个<code class="code">ResourceNotFoundException</code>。而Spring无论如何都会取得<code class="code">Resource</code>对象，但随后你需要调用<code class="code">Resource.exists()</code>方法来判断资源存在于否。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.service.getres2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">ResourceLoadingService.getResource()</code>方法还支持一个选项：<code class="code">FOR_CREATE</code>。如果提供了这个选项，那么对于某些类型的资源（如文件系统的资源），即使文件或目录不存在，仍然会返回结果。这样，你就可以创建这个文件或目录
                                        —— 这就是<code class="code">FOR_CREATE</code>参数的意思。</p></td></tr></table></div></div></div></dd><dt><span class="term">取得特定类型的资源</span></dt><dd><div class="example"><a id="d0e4444"><!--anchor d0e4444--></a><p class="title"><strong>例 5.30. 通过<code class="code">ResourceLoadingService</code>接口取得特定类型的资源</strong></p><div class="example-contents"><pre class="programlisting"><em class="hl-comment" style="color: green">// 取得资源文件</em>
File file = resourceLoadingService.getResourceAsFile(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>);

<em class="hl-comment" style="color: green">// 取得资源URL</em>
URL url = resourceLoadingService.getResourceAsURL(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>);

<em class="hl-comment" style="color: green">// 取得资源输入流</em>
InputStream stream = resourceLoadingService.getResourceAsStream(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>);</pre></div></div></dd><dt><span class="term">判断资源存在于否</span></dt><dd><div class="example"><a id="d0e4456"><!--anchor d0e4456--></a><p class="title"><strong>例 5.31. 通过<code class="code">ResourceLoadingService</code>接口判断资源存在于否</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">if</strong> (resourceLoadingService.exists(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>)) {
    ...
}</pre></div></div></dd><dt><span class="term">列举子资源</span></dt><dd><div class="example"><a id="d0e4468"><!--anchor d0e4468--></a><p class="title"><strong>例 5.32. 通过<code class="code">ResourceLoadingService</code>接口列举子资源</strong></p><div class="example-contents"><pre class="programlisting">String[] resourceNames = resourceLoadingService.list(<strong class="hl-string"><em style="color:navy">"/myapp/conf"</em></strong>);
Resource[] resources = resourceLoadingService.listResources(<strong class="hl-string"><em style="color:navy">"/myapp/conf"</em></strong>);</pre></div></div><p>相当于列出当前目录下的所有子目录和文件。</p><p>不是所有的<code class="code">ResourceLoader</code>都支持这个操作 ——
                                <code class="code">FileResourceLoader</code>和<code class="code">WebappResourceLoader</code>支持列举子资源，<code class="code">ClasspathResourceLoader</code>则不支持。
                        </p></dd><dt><span class="term">跟踪取得资源的过程</span></dt><dd><div class="example"><a id="d0e4496"><!--anchor d0e4496--></a><p class="title"><strong>例 5.33. 通过<code class="code">ResourceLoadingService</code>接口跟踪取得资源的过程</strong></p><div class="example-contents"><pre class="programlisting">ResourceTrace trace = resourceLoadingService.trace(<strong class="hl-string"><em style="color:navy">"/myapp/conf/webx.xml"</em></strong>);

<strong class="hl-keyword" style="color: maroon">for</strong> (ResourceTraceElement element : trace) {
    System.out.println(element);
}</pre></div></div><p>这是用来方便调试的功能。有点像<code class="code">Throwable.getStackTrace()</code>方法，可以得到每一个方法调用的历史记录
                            ——
                            <code class="code">ResourceLoadingService.trace()</code>方法可以将取得资源的步骤记录下来。上面代码会在console中输出类似下面的内容：</p><pre class="screen">"/myapp/conf/webx.xml" matched [resource-alias pattern="/myapp/conf"], at "resources.xml", beanName="resourceLoadingService"
"/webroot/WEB-INF/webx.xml" matched [resource pattern="/webroot"], at "resources.xml", beanName="resourceLoadingService"
</pre></dd><dt><span class="term">列出所有可用的资源定义和别名的pattern</span></dt><dd><div class="example"><a id="d0e4518"><!--anchor d0e4518--></a><p class="title"><strong>例 5.34. 通过<code class="code">ResourceLoadingService</code>接口列出所有可用的资源定义和别名的pattern</strong></p><div class="example-contents"><pre class="programlisting">String[] patterns = resourceLoadingService.getPatterns(true);</pre></div></div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.using.service.nonweb"><!--anchor webx.resource.using.service.nonweb--></a>5.3.10. 在非Web环境中使用Resource Loading服务</h3></div></div></div><div class="figure"><a id="d0e4529"><!--anchor d0e4529--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/rl-non-web.png" alt="在非Web环境中使用的ResourceLoadingXmlApplicationContext"/></div></div><p class="title"><strong>图 5.4. 在非Web环境中使用的<code class="code">ResourceLoadingXmlApplicationContext</code></strong></p></div><p>在非Web环境中使用Resource
                    Loading服务的最好方法，是创建<code class="code">ResourceLoadingXmlApplicationContext</code>作为Spring容器。</p><div class="example"><a id="d0e4542"><!--anchor d0e4542--></a><p class="title"><strong>例 5.35. 创建<code class="code">ResourceLoadingXmlApplicationContext</code>容器</strong></p><div class="example-contents"><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> ResourceLoadingXmlApplicationContext(
                                                          <strong class="hl-keyword" style="color: maroon">new</strong> FileSystemResource(<strong class="hl-string"><em style="color:navy">"beans.xml"</em></strong>));</pre></div></div><p>只要<code class="filename">beans.xml</code>中包含<code class="code">&lt;resource-loading&gt;</code>的配置，就会自动启用Resource
                    Loading服务，并取代Spring原来的<code class="code">ResourceLoader</code>机制。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx.resource.loaders"><!--anchor webx.resource.loaders--></a>5.4. ResourceLoader参考</h2></div></div></div><p>Resource Loading服务的核心是<code class="code">ResourceLoader</code>。和Spring
            <code class="code">ResourceLoader</code>不同，Resource
                Loading服务的<code class="code">ResourceLoader</code>是可扩展的轻量级对象，担负着装载某一种类型的资源的具体任务。例如<code class="code">FileResourceLoader</code>负责装载文件系统的资源；<code class="code">WebappResourceLoader</code>负责装载WEB应用中的资源等等。</p><p>当你需要新的资源装载方式时，你所要做的，就是实现一种新的<code class="code">ResourceLoader</code>。例如，你想从数据库中装载资源，那么就可以实现一个<code class="code">DatabaseResourceLoader</code>。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.file"><!--anchor webx.resource.loader.file--></a>5.4.1. <code class="code">FileResourceLoader</code></h3></div></div></div><p><code class="code">FileResourceLoader</code>的功能是：从文件系统中装载资源。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">基本用法</span></dt><dd><div class="example"><a id="d0e4602"><!--anchor d0e4602--></a><p class="title"><strong>例 5.36. <code class="code">FileResourceLoader</code>的基本用法</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></div></div><p>这样，<code class="code">file-loader</code>会从哪里装载资源呢？</p><p>答案是：<span class="emphasis"><em>从当前配置文件所在的目录中装载</em></span>。假如上述资源配置所在的配置文件是<code class="code">c:/myapp/conf/resources.xml</code>，那么<code class="code">file-loader</code>就会从<code class="code">c:/myapp/conf/myFile.xml</code>文件中装载<code class="code">/my/virtual/myFile.xml</code>资源。</p><p>这样做的思路源自于Apache的一个项目：Ant。Ant是一个广为使用的build工具。每一个Ant项目，都有一个<code class="filename">build.xml</code>脚本，在里面定义了很多target，诸如编译项目、打包等。通常我们都会把<code class="filename">build.xml</code>这个文件放在项目的根目录中，然后<code class="filename">build.xml</code>中的命令全是使用相对于<code class="filename">build.xml</code>所在的项目根目录计算出来的相对路径。例如：</p><div class="example"><a id="d0e4645"><!--anchor d0e4645--></a><p class="title"><strong>例 5.37. Ant脚本（<code class="filename">build.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;target</strong> <span class="hl-attribute" style="color: #F5844C">...&gt;</span>
        <span class="hl-attribute" style="color: #F5844C">&lt;copy</span> <span class="hl-attribute" style="color: #F5844C">todir</span>=<span class="hl-value" style="color: #993300">"bin"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;fileset</strong> <span class="hl-attribute" style="color: #F5844C">dir</span>=<span class="hl-value" style="color: #993300">"src"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/copy&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/target&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre></div></div><p>在上面的Ant脚本中，<code class="code">bin</code>、<code class="code">src</code>目录全是相对于<code class="filename">build.xml</code>所在目录的相对目录。这样做的好处是，当你把项目移到不同的环境中，你也无需改变配置文件和脚本。</p><p><code class="code">FileResourceLoader</code>采用了和Ant完全类似的想法。</p></dd><dt><span class="term">指定<code class="code">basedir</code></span></dt><dd><div class="example"><a id="d0e4674"><!--anchor d0e4674--></a><p class="title"><strong>例 5.38. 在<code class="code">FileResourceLoader</code>中指定<code class="code">basedir</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${my.basedir}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></div></div><p><code class="code">FileResourceLoader</code>当然也支持指定<code class="code">basedir</code>根目录。这样，它就会从指定的<code class="code">basedir</code>的子目录中查找资源。</p><p>一般来说，我们需要利用Spring Property
                                Placeholder来设置<code class="code">basedir</code>。在上面的例子中，我们可以在系统启动时，指定JVM参数：<code class="code">-Dmy.basedir=c:/mydata</code>。在不同的系统环境中，必须指定正确的<code class="code">basedir</code>，否则，<code class="code">&lt;file-loader&gt;</code>有可能找不到资源。
                        </p></dd><dt><span class="term">搜索多个路径</span></dt><dd><div class="example"><a id="d0e4712"><!--anchor d0e4712--></a><p class="title"><strong>例 5.39. 在<code class="code">FileResourceLoader</code>中指定多个搜索路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:path&gt;</strong>relativePathToBasedir<strong class="hl-tag" style="color: #000096">&lt;/res-loaders:path&gt;</strong> <a id="co.rl.loader.file.relpath"><!--anchor co.rl.loader.file.relpath--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:path</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"absolute"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>c:/absolutePath<strong class="hl-tag" style="color: #000096">&lt;/res-loaders:path&gt;</strong> <a id="co.rl.loader.file.abspath"><!--anchor co.rl.loader.file.abspath--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/res-loaders:file-loader&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.loader.file.relpath"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>搜索路径默认为相对路径，相对于指定的<code class="code">basedir</code>。如果<code class="code">basedir</code>未指定，则相对于当前<code class="code">resource-loading</code>所在的配置文件的路径。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.loader.file.abspath"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>搜索路径也可以是绝对路径。</p></td></tr></table></div></div></div><p><code class="code">FileResourceLoader</code>支持搜索多个路径，类似于操作系统在<code class="code">PATH</code>环境变量所指定的路径中，搜索可执行文件；也类似于Java在<code class="code">CLASSPATH</code>参数所指定的路径中，搜索classes。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.webapp"><!--anchor webx.resource.loader.webapp--></a>5.4.2. <code class="code">WebappResourceLoader</code></h3></div></div></div><p><code class="code">WebappResourceLoader</code>的功能是：从当前WEB应用中装载资源，也就是从<code class="code">ServletContext</code>对象中装载资源。</p><div class="example"><a id="d0e4761"><!--anchor d0e4761--></a><p class="title"><strong>例 5.40. 配置<code class="code">WebappResourceLoader</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.classpath"><!--anchor webx.resource.loader.classpath--></a>5.4.3. <code class="code">ClasspathResourceLoader</code></h3></div></div></div><p><code class="code">ClasspathResourceLoader</code>的功能是：从classpath中装载资源，也就是从当前的<code class="code">ClassLoader</code>对象中装载资源。</p><div class="example"><a id="d0e4779"><!--anchor d0e4779--></a><p class="title"><strong>例 5.41. 配置<code class="code">ClasspathResourceLoader</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.super"><!--anchor webx.resource.loader.super--></a>5.4.4. <code class="code">SuperResourceLoader</code></h3></div></div></div><p><code class="code">SuperResourceLoader</code>的功能是：调用Resource
                    Loading服务来取得资源。它有点像Java里面的<code class="code">super</code>操作符。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">取得新名字所代表的资源</span></dt><dd><div class="example"><a id="d0e4802"><!--anchor d0e4802--></a><p class="title"><strong>例 5.42. 用<code class="code">SuperResourceLoader</code>取得新名字所代表的资源</strong></p><div class="example-contents"><pre class="programlisting">&lt;resource pattern="/my/virtual"&gt;
    &lt;res-loaders:super-loader basedir="/webroot/WEB-INF" /&gt;
&lt;/resource&gt;
</pre></div></div><p>这个操作类似于<code class="code">&lt;resource-alias&gt;</code>。</p><p>如果在当前context的Resource Loading服务中找不到资源，它会前往parent context中查找。 </p></dd><dt><span class="term">在parent context中查找资源</span></dt><dd><div class="example"><a id="d0e4821"><!--anchor d0e4821--></a><p class="title"><strong>例 5.43. 用<code class="code">SuperResourceLoader</code>查找parent context中的资源</strong></p><div class="example-contents"><pre class="programlisting">&lt;resource pattern="/my/virtual"&gt;
    &lt;res-loaders:super-loader /&gt;
&lt;/resource&gt;
</pre></div></div><p>如果你不指定<code class="code">name</code>参数，那么<code class="code">SuperResourceLoader</code>会直接去parent
                            context中查找资源，而不会在当前context的Resource Loading服务中找。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.other"><!--anchor webx.resource.loader.other--></a>5.4.5. 关于<code class="code">ResourceLoader</code>的其它考虑</h3></div></div></div><p>以上所有的<code class="code">ResourceLoader</code>都被设计成可以在任何环境中工作，即使当前环境不适用，也不会报错。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">WebappResourceLoader</code>可以兼容非WEB环境</span></dt><dd><p>在非WEB环境中，例如单元测试环境、你直接通过<code class="code">XmlApplicationContext</code>创建的Spring环境，<code class="code">WebappResourceLoader</code>也不会出错
                            —— 只不过它找不到任何资源而已。</p></dd><dt><span class="term"><code class="code">SuperResourceLoader</code>可以工作于非级联的环境</span></dt><dd><p>也就是说，即使parent context不存在，或者parent context中没有配置Resource
                                Loading服务，<code class="code">SuperResourceLoader</code>也是可以工作的。</p></dd></dl></div><p>这样，同一套资源配置文件，可以被用于所有环境。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e4876"><!--anchor d0e4876--></a>5.5. 本章总结</h2></div></div></div><p>Resource Loading服务提供了一套高度可扩展的、强大的资源装载机制。这套机制和Spring
            <code class="code">ResourceLoader</code>无缝连接。使用它并不需要特殊的技能，只要掌握Spring的风格即可。</p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt02.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="pt02.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="filter.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">部分 II. Webx基础设施服务 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 6 章 Filter、Request Contexts和Pipeline</td></tr></table></div></body></html>