<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>第 4 章 Webx Turbine</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="home" href="index.html" title="Webx框架指南"/><link rel="up" href="pt01.html" title="部分 I. Webx框架概览"/><link rel="prev" href="webxframework.html" title="第 3 章 Webx Framework"/><link rel="next" href="pt02.html" title="部分 II. Webx基础设施服务"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 4 章 Webx Turbine</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="webxframework.html">上一页</a> </td><th width="60%" align="center">部分 I. Webx框架概览</th><td width="20%" align="right"> <a accesskey="n" href="pt02.html">下一页</a></td></tr></table><hr/></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.overview.turbine"><!--anchor webx.overview.turbine--></a>第 4 章 Webx Turbine</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="turbine.html#d0e2185">4.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="turbine.html#d0e2197">4.1.1. 页面驱动</a></span></dt><dt><span class="section"><a href="turbine.html#d0e2214">4.1.2. 约定胜于配置</a></span></dt></dl></dd><dt><span class="section"><a href="turbine.html#d0e2256">4.2. 页面布局</a></span></dt><dt><span class="section"><a href="turbine.html#d0e2279">4.3. 处理页面的基本流程</a></span></dt><dt><span class="section"><a href="turbine.html#d0e2479">4.4. 依赖注入</a></span></dt><dd><dl><dt><span class="section"><a href="turbine.html#d0e2482">4.4.1. Spring原生注入手段</a></span></dt><dt><span class="section"><a href="turbine.html#d0e2508">4.4.2. 注入request、response和session对象</a></span></dt><dt><span class="section"><a href="turbine.html#d0e2538">4.4.3. 参数注入</a></span></dt></dl></dd><dt><span class="section"><a href="turbine.html#d0e2646">4.5. 定制Webx Turbine</a></span></dt><dt><span class="section"><a href="turbine.html#d0e2668">4.6. 本章总结</a></span></dt></dl></div><p>Webx是一套基于Java Servlet API的通用Web框架。整个Webx框架分成三个层次，本章将简单介绍其第三个层次：Webx Turbine。Webx
        Turbine建立在Webx Framework的基础上，实现了页面渲染、布局、数据验证、数据提交等一系列工作。</p><p>Webx Turbine之所以叫这个名字，是因为Webx最早的版本，是从Apache
        Turbine项目上发展而来的。到现在，Turbine的代码已经荡然无存，然而Turbine中的一些风格和想法依赖保存在Webx框架中。 </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2185"><!--anchor d0e2185--></a>4.1. 设计理念</h2></div></div></div><p>Webx Turbine所遵循下面的设计理念包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>页面驱动</p></li><li class="listitem"><p>约定胜于配置</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2197"><!--anchor d0e2197--></a>4.1.1. 页面驱动</h3></div></div></div><p>创建一个WEB应用，一般会经历三个阶段：产品设计、用户界面设计、功能实现。分别由产品设计师、用户界面设计师和程序员协作完成。如下图所示。</p><div class="figure"><a id="d0e2202"><!--anchor d0e2202--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o4/co-operations.png" alt="协作图：创建一个WEB应用"/></div></div><p class="title"><strong>图 4.1. 协作图：创建一个WEB应用</strong></p></div><p>通常，界面设计师只完成纯静态页面的设计，需要由程序员来把静态页面转换、分解成模板，才能在最终的WEB应用中被使用。为什么不让界面设计师直接创建模板呢？这样一定可以提高很多效率。然而在一般的WEB框架中，由于模板不能独立于程序元素（如action）而存在，因此在程序员介入以前，界面设计师是没有办法展示模板的效果的。</p><p>Webx
                Turbine推崇页面驱动的理念。它的意思是，在程序员介入以前，让界面设计师可以直接创建模板，并展示模板的效果。页面驱动的反面，是程序驱动，或者是Action驱动 ——
                这是多数WEB框架的模式。</p><p>页面驱动不止提高了开发的效率，也使界面设计师在早期阶段，就可以利用框架所提供的工具，做一些以前做不到的事，例如：页面跳转、简单的表单验证、字符串操作等。这些工具是通过Webx
                Turbine中的一个服务来完成的：pull tools。Pull tools服务预先准备了很多模板中可用的工具，让模板可以“按需”取得这些对象 ——
                这就是pull这个单词的意思。 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2214"><!--anchor d0e2214--></a>4.1.2. 约定胜于配置</h3></div></div></div><p>Webx Turbine的另一个理念，是约定胜于配置。“约定”即规则。规则是预先定义的，工程师只需要按着规则来做事，就不需要额外的“配置”。对比其它一些框架 ——
                往往每增加一个页面，都需要在配置文件中增加若干行内容。</p><p>Webx Turbine的规则主要是指一系列映射规则。 </p><div class="table"><a id="d0e2221"><!--anchor d0e2221--></a><p class="title"><strong>表 4.1. Webx Turbine映射规则</strong></p><div class="table-contents"><table summary="Webx Turbine映射规则" cellpadding="10" style="border: none;"><colgroup><col width="27%" class="c1"/><col width="73%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">映射规则</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">将URL映射成target</td><td style="border-bottom: 0.5pt solid #6666cc; ">target是一个抽象的概念，指明当前请求要完成的任务。Target由pipeline来解释，它可能被解释成模板名，也可能被解释成别的东西。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">将target转换成模板名</td><td style="border-bottom: 0.5pt solid #6666cc; ">模板用来展现页面的内容。Velocity、Freemarker、JSP都可以作为模板的格式，但在Webx建议使用velocity模板。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">将target转换成layout布局</td><td style="border-bottom: 0.5pt solid #6666cc; ">你可以为一组页面选择相同的布局（菜单、导航栏、版权信息等），为另一组页面选择另一种布局。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">将target转换成module</td><td style="">在Webx
                                Turbine中，module是指screen、action、control等，大致相当于其它框架中的action或者controller。</td></tr></tbody></table></div></div><p>工程师只需要根据上述规则，将模板放在指定的目录、按照预定的方式命名module（也就是screen、action、control等），就不再需要额外的配置。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2256"><!--anchor d0e2256--></a>4.2. 页面布局</h2></div></div></div><p>Webx Turbine的页面，由以下几个部分组成：</p><div class="figure"><a id="d0e2261"><!--anchor d0e2261--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o4/page-layout.png" alt="Webx Turbine页面的构成"/></div></div><p class="title"><strong>图 4.2. Webx Turbine页面的构成</strong></p></div><p>其中：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Screen，代表页面的主体。</p></li><li class="listitem"><p>Layout，代表页面的布局。</p></li><li class="listitem"><p>Control，代表嵌在screen和layout中的页面片段。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2279"><!--anchor d0e2279--></a>4.3. 处理页面的基本流程</h2></div></div></div><p>Webx Turbine的处理流程被定义在pipeline中。Webx Framework没有规定Pipeline的内容，但Webx
            Turbine却定义了一系列valves。下面是一个Webx Turbine推荐的pipeline配置：</p><div class="example"><a id="d0e2284"><!--anchor d0e2284--></a><p class="title"><strong>例 4.1. Webx Turbine推荐的pipeline配置 - <code class="filename">pipeline.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 初始化turbine rundata，并在pipelineContext中设置可能会用到的对象(如rundata、utils)，以便valve取得。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;prepareForTurbine /&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 设置日志系统的上下文，支持把当前请求的详情打印在日志中。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;setLoggingContext /&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 分析URL，取得target。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;analyzeURL</strong> <span class="hl-attribute" style="color: #F5844C">homepage</span>=<span class="hl-value" style="color: #993300">"homepage"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 检查csrf token，防止csrf攻击和重复提交。假如request和session中的token不匹配，则出错，或显示expired页面。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                <em class="hl-comment" style="color: green">&lt;!-- 执行带模板的screen，默认有layout。 --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"null, vm, jsp"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performTemplateScreen /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;renderTemplate /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                <em class="hl-comment" style="color: green">&lt;!-- 执行不带模板的screen，默认无layout。 --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"do"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performScreen /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong>
                <em class="hl-comment" style="color: green">&lt;!-- 将控制交还给servlet engine。 --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;exit /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 假如rundata.setRedirectTarget()被设置，则循环，否则退出循环。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;breakUnlessTargetRedirected /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div><p>假设用户以URL：<code class="code">http://localhost:8081/</code>来访问Webx应用。域名和端口不重要，取决于应用服务器的配置，这里假设为<code class="code">localhost:8081</code>。Webx
                Framework的处理流程，从<code class="code">WebxFrameworkFilter</code>接收请求，并且一路顺利到达pipeline。然后Pipeline开始依次执行它的valves。（下面的描述略过一些相对次要的步骤。）</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p class="title"><strong><code class="code">&lt;analyzeURL&gt;</code> - 分析URL</strong></p><p>分析URL的目的是取得target。由于用户访问的URL中并没有提供path信息，通常被理解为：用户想要访问“主页”。<code class="code">AnalyzeURL</code>
                        valve提供了一个可选的参数“<code class="code">homepage</code>”，即是在这种情况下起作用 ——
                        <code class="code">http://localhost:8081/</code>对应的target为“<code class="code">homepage</code>”。</p><p>需要注意的是，<span class="emphasis"><em>target不代表模板名，也不代表类名</em></span>。Target只是一个抽象的概念 ——
                        当前页面需要达成的目标。Target可能被后续的valves<span class="emphasis"><em>解释成</em></span>模板名、类名或者其它东西。 </p></li><li class="step"><p class="title"><strong>进入<code class="code">&lt;choose&gt;</code> - 多重分支</strong></p><p>很明显，“<code class="code">homepage</code>”满足了第一个<code class="code">&lt;when&gt;</code>所附带的条件：<code class="code">&lt;target-extension-condition
                        extension="null, vm,
                        jsp"&gt;</code>，意思是target的后缀不存在（<code class="code">null</code>）或为“<code class="code">jsp</code>”或为“<code class="code">vm</code>”。</p></li><li class="step"><p class="title"><strong><code class="code">&lt;performAction&gt;</code> - 执行action</strong></p><p>和其它框架中的action概念不同，在Webx Turbine中，action是用来处理用户提交的表单的。</p><p>因为本次请求未提供action参数，所以跳过该步骤。 </p></li><li class="step"><p class="title"><strong><code class="code">&lt;performTemplateScreen&gt;</code> - 查找并执行screen。</strong></p><p>这里要用到一个规则：target映射成screen module类名的规则。</p><p>假设target为<code class="code">xxx/yyy/zzz</code>，那么Webx Turbine会依次查找下面的screen模块：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">screen.xxx.yyy.Zzz</code>，</p></li><li class="listitem"><p><code class="code">screen.xxx.yyy.Default</code>，</p></li><li class="listitem"><p><code class="code">screen.xxx.Default</code>，</p></li><li class="listitem"><p><code class="code">screen.Default</code>。 </p></li></ul></div><p>本次请求的target为<code class="code">homepage</code>，因此它会尝试查找<code class="code">screen.Homepage</code>和<code class="code">screen.Default</code>这两个类。</p><p>如果找到screen类，Webx
                    Turbine就会执行它。Screen类的功能，通常是读取数据库，然后把模板所需要的对象放到context中。</p><p>如果找不到，也没关系 ——
                    这就是“页面优先”：像<code class="code">homepage</code>这样的主页，通常没有业务逻辑，因此不需要screen类，只需要有模板就可以了。 </p></li><li class="step"><p class="title"><strong><code class="code">&lt;renderTemplate&gt;</code> - 渲染模板</strong></p><p>这里用到两个规则：target映射成screen template，以及target映射成layout template。</p><p>假设target为<code class="code">xxx/yyy/zzz</code>，那么Webx
                        Turbine会查找下面的screen模板：<code class="code">/templates/screen/xxx/yyy/zzz</code>。Screen模板如果未找到，就会报<code class="code">404
                        Not Found</code>错误。 找到screen模板以后，Webx Turbine还会试着查找下面的layout模板：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">/templates/layout/xxx/yyy/zzz</code></p></li><li class="listitem"><p><code class="code">/templates/layout/xxx/yyy/default</code></p></li><li class="listitem"><p><code class="code">/templates/layout/xxx/default</code></p></li><li class="listitem"><p><code class="code">/templates/layout/default</code></p></li></ul></div><p>Layout模板如果找不到，就直接渲染screen模板；如果存在，则把渲染screen模板后的结果，嵌入到layout模板中。</p><p>Layout模板和screen模板中，都可以调用control。每个页面只有一个screen，却可以有任意多个controls。 </p></li><li class="step"><p class="title"><strong><code class="code">&lt;breakUnlessTargetRedirected&gt;</code> - 内部重定向</strong></p><p>在screen和action中，可以进行“内部重定向”。内部重定向实质上就是由<code class="code">&lt;breakUnlessTargetRedirected&gt;</code>实施的
                    —— 如果没有重定向标记，就退出；否则循环到<code class="code">&lt;loop&gt;</code>标签。</p><p>和外部重定向不同，外部重定向是向浏览器返回一个<code class="code">302</code>或<code class="code">303</code>
                        response，其中包含<code class="code">Location</code>
                    header，浏览器看到这样的response以后，就会发出第二个请求。而内部重定向发生在pipeline内部，浏览器并不了解内部重定向。</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2479"><!--anchor d0e2479--></a>4.4. 依赖注入</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2482"><!--anchor d0e2482--></a>4.4.1. Spring原生注入手段</h3></div></div></div><p>依赖注入是Spring的重要特性，Webx既然建立在Spring基础上，当然支持Spring原有的依赖注入手段，例如，你可以在Screen/control/action
                module类中这样写：</p><div class="example"><a id="d0e2487"><!--anchor d0e2487--></a><p class="title"><strong>例 4.2. 通过<code class="code">@Autowired</code> annotation注入</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> UserManager userManager; <a id="co.spring.autowired"><!--anchor co.spring.autowired--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.spring.autowired"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">UserManager</code>是在spring context中配置的bean。</p></td></tr></table></div></div></div><p>在使用Spring原生注入手段时，需要注意beans的scope。你只能注入相同scope或较大的scope中的bean。例如，screen/action/control的scope为singleton，因此用<code class="code">@Autowired</code>注入时，只能注入singleton的对象，不能注入诸如request、session等较小的scope对象。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2508"><!--anchor d0e2508--></a>4.4.2. 注入request、response和session对象</h3></div></div></div><p>在Webx Framework中，你可以这样做：</p><div class="example"><a id="d0e2513"><!--anchor d0e2513--></a><p class="title"><strong>例 4.3. 注入request、response和session对象</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpSession session;
    ...
}</pre></div></div><p>前面我们刚讲过，你<span class="emphasis"><em>不能把request scope的对象，注入到singleton
                        scope的对象中</em></span>。但在Webx中，你<span class="emphasis"><em>可以将<code class="code">HttpServletRequest</code>、<code class="code">HttpServletResponse</code>和<code class="code">HttpSession</code>对象注入到singleton对象中</em></span>。为什么呢？原来，<code class="code">&lt;request-contexts&gt;</code>对这几个常用对象进行了特殊处理，将它们转化成了singleton对象。
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2538"><!--anchor d0e2538--></a>4.4.3. 参数注入</h3></div></div></div><p>有一些对象，是无法通过Spring的bean来注入的，例如：用户提交的参数、表单等。好在Webx
                    Turbine提供了一种可扩展的机制（<code class="code">DataResolver</code>
                service），通过它，我们可以在screen/control/action的方法中注入任意对象。</p><div class="table"><a id="d0e2546"><!--anchor d0e2546--></a><p class="title"><strong>表 4.2. 参数注入</strong></p><div class="table-contents"><table summary="参数注入" cellpadding="10" style="border: none;"><colgroup><col width="22%" class="c1"/><col width="60%" class="c2"/><col width="18%" class="c3"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">功能</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">代码示例</th><th style="border-bottom: 0.5pt solid #6666cc; " valign="middle">适用于module类型</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">注入一个query参数</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetInt(<em><span class="hl-annotation" style="color: gray">@Param("aaa")</span></em> <strong class="hl-keyword" style="color: maroon">int</strong> i)</pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">将query参数注入bean properties</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doSetData(<em><span class="hl-annotation" style="color: gray">@Params</span></em> MyData data) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="3" valign="middle">注入框架对象</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetNavigator(Navigator nav)</pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetContext(Context context) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> execute(ControlParameters params) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">注入context和control参数</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> execute(<em><span class="hl-annotation" style="color: gray">@ContextValue("myvalue")</span></em> <strong class="hl-keyword" style="color: maroon">int</strong> value) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2" valign="middle">注入表单对象</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetGroup(<em><span class="hl-annotation" style="color: gray">@FormGroup("myGroup1")</span></em> Group group) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">action</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetGroups(<em><span class="hl-annotation" style="color: gray">@FormGroups("myGroup1")</span></em> Group[] groups) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">action</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">将表单值注入bean properties</td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetGroupsBeans(<em><span class="hl-annotation" style="color: gray">@FormGroups("myGroup1")</span></em> MyData[] data) </pre>
                            </td><td style="" valign="middle">action</td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2646"><!--anchor d0e2646--></a>4.5. 定制Webx Turbine</h2></div></div></div><p>通过改进pipeline中的valves，我们很容易改变webx turbine的行为。</p><p>最常见的一种需求，是要对页面进行授权 —— 只有符合条件的用户才能访问相应的页面。在pipeline中，很容易添加这样的逻辑： </p><div class="example"><a id="d0e2653"><!--anchor d0e2653--></a><p class="title"><strong>例 4.4. 改进pipeline，增加页面授权功能 - <code class="filename">pipeline.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;prepareForTurbine /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;setLoggingContext /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;analyzeURL</strong> <span class="hl-attribute" style="color: #F5844C">homepage</span>=<span class="hl-value" style="color: #993300">"homepage"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;valve</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.mycompany.auth.PageAuthorizationValve"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.pipeline.auth"><!--anchor co.pipeline.auth--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.pipeline.auth"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>插入用于验证权限的valve。</p></td></tr></table></div></div></div><p>事实上，你甚至可以重写整个pipeline，以实现另一种风格的WEB框架。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2668"><!--anchor d0e2668--></a>4.6. 本章总结</h2></div></div></div><p>Webx Turbine建立在pipeline的基础上，基于页面驱动和约定胜于配置的理念，定义了一组处理页面的流程。Webx
            Turbine的灵活性在于，你可以轻易定制pipeline，以改变它的任何一个方面。</p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="webxframework.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="pt01.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="pt02.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 3 章 Webx Framework </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 部分 II. Webx基础设施服务</td></tr></table></div></body></html>