<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Webx框架指南</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div xml:lang="zh-CN" class="book"><div class="titlepage"><div><div><h1 class="title"><a id="webx.guide"/>Webx框架指南</h1></div><div><div class="author"><h3 class="author">Michael Zhou</h3><code class="email">&lt;<a class="email" href="mailto:zyh@alibaba-inc.com">zyh@alibaba-inc.com</a>&gt;</code></div></div><div><p class="pubdate">2010-11-13</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#d0e12">引言</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16">1. 阅读向导</a></span></dt><dt><span class="section"><a href="#d0e43">2. Webx是什么？</a></span></dt><dt><span class="section"><a href="#d0e48">3. Webx的历史</a></span></dt><dt><span class="section"><a href="#d0e76">4. 为什么要用Webx而不是其它的开源框架？</a></span></dt><dt><span class="section"><a href="#d0e107">5. Webx的优势</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e110">5.1. 成熟可靠性</a></span></dt><dt><span class="section"><a href="#d0e115">5.2. 开放和扩展性</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e128">6. Webx还缺少什么？</a></span></dt></dl></dd><dt><span class="part"><a href="#webx.overview">部分 I. Webx框架概览</a></span></dt><dd><dl><dt><span class="chapter"><a href="#webx.overview.intro">第 1 章 Webx总体介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e157">1.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e160">1.1.1. 框架的本质</a></span></dt><dt><span class="section"><a href="#d0e210">1.1.2. 基础框架</a></span></dt><dt><span class="section"><a href="#d0e236">1.1.3. 层次化</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e289">1.2. Webx的层次</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e292">1.2.1. 三个大层次</a></span></dt><dt><span class="section"><a href="#d0e318">1.2.2. 剪裁和定制Webx</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e430">1.3. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.overview.springext">第 2 章 SpringExt</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e443">2.1. 用SpringExt装配服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e460">2.1.1. Spring Beans</a></span></dt><dt><span class="section"><a href="#d0e498">2.1.2. Spring Schema</a></span></dt><dt><span class="section"><a href="#d0e574">2.1.3. SpringExt Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e666">2.2. SpringExt原理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e669">2.2.1. XML Schema中的秘密</a></span></dt><dt><span class="section"><a href="#d0e789">2.2.2. 扩展点，Configuration Point</a></span></dt><dt><span class="section"><a href="#d0e820">2.2.3. 捐献，Contribution</a></span></dt><dt><span class="section"><a href="#d0e872">2.2.4. 组件和包</a></span></dt><dt><span class="section"><a href="#d0e934">2.2.5. 取得Schemas</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1169">2.3. SpringExt其它特性</a></span></dt><dt><span class="section"><a href="#d0e1223">2.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.overview.framework">第 3 章 Webx Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1269">3.1. Webx的初始化</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1272">3.1.1. 初始化级联的Spring容器</a></span></dt><dt><span class="section"><a href="#d0e1330">3.1.2. 初始化日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1385">3.2. Webx响应请求</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1412">3.2.1. 增强request、response、session的功能</a></span></dt><dt><span class="section"><a href="#d0e1566">3.2.2. Pipeline流程机制</a></span></dt><dt><span class="section"><a href="#d0e1673">3.2.3. 异常处理机制</a></span></dt><dt><span class="section"><a href="#webx.overview.framework.devmode">3.2.4. 开发模式工具</a></span></dt><dt><span class="section"><a href="#d0e1901">3.2.5. 响应和处理请求的更多细节</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2093">3.3. 定制Webx Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2096">3.3.1. 定制<code class="code">WebxRootController</code></a></span></dt><dt><span class="section"><a href="#d0e2127">3.3.2. 定制<code class="code">WebxController</code></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2172">3.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.overview.turbine">第 4 章 Webx Turbine</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2185">4.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2197">4.1.1. 页面驱动</a></span></dt><dt><span class="section"><a href="#d0e2214">4.1.2. 约定胜于配置</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2256">4.2. 页面布局</a></span></dt><dt><span class="section"><a href="#d0e2279">4.3. 处理页面的基本流程</a></span></dt><dt><span class="section"><a href="#d0e2479">4.4. 依赖注入</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2482">4.4.1. Spring原生注入手段</a></span></dt><dt><span class="section"><a href="#d0e2508">4.4.2. 注入request、response和session对象</a></span></dt><dt><span class="section"><a href="#d0e2538">4.4.3. 参数注入</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2646">4.5. 定制Webx Turbine</a></span></dt><dt><span class="section"><a href="#d0e2668">4.6. 本章总结</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#webx.basic.services">部分 II. Webx基础设施服务</a></span></dt><dd><dl><dt><span class="chapter"><a href="#webx.resource">第 5 章 Resource Loading服务指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2690">5.1. 资源概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2693">5.1.1. 什么是资源？</a></span></dt><dt><span class="section"><a href="#d0e2738">5.1.2. 如何表示资源？</a></span></dt><dt><span class="section"><a href="#d0e2867">5.1.3. 如何访问资源？</a></span></dt><dt><span class="section"><a href="#d0e2932">5.1.4. 如何遍历资源？</a></span></dt><dt><span class="section"><a href="#d0e2970">5.1.5. 有什么问题？</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3004">5.2. Spring的<code class="code">ResourceLoader</code>机制</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3015">5.2.1. <code class="code">Resource</code>接口</a></span></dt><dt><span class="section"><a href="#d0e3064">5.2.2. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</a></span></dt><dt><span class="section"><a href="#d0e3091">5.2.3. 在代码中取得资源</a></span></dt><dt><span class="section"><a href="#d0e3210">5.2.4. Spring如何装载资源？</a></span></dt><dt><span class="section"><a href="#d0e3390">5.2.5. Spring <code class="code">ResourceLoader</code>的缺点</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3457">5.3. Resource Loading服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3460">5.3.1. 替换Spring <code class="code">ResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.define.newres">5.3.2. 定义新资源</a></span></dt><dt><span class="section"><a href="#webx.resource.rename.res">5.3.3. 重命名资源</a></span></dt><dt><span class="section"><a href="#webx.resource.redirect.res">5.3.4. 重定向资源</a></span></dt><dt><span class="section"><a href="#webx.resource.matching">5.3.5. 匹配资源</a></span></dt><dt><span class="section"><a href="#webx.resource.multi.loaders">5.3.6. 在多个<code class="code">ResourceLoader</code>中查找</a></span></dt><dt><span class="section"><a href="#webx.resource.load.parent">5.3.7. 装载parent容器中的资源</a></span></dt><dt><span class="section"><a href="#webx.resource.modify.res">5.3.8. 修改资源文件的内容</a></span></dt><dt><span class="section"><a href="#webx.resource.using.service">5.3.9. 直接使用<code class="code">ResourceLoadingService</code></a></span></dt><dt><span class="section"><a href="#webx.resource.using.service.nonweb">5.3.10. 在非Web环境中使用Resource Loading服务</a></span></dt></dl></dd><dt><span class="section"><a href="#webx.resource.loaders">5.4. ResourceLoader参考</a></span></dt><dd><dl><dt><span class="section"><a href="#webx.resource.loader.file">5.4.1. <code class="code">FileResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.webapp">5.4.2. <code class="code">WebappResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.classpath">5.4.3. <code class="code">ClasspathResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.super">5.4.4. <code class="code">SuperResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.other">5.4.5. 关于<code class="code">ResourceLoader</code>的其它考虑</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4876">5.5. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.filter.requestcontexts.pipeline">第 6 章 Filter、Request Contexts和Pipeline</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4894">6.1. Filter</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4897">6.1.1. Filter的用途</a></span></dt><dt><span class="section"><a href="#d0e4957">6.1.2. Filter工作原理</a></span></dt><dt><span class="section"><a href="#d0e5017">6.1.3. Filter的限制</a></span></dt><dt><span class="section"><a href="#d0e5045">6.1.4. Webx对filter功能的补充</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5103">6.2. Request Contexts服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5106">6.2.1. Request Contexts工作原理</a></span></dt><dt><span class="section"><a href="#d0e5148">6.2.2. Request Contexts的用途</a></span></dt><dt><span class="section"><a href="#d0e5217">6.2.3. Request Contexts的使用</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5451">6.3. Pipeline服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5454">6.3.1. Pipeline工作原理</a></span></dt><dt><span class="section"><a href="#d0e5477">6.3.2. Pipeline的用途</a></span></dt><dt><span class="section"><a href="#d0e5490">6.3.3. Pipeline的使用</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6044">6.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.requestcontexts">第 7 章 Request Contexts功能指南</a></span></dt><dd><dl><dt><span class="section"><a href="#webx3.requestcontexts.basic">7.1. <code class="code">&lt;basic&gt;</code> - 提供基础特性</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6148">7.1.1. 拦截器接口</a></span></dt><dt><span class="section"><a href="#d0e6263">7.1.2. 默认拦截器</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.setlocale">7.2. <code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6310">7.2.1. Locale基础</a></span></dt><dt><span class="section"><a href="#d0e6385">7.2.2. Charset编码基础</a></span></dt><dt><span class="section"><a href="#d0e6456">7.2.3. Locale和charset的关系</a></span></dt><dt><span class="section"><a href="#d0e6620">7.2.4. 设置locale和charset</a></span></dt><dt><span class="section"><a href="#d0e6788">7.2.5. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.parser">7.3. <code class="code">&lt;parser&gt;</code> - 解析参数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7126">7.3.1. 基本使用方法</a></span></dt><dt><span class="section"><a href="#d0e7262">7.3.2. 上传文件</a></span></dt><dt><span class="section"><a href="#d0e7441">7.3.3. 高级选项</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.buffered">7.4. <code class="code">&lt;buffered&gt;</code> - 缓存response中的内容</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7851">7.4.1. 实现原理</a></span></dt><dt><span class="section"><a href="#d0e7918">7.4.2. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.lazycommit">7.5. <code class="code">&lt;lazy-commit&gt;</code> - 延迟提交response</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8029">7.5.1. 什么是提交</a></span></dt><dt><span class="section"><a href="#d0e8073">7.5.2. 实现原理</a></span></dt><dt><span class="section"><a href="#d0e8092">7.5.3. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.rewrite">7.6. <code class="code">&lt;rewrite&gt;</code> -重写请求的URL和参数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8198">7.6.1. 概述</a></span></dt><dt><span class="section"><a href="#d0e8268">7.6.2. 取得路径</a></span></dt><dt><span class="section"><a href="#d0e8308">7.6.3. 匹配rules</a></span></dt><dt><span class="section"><a href="#d0e8375">7.6.4. 匹配conditions</a></span></dt><dt><span class="section"><a href="#d0e8723">7.6.5. 替换路径</a></span></dt><dt><span class="section"><a href="#d0e8827">7.6.6. 替换参数</a></span></dt><dt><span class="section"><a href="#d0e8904">7.6.7. 后续操作 </a></span></dt><dt><span class="section"><a href="#d0e8971">7.6.8. 重定向</a></span></dt><dt><span class="section"><a href="#d0e9047">7.6.9. 自定义处理器</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9067">7.7. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.requestcontext.session">第 8 章 Request Context之Session指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9084">8.1. Session概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9087">8.1.1. 什么是Session</a></span></dt><dt><span class="section"><a href="#d0e9106">8.1.2. Session数据存在哪？</a></span></dt><dt><span class="section"><a href="#d0e9174">8.1.3. 创建通用的session框架</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9198">8.2. Session框架</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9201">8.2.1. 最简配置</a></span></dt><dt><span class="section"><a href="#d0e9237">8.2.2. Session ID</a></span></dt><dt><span class="section"><a href="#d0e9520">8.2.3. Session的生命期</a></span></dt><dt><span class="section"><a href="#d0e9681">8.2.4. Session Store</a></span></dt><dt><span class="section"><a href="#d0e9822">8.2.5. Session Model</a></span></dt><dt><span class="section"><a href="#d0e9878">8.2.6. Session Interceptor</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9984">8.3. Cookie Store</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10006">8.3.1. 多值Cookie Store</a></span></dt><dt><span class="section"><a href="#d0e10438">8.3.2. 单值Cookie Store</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10791">8.4. 其它Session Store</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10794">8.4.1. Simple Memory Store</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10815">8.5. 本章总结</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#webx.services">部分 III. Webx应用支持服务</a></span></dt><dd><dl><dt><span class="chapter"><a href="#webx.form">第 9 章 表单验证服务指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10831">9.1. 表单概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10834">9.1.1. 什么是表单验证</a></span></dt><dt><span class="section"><a href="#d0e10883">9.1.2. 表单验证的形式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11104">9.2. 设计</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11107">9.2.1. 验证逻辑与表现逻辑分离</a></span></dt><dt><span class="section"><a href="#d0e11121">9.2.2. 验证逻辑和应用代码分离</a></span></dt><dt><span class="section"><a href="#d0e11138">9.2.3. 表单验证的流程</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11211">9.3. 使用表单验证服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11244">9.3.1. 创建新数据</a></span></dt><dt><span class="section"><a href="#d0e11643">9.3.2. 修改老数据</a></span></dt><dt><span class="section"><a href="#d0e11782">9.3.3. 批量创建或修改数据</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11945">9.4. 表单验证服务详解</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11948">9.4.1. 配置详解</a></span></dt><dt><span class="section"><a href="#d0e12891">9.4.2. Validators</a></span></dt><dt><span class="section"><a href="#d0e14091">9.4.3. Form Tool</a></span></dt><dt><span class="section"><a href="#d0e14313">9.4.4. Field keys的格式</a></span></dt><dt><span class="section"><a href="#d0e14502">9.4.5. 外部验证</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14560">9.5. 本章总结</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#webx.practicing">部分 IV. Webx应用实作</a></span></dt><dd><dl><dt><span class="chapter"><a href="#webx.tutorial.simple">第 10 章 创建第一个Webx应用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14576">10.1. 准备工作</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14581">10.1.1. 安装JDK</a></span></dt><dt><span class="section"><a href="#d0e14588">10.1.2. 安装和配置maven</a></span></dt><dt><span class="section"><a href="#d0e14602">10.1.3. 安装集成开发环境</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14629">10.2. 创建应用</a></span></dt><dt><span class="section"><a href="#d0e14717">10.3. 运行应用</a></span></dt><dt><span class="section"><a href="#d0e14765">10.4. 提问和解答</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14768">10.4.1. 在生产环境的应用上，也会出现前述的“开发者首页”吗？</a></span></dt><dt><span class="section"><a href="#d0e14814">10.4.2. “开发模式”是什么意思？</a></span></dt><dt><span class="section"><a href="#d0e14821">10.4.3. 所生成的应用中包含了什么？</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#webx.logging">第 11 章 Webx日志系统的配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14851">11.1. 名词解释</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14854">11.1.1. 日志系统（Logging System）</a></span></dt><dt><span class="section"><a href="#d0e14918">11.1.2. 日志框架（Logging Framework）</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14968">11.2. 在Maven中组装日志系统</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15052">11.2.1. 在Maven中配置logback作为日志系统</a></span></dt><dt><span class="section"><a href="#d0e15139">11.2.2. 在Maven中配置log4j作为日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15173">11.3. 在WEB应用中配置日志系统</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15176">11.3.1. 设置WEB应用</a></span></dt><dt><span class="section"><a href="#d0e15419">11.3.2. 定制<code class="filename">/WEB-INF/logback.xml</code>（或<code class="filename">/WEB-INF/log4j.xml</code>）</a></span></dt><dt><span class="section"><a href="#d0e15674">11.3.3. 同时初始化多个日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15736">11.4. 常见错误及解决</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15739">11.4.1. 查错技巧</a></span></dt><dt><span class="section"><a href="#d0e15806">11.4.2. 异常信息：No log system exists</a></span></dt><dt><span class="section"><a href="#d0e15832">11.4.3. 异常信息：<code class="code">NoSuchMethodError</code>:
                    <code class="code">org.slf4j.MDC.getCopyOfContextMap()</code></a></span></dt><dt><span class="section"><a href="#d0e15858">11.4.4. <code class="code">STDERR</code>输出：Class path contains multiple SLF4J bindings</a></span></dt><dt><span class="section"><a href="#d0e15885">11.4.5. 看不到日志输出</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15985">11.5. 本章总结</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#webx.tools">部分 V. 辅助工具</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tool.plugin.springext">第 12 章 安装和使用SpringExt插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16013">12.1. SpringExt插件有什么用？</a></span></dt><dt><span class="section"><a href="#tool.plugin.springext.maven">12.2. Maven插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16100">12.2.1. 在<code class="code">pom.xml</code>中定义插件</a></span></dt><dt><span class="section"><a href="#d0e16130">12.2.2. 启动schema服务器</a></span></dt><dt><span class="section"><a href="#d0e16157">12.2.3. 导出所有的schemas</a></span></dt><dt><span class="section"><a href="#d0e16170">12.2.4. Maven插件的可选参数</a></span></dt></dl></dd><dt><span class="section"><a href="#tool.plugin.springext.eclipse">12.3. Eclipse插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16378">12.3.1. 安装插件</a></span></dt><dt><span class="section"><a href="#d0e16435">12.3.2. 利用插件编辑Webx/SpringExt配置文件</a></span></dt><dt><span class="section"><a href="#d0e16756">12.3.3. 利用插件编辑SpringExt组件</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e16789">12.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tool.autoconfig">第 13 章 AutoConfig工具使用指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16798">13.1. 需求分析</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16845">13.1.1. 解决方案</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17089">13.2. AutoConfig的设计</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17094">13.2.1. 角色与职责</a></span></dt><dt><span class="section"><a href="#d0e17190">13.2.2. 分享二进制目标文件</a></span></dt><dt><span class="section"><a href="#d0e17218">13.2.3. 部署二进制目标文件</a></span></dt><dt><span class="section"><a href="#d0e17234">13.2.4. AutoConfig特性列表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17303">13.3. AutoConfig的使用 —— 开发者指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17306">13.3.1. 建立AutoConfig目录结构</a></span></dt><dt><span class="section"><a href="#d0e17446">13.3.2. 建立auto-config.xml描述文件</a></span></dt><dt><span class="section"><a href="#d0e17757">13.3.3. 建立模板文件</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17901">13.4. AutoConfig的使用 —— 部署者指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17913">13.4.1. 在命令行中使用AutoConfig</a></span></dt><dt><span class="section"><a href="#d0e18021">13.4.2. 在maven中使用AutoConfig</a></span></dt><dt><span class="section"><a href="#d0e18061">13.4.3. 运行并观察AutoConfig的结果</a></span></dt><dt><span class="section"><a href="#d0e18132">13.4.4. 共享properties文件</a></span></dt><dt><span class="section"><a href="#d0e18370">13.4.5. AutoConfig常用命令</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18622">13.5. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tool.autoexpand">第 14 章 AutoExpand工具使用指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18641">14.1. AutoExpand工具简介</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18646">14.1.1. Java、JavaEE打包的格式</a></span></dt><dt><span class="section"><a href="#d0e18704">14.1.2. 应用部署的方式</a></span></dt><dt><span class="section"><a href="#d0e18741">14.1.3. AutoExpand的用武之地</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18791">14.2. AutoExpand的使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18794">14.2.1. 取得AutoExpand</a></span></dt><dt><span class="section"><a href="#d0e18801">14.2.2. 执行AutoExpand</a></span></dt><dt><span class="section"><a href="#d0e18870">14.2.3. AutoExpand和AutoConfig的合作</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18884">14.3. AutoExpand的参数</a></span></dt><dt><span class="section"><a href="#d0e19001">14.4. 本章总结</a></span></dt></dl></dd></dl></dd></dl></div><div xml:lang="zh-CN" class="preface"><div class="titlepage"><div><div><h1 class="title"><a id="d0e12"><!--anchor d0e12--></a>引言</h1></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e16">1. 阅读向导</a></span></dt><dt><span class="section"><a href="#d0e43">2. Webx是什么？</a></span></dt><dt><span class="section"><a href="#d0e48">3. Webx的历史</a></span></dt><dt><span class="section"><a href="#d0e76">4. 为什么要用Webx而不是其它的开源框架？</a></span></dt><dt><span class="section"><a href="#d0e107">5. Webx的优势</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e110">5.1. 成熟可靠性</a></span></dt><dt><span class="section"><a href="#d0e115">5.2. 开放和扩展性</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e128">6. Webx还缺少什么？</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e16"><!--anchor d0e16--></a>1. 阅读向导</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>如果你希望马上尝试用webx来搭建应用，请转至<a class="xref" href="#webx.practicing" title="部分 IV. Webx应用实作">第 IV 部分 “Webx应用实作”</a>。</p></li><li class="listitem"><p>如果你想了解webx的整体设计思想，请转至<a class="xref" href="#webx.overview" title="部分 I. Webx框架概览">第 I 部分 “Webx框架概览”</a>。</p></li><li class="listitem"><p>如果你想进一步了解webx的每个具体服务，请转至<a class="xref" href="#webx.basic.services" title="部分 II. Webx基础设施服务">第 II 部分 “Webx基础设施服务”</a>以及<a class="xref" href="#webx.services" title="部分 III. Webx应用支持服务">第 III 部分 “Webx应用支持服务”</a>。</p></li><li class="listitem"><p>如果你想了解一些常用的开发工具，请转至<a class="xref" href="#webx.tools" title="部分 V. 辅助工具">第 V 部分 “辅助工具”</a>。</p></li></ul></div></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e43"><!--anchor d0e43--></a>2. Webx是什么？</h2></div></div></div><p>Webx是一套基于Java Servlet API的通用Web框架。它在Alibaba集团内部被广泛使用。从2010年底，向社会开放源码。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e48"><!--anchor d0e48--></a>3. Webx的历史</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>2001年，阿里巴巴内部开始使用Java Servlet作为WEB服务器端的技术，以取代原先的Apache HTTPD
                    server和mod_perl的组合。</p></li><li class="listitem"><p>2002年，选择Jakarta Turbine作为WEB框架，并开始在此之上进行扩展。</p></li><li class="listitem"><p>2003年，经过大约一年的扩展，框架开始成熟。我们私下称这个经过改进的Turbine框架为Webx 1.0。</p></li><li class="listitem"><p>2004年，借着淘宝网的第一次改版，我们正式推出了Webx 2.0。由于Turbine开源项目发展过于缓慢，我们不得不放弃它。Webx
                    2.0是从零开始完全重写的，仅管它仍然延续了Turbine的使用风格。</p></li><li class="listitem"><p>2004年11月，Webx 2.0和Spring框架整合。</p></li><li class="listitem"><p>从那以后，Webx 2.0一直在进化，但没有作根本性的改动。</p></li><li class="listitem"><p>2010年，Webx 3.0发布。Webx 3.0抛弃了Webx
                    2.0中过时的、从Turbine中发展而来的Service框架，直接采用Spring作为其基础，并对Spring作了重大改进。Webx 3.0完全兼容Webx
                    2.0的代码，只需要修改配置文件就可完成升级。</p></li><li class="listitem"><p>2010年底，Webx 3.0开源。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e76"><!--anchor d0e76--></a>4. 为什么要用Webx而不是其它的开源框架？</h2></div></div></div><p>现在有很多Java的Web框架可供选择，并且它们也都是免费的。例如，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Struts - <a class="link" href="http://struts.apache.org/" target="_top">http://struts.apache.org/</a></p></li><li class="listitem"><p>Webwork - <a class="link" href="http://www.opensymphony.com/webwork/" target="_top">http://www.opensymphony.com/webwork/</a></p></li><li class="listitem"><p>Tapestry - <a class="link" href="http://tapestry.apache.org/" target="_top">http://tapestry.apache.org/</a></p></li><li class="listitem"><p>Spring MVC - <a class="link" href="http://www.springsource.org/" target="_top">http://www.springsource.org/</a></p></li><li class="listitem"><p>⋯⋯</p></li></ul></div><p>以上框架都是非常优秀的。说实话，如果阿里巴巴网站在2001年开始，就有这么多可选择的话，无论选择哪一个都不会有问题。因为这些年来，所有的开源Web框架都在互相学习、并趋于相似。Webx也不例外，它吸收了其它框架的很多想法。因此，当你使用Webx的时候，你会觉得在很多方面，它和其它开源的框架非常类似。</p><p>我并不是说所有的框架都一样好，而是说只要假以时日，所有的框架在发展过程中，必然会积聚好的方面，淘汰坏的方面，从而变得足够好。从这个角度看，的确没有特别明显的理由来选择Webx，但也没有明显的理由不选择Webx。</p><p>另一方面，由于每一种框架采用不同的设计，必然会有各自的优势。Webx也是如此 —— 它在某些方面有一些独到的设计，超越了同类框架。Webx有哪些优势呢？</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e107"><!--anchor d0e107--></a>5. Webx的优势</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e110"><!--anchor d0e110--></a>5.1. 成熟可靠性</h3></div></div></div><p>这个优势主要是针对阿里巴巴及属下网站而言。因为Webx在阿里巴巴和淘宝用了很多年。对于这种超大访问量的电子商务网站，Webx经受了考验，被证明是成熟可靠的。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e115"><!--anchor d0e115--></a>5.2. 开放和扩展性</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>对Spring的直接支持 —— Spring是当今主流的轻量级框架。Webx 3.0和Spring
                        MVC一样，完全建立在Spring框架之上，故可运用Spring的所有特性。</p></li><li class="listitem"><p>扩展性 —— Webx 3.0对Spring做了扩展，使Spring
                        Bean不再是“bean”，而是升级成“组件”。一个组件可以扩展另一个组件，也可以被其它组件扩展。这种机制造就了Webx的非常好的扩展性，且比未经扩展的Spring更易使用。</p></li><li class="listitem"><p>开放性 ——
                        Webx被设计成多个层次，层次间的分界线很清晰。每个层次都足够开放和易于扩展。你可以使用全部的Webx，也可以仅仅使用到Webx的任何一个层次。</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e128"><!--anchor d0e128--></a>6. Webx还缺少什么？</h2></div></div></div><p>和目前快速发展的开源框架相比，Webx似乎不够时髦，因为它还缺少对很多流行功能的直接支持 —— 并非不支持，而是没有方便的方法来直接完成。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>目前Webx只支持服务端的表单验证，而没有直接支持客户端的JS验证。</p></li><li class="listitem"><p>目前Webx没有直接支持AJAX编程。</p></li><li class="listitem"><p>目前Webx没有直接支持REST编程。</p></li><li class="listitem"><p>目前Webx没有直接支持Web Flow。</p></li></ul></div><p>凡是缺少的功能，我们将在未来的版本中陆续加上。</p></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="webx.overview"><!--anchor webx.overview--></a>部分 I. Webx框架概览</h1></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="#webx.overview.intro">第 1 章 Webx总体介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e157">1.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e160">1.1.1. 框架的本质</a></span></dt><dt><span class="section"><a href="#d0e210">1.1.2. 基础框架</a></span></dt><dt><span class="section"><a href="#d0e236">1.1.3. 层次化</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e289">1.2. Webx的层次</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e292">1.2.1. 三个大层次</a></span></dt><dt><span class="section"><a href="#d0e318">1.2.2. 剪裁和定制Webx</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e430">1.3. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.overview.springext">第 2 章 SpringExt</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e443">2.1. 用SpringExt装配服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e460">2.1.1. Spring Beans</a></span></dt><dt><span class="section"><a href="#d0e498">2.1.2. Spring Schema</a></span></dt><dt><span class="section"><a href="#d0e574">2.1.3. SpringExt Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e666">2.2. SpringExt原理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e669">2.2.1. XML Schema中的秘密</a></span></dt><dt><span class="section"><a href="#d0e789">2.2.2. 扩展点，Configuration Point</a></span></dt><dt><span class="section"><a href="#d0e820">2.2.3. 捐献，Contribution</a></span></dt><dt><span class="section"><a href="#d0e872">2.2.4. 组件和包</a></span></dt><dt><span class="section"><a href="#d0e934">2.2.5. 取得Schemas</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1169">2.3. SpringExt其它特性</a></span></dt><dt><span class="section"><a href="#d0e1223">2.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.overview.framework">第 3 章 Webx Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1269">3.1. Webx的初始化</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1272">3.1.1. 初始化级联的Spring容器</a></span></dt><dt><span class="section"><a href="#d0e1330">3.1.2. 初始化日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1385">3.2. Webx响应请求</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1412">3.2.1. 增强request、response、session的功能</a></span></dt><dt><span class="section"><a href="#d0e1566">3.2.2. Pipeline流程机制</a></span></dt><dt><span class="section"><a href="#d0e1673">3.2.3. 异常处理机制</a></span></dt><dt><span class="section"><a href="#webx.overview.framework.devmode">3.2.4. 开发模式工具</a></span></dt><dt><span class="section"><a href="#d0e1901">3.2.5. 响应和处理请求的更多细节</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2093">3.3. 定制Webx Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2096">3.3.1. 定制<code class="code">WebxRootController</code></a></span></dt><dt><span class="section"><a href="#d0e2127">3.3.2. 定制<code class="code">WebxController</code></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2172">3.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.overview.turbine">第 4 章 Webx Turbine</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2185">4.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2197">4.1.1. 页面驱动</a></span></dt><dt><span class="section"><a href="#d0e2214">4.1.2. 约定胜于配置</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2256">4.2. 页面布局</a></span></dt><dt><span class="section"><a href="#d0e2279">4.3. 处理页面的基本流程</a></span></dt><dt><span class="section"><a href="#d0e2479">4.4. 依赖注入</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2482">4.4.1. Spring原生注入手段</a></span></dt><dt><span class="section"><a href="#d0e2508">4.4.2. 注入request、response和session对象</a></span></dt><dt><span class="section"><a href="#d0e2538">4.4.3. 参数注入</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2646">4.5. 定制Webx Turbine</a></span></dt><dt><span class="section"><a href="#d0e2668">4.6. 本章总结</a></span></dt></dl></dd></dl></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.overview.intro"><!--anchor webx.overview.intro--></a>第 1 章 Webx总体介绍</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e157">1.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e160">1.1.1. 框架的本质</a></span></dt><dt><span class="section"><a href="#d0e210">1.1.2. 基础框架</a></span></dt><dt><span class="section"><a href="#d0e236">1.1.3. 层次化</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e289">1.2. Webx的层次</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e292">1.2.1. 三个大层次</a></span></dt><dt><span class="section"><a href="#d0e318">1.2.2. 剪裁和定制Webx</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e430">1.3. 本章总结</a></span></dt></dl></div><p>本章概要地介绍了Webx框架的整体结构和设计。如果你想了解更多，请参考其它详细文档。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e157"><!--anchor d0e157--></a>1.1. 设计理念</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e160"><!--anchor d0e160--></a>1.1.1. 框架的本质</h3></div></div></div><div class="figure"><a id="framework-structure"><!--anchor framework-structure--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o1/framework.png" alt="框架结构的建筑"/></div></div><p class="title"><strong>图 1.1. 框架结构的建筑</strong></p></div><p>应用框架（Application Framework），让人联想到建筑的框架（Frame Structure）。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>建筑框架确定了整个建筑的结构；应用框架确定了应用的结构。</p></li><li class="listitem"><p>建筑框架允许你在不改变结构的基础上，自由改变其内容。例如，你可以用墙体随意分隔房间。应用框架允许你在不改变整体结构的基础上，自由扩展功能。</p></li></ul></div><p>可以这样说，框架的本质就是“扩展”。维基百科这样定义描写“软件框架”，它说一个软件框架必须符合如下要素：</p><div class="informaltable"><table cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><tbody><tr><td style="">Inversion of Control 反转控制</td><td style="">应用的流程不是由应用控制的，而是由框架控制的。</td></tr><tr><td style="">Default Behavior 默认行为</td><td style="">框架会定义一系列默认的行为。</td></tr><tr><td style="">Extensibility 扩展性</td><td style="">应用可以扩展框架的功能，也可以修改框架的默认行为。</td></tr><tr><td style="">Non-modifiable Framework Code 框架本身不可更改</td><td style="">框架在被扩展时，自身的代码无须被改变。</td></tr></tbody></table></div><p>在一个框架中，实现丰富的功能固然重要，然而更重要的是：<span class="emphasis"><em>建立良好的扩展机制</em></span>。我们知道，Webx目前虽然欠缺一些流行的功能。然而Webx却有一个良好的扩展机制，来支持开发者增加新的功能。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e210"><!--anchor d0e210--></a>1.1.2. 基础框架</h3></div></div></div><p>纵观开源的Web框架，做得比较好的框架，都有一个共性 —— 它们并不是简单地实现Web应用所需要的功能（诸如Action、模板、表单验证等），而是把框架建立在另一个基础框架之上。这个基础框架的作用是：组装模块；提供扩展机制。建立在这种基础上的Web框架有很好的适应性和扩展性，可以应对Web应用不断变化和发展的需求。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>早期的Turbine，建立在Service框架之上。</p></li><li class="listitem"><p>Webwork，建立在Xwork框架之上。</p></li><li class="listitem"><p>Tapestry，建立在HiveMind或Tapestry IOC框架之上。</p></li><li class="listitem"><p>早期的Struts 1.x由于没有一个轻量框架作为基础，因此很难扩展。而Struts
                            2.x使用了Webwork和Xwork，因此适用能力大为提高。</p></li><li class="listitem"><p>Spring MVC，建立在Spring框架之上。</p></li></ul></div><p><span class="emphasis"><em>一个Web框架的好坏，往往不是由它所实现的具体功能的好坏决定的，而是由其所用的基础框架的好坏决定的。</em></span></p><p>Webx建立在SpringExt的基础上 ——
                SpringExt是对Spring的扩展。Spring是当今主流的轻量级框架。SpringExt没有损失任何Spring的功能，但它能够提供比Spring自身更强大的扩展能力。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e236"><!--anchor d0e236--></a>1.1.3. 层次化</h3></div></div></div><p><span class="emphasis"><em>设计良好的模块，应该是层次化的。</em></span></p><p>例如，模块B扩展了模块A，同时被模块C扩展。这样就形成了A、B、C三个层次。</p><div class="figure"><a id="tiers"><!--anchor tiers--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o1/tiers.png" alt="模块的层次"/></div></div><p class="title"><strong>图 1.2. 模块的层次</strong></p></div><p>如图所示，层次之间有如下的关系：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>上层定义规则，下层定义细节；（上层、下层也可称为内层、外层）</p></li><li class="listitem"><p>上层是抽象的，下层是具体的；</p></li><li class="listitem"><p>越上层，越稳定（越少改变）；越下层，越易变。</p></li><li class="listitem"><p>依赖倒转（Dependency Inversion）。下层（具体）依赖上层（抽象），而不是上层依赖下层。</p></li><li class="listitem"><p>下层扩展上层时，不需要修改到上层的任何代码和配置。即符合开闭原则（Open-Closed Principle简称OCP – Open for
                            extension, Closed for modification）。</p></li><li class="listitem"><p>每一层均可被替换。 </p></li></ul></div><p>层次化的设计，使软件中的每一个部分都可被增强或替换。</p><p><span class="emphasis"><em>层次化不是自然而然的，而是需要精心的设计。</em></span>设计一个层次化的组件，可以从下面几方面来考虑：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>切分功能。每个组件专心做一件事。</p></li><li class="listitem"><p>分析哪些会改变，哪些不会改变。不变部分固化在组件中，可能会改变的部分抽象成接口，以便扩展。</p></li><li class="listitem"><p>考虑默认值和默认扩展。默认值和默认扩展应该是最安全、最常用的选择。对于默认值和默认扩展，用户在使用时不需要额外的配置。</p></li></ul></div><p>Webx鼓励层次化的模块设计，而SpringExt提供了创建和配置层次化组件的机制。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e289"><!--anchor d0e289--></a>1.2. Webx的层次</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e292"><!--anchor d0e292--></a>1.2.1. 三个大层次</h3></div></div></div><p>很多用过Webx框架的人说起Webx，就想到：Webx如何处理页面、如何验证表单、如何渲染模板等等功能。事实上，这些只不过是Webx最外层、最易变、非本质的功能。</p><p>Webx框架不仅鼓励层次化设计，它本身也是层次化的。<span class="emphasis"><em>你既可以使用全部的Webx框架，也可以只使用部分的Webx框架。</em></span>大体上，Webx框架可以划分成三个大层次，如图所示。</p><div class="figure"><a id="webx-tiers"><!--anchor webx-tiers--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o1/webx-tiers.png" alt="Webx的层次"/></div></div><p class="title"><strong>图 1.3. Webx的层次</strong></p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>SpringExt：基于Spring，提供扩展组件的能力。它是整个框架的基础。</p></li><li class="listitem"><p>Webx Framework：基于Servlet
                        API，提供基础的服务，例如：初始化Spring、初始化日志、接收请求、错误处理、开发模式等。Webx
                        Framework只和servlet及spring相关 ——
                        它不关心Web框架中常见的一些服务，例如Action处理、表单处理、模板渲染等。因此，事实上，你可以用Webx
                        Framework来创建多种风格的Web框架。</p></li><li class="listitem"><p>Webx Turbine：基于Webx Framework，实现具体的网页功能，例如：Action处理、表单处理、模板渲染等。</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e318"><!--anchor d0e318--></a>1.2.2. 剪裁和定制Webx</h3></div></div></div><p>并非所有的开发者都需要使用Webx的全部。下面列举几种情形。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e323"><!--anchor d0e323--></a>1.2.2.1. 级别一：仅使用SpringExt，适用于非Web应用、单元测试</h4></div></div></div><p>对于非Web应用和单元测试，但却想拥有Spring和SpringExt的功能，可以直接创建SpringExt容器：</p><div class="example"><a id="d0e328"><!--anchor d0e328--></a><p class="title"><strong>例 1.1. 直接创建SpringExt容器</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">import</strong> java.io.File;
<strong class="hl-keyword" style="color: maroon">import</strong> org.springframework.core.io.FileSystemResource;
<strong class="hl-keyword" style="color: maroon">import</strong> com.alibaba.citrus.springext.support.context.XmlApplicationContext; <a id="co.xac"><!--anchor co.xac--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

...

XmlApplicationContext parentContext = <strong class="hl-keyword" style="color: maroon">new</strong> XmlApplicationContext(
        <strong class="hl-keyword" style="color: maroon">new</strong> FileSystemResource(<strong class="hl-keyword" style="color: maroon">new</strong> File(srcdir, <strong class="hl-string"><em style="color:navy">"parent.xml"</em></strong>)));  <a id="co.xac.normal"><!--anchor co.xac.normal--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>

XmlApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> XmlApplicationContext(
        <strong class="hl-keyword" style="color: maroon">new</strong> FileSystemResource(<strong class="hl-keyword" style="color: maroon">new</strong> File(srcdir, <strong class="hl-string"><em style="color:navy">"app.xml"</em></strong>)), parentContext); <a id="co.xac.w.parent"><!--anchor co.xac.w.parent--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>

Object mybean = context.getBean(<strong class="hl-string"><em style="color:navy">"mybean"</em></strong>);</pre></div></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.xac"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请注意代码所使用的<code class="code">ApplicationContext</code>实现类为SpringExt扩展的类型（<code class="code">c.a.c.springext.s.c.XmlApplicationContext</code>）。通过这个实现类，你除了可以使用原来Spring的所有功能以外，还可以使用SpringExt的所有功能，包括：Schema、Configuration
                            Points和Contributions、ResourceLoadingService等。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.xac.normal"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这行代码从一个配置文件中创建容器。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.xac.w.parent"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这行代码创建了一个子容器。多个子容器和父容器之间可组成一个树状级联的容器结构。在子容器中可以访问到所有父容器中的beans和服务，但反过来是不成立的。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e355"><!--anchor d0e355--></a>1.2.2.2. 级别二：仅使用SpringExt及Web组件，在此基础上运行Spring MVC、Struts等非webx框架</h4></div></div></div><p>非webx框架也可以使用SpringExt的全部功能。</p><div class="example"><a id="d0e360"><!--anchor d0e360--></a><p class="title"><strong>例 1.2. 修改<code class="filename">/WEB-INF/web.xml</code>，让非webx框架支持SpringExt</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 初始化日志系统，装载/WEB-INF/log4j.xml或/WEB-INF/logback.xml --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong>com.alibaba.citrus.logconfig.LogConfiguratorListener<strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 初始化Spring容器，装载/WEB-INF/webx.xml, /WEB-INF/webx-*.xml --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong>com.alibaba.citrus.webx.context.WebxContextLoaderListener<strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong> <a id="co.context-loader"><!--anchor co.context-loader--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 下面配置：Spring MVC、Struts的filter、servlet、mapping... --&gt;</em>
    ……

<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.context-loader"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这里使用了webx的<code class="code">WebxContextLoaderListener</code>来初始化spring容器，而不是用spring原生的<code class="code">ContextLoaderListener</code>。不用担心，前者完全兼容后者。事实上前者是从后者派生而来的。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e380"><!--anchor d0e380--></a>1.2.2.3. 级别三：仅使用Webx Framework，创造新的Web框架</h4></div></div></div><p>也许你想做一个新的Web框架 —— 因为你并不想使用Webx Turbine中提供的页面处理的方案，但你仍然可以使用Webx
                    Framework所提供的服务，例如：错误处理、开发模式等。</p><div class="example"><a id="d0e385"><!--anchor d0e385--></a><p class="title"><strong>例 1.3. 修改<code class="filename">/WEB-INF/webx.xml</code>，以创建新的WEB框架</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;webx-configuration</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;components</strong> <span class="hl-attribute" style="color: #F5844C">defaultControllerClass</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyController"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.controller"><!--anchor co.controller--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;rootController</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyRootController"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.root-controller"><!--anchor co.root-controller--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/components&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.controller"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">MyController</code>扩展了<code class="code">AbstractWebxController</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.root-controller"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">MyRootController</code>扩展了<code class="code">AbstractWebxRootController</code>。</p></td></tr></table></div></div></div><p>这个方案非常适合作为一个新Web框架的起点 ——
                    免去了创建Servlet/Filter、初始化Spring容器、处理request/response等繁杂事务，并且完全支持SpringExt的所有功能，此外还包含了错误处理、开发模式等Webx
                    Framework中的一切便利。</p><p>另一种以Webx
                        Framework为基础的创建新框架的方法，是从pipeline入手。<span class="emphasis"><em>通过pipeline，理论上可以实现任何框架的功能</em></span>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e421"><!--anchor d0e421--></a>1.2.2.4. 级别四：使用整个Webx框架，定制Turbine</h4></div></div></div><p>假如你想使用几乎大部分Webx的功能，但希望对少数步骤进行改进，你可以修改pipeline。</p><p>Webx Turbine本身定义了一套pipeline的实现，但是你完全可以去修改它：插入一些步骤、删除一些步骤、修改一些步骤 ——
                    所有都取决于你。</p><p>最常见的一个需求，是在Webx Turbine中添加权限验证 —— 只需要插入一个步骤就可以做到了。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e430"><!--anchor d0e430--></a>1.3. 本章总结</h2></div></div></div><p>Webx框架是一个稳定、强大的Web框架。倒不是说它实现了所有的功能，而是它建立在SpringExt的基础上，具有超强的扩展能力。你可以使用全部的Webx，也可以使用部分Webx。你也可以比较容易地用SpringExt做出自己的可扩展组件。</p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.overview.springext"><!--anchor webx.overview.springext--></a>第 2 章 SpringExt</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e443">2.1. 用SpringExt装配服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e460">2.1.1. Spring Beans</a></span></dt><dt><span class="section"><a href="#d0e498">2.1.2. Spring Schema</a></span></dt><dt><span class="section"><a href="#d0e574">2.1.3. SpringExt Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e666">2.2. SpringExt原理</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e669">2.2.1. XML Schema中的秘密</a></span></dt><dt><span class="section"><a href="#d0e789">2.2.2. 扩展点，Configuration Point</a></span></dt><dt><span class="section"><a href="#d0e820">2.2.3. 捐献，Contribution</a></span></dt><dt><span class="section"><a href="#d0e872">2.2.4. 组件和包</a></span></dt><dt><span class="section"><a href="#d0e934">2.2.5. 取得Schemas</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1169">2.3. SpringExt其它特性</a></span></dt><dt><span class="section"><a href="#d0e1223">2.4. 本章总结</a></span></dt></dl></div><p>Webx是一套基于Java Servlet
        API的通用Web框架。Webx致力于提供一套极具扩展性的机制，来满足Web应用不断变化和发展的需求。而SpringExt正是这种扩展性的基石。SpringExt扩展了Spring，在Spring的基础上提供了一种扩展功能的新方法。</p><p>本章将告诉你SpringExt是什么？它能做什么？本章不会涉及太深的细节，如果你想了解更多，请参考其它文档。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e443"><!--anchor d0e443--></a>2.1. 用SpringExt装配服务</h2></div></div></div><p>在Webx中有一个非常有用的ResourceLoadingService。现在我们以这个服务为例，来说明SpringExt的用途。</p><p>ResourceLoadingService是一个可以从各种输入源中（例如从File
            System、Classpath、Webapp中）查找和读取资源文件的服务。有点像Linux的文件系统 ——
            你可以在一个统一的树形目录结构中，定位（mount）任意文件系统，而应用程序不需要关心它所访问的资源文件属于哪个具体的文件系统。</p><p>ResourceLoadingService的结构如图所示。这是一个既简单又典型的面向对象的设计。 </p><div class="figure"><a id="d0e452"><!--anchor d0e452--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/resource-loading-design.png" alt="Resource Loading服务的设计"/></div></div><p class="title"><strong>图 2.1. Resource Loading服务的设计</strong></p></div><p>下面我们尝试在Spring容器中装配ResourceLoadingService服务。为了更好地说明问题，下文所述的Spring配置是被简化的，未必和ResourceLoadingService的真实代码相吻合。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e460"><!--anchor d0e460--></a>2.1.1. Spring Beans</h3></div></div></div><p>在Spring 2.0以前，你只能装配beans，就像下面这样：</p><div class="example"><a id="example.resource-loading.spring.beans"><!--anchor example.resource-loading.spring.beans--></a><p class="title"><strong>例 2.1. 用Spring Beans装配Resource Loading服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"resourceLoadingService"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba...ResourceLoadingServiceImpl"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"mappings"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;map&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;entry</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"/file"</span> <span class="hl-attribute" style="color: #F5844C">value-ref</span>=<span class="hl-value" style="color: #993300">"fileLoader"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;entry</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">value-ref</span>=<span class="hl-value" style="color: #993300">"webappLoader"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/map&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/property&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"fileLoader"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba...FileResourceLoader"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"basedir"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${user.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"webappLoader"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">" com.alibaba...WebappResourceLoader"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>以上是一个典型的Spring beans的配置方案。这种方案简单易行，很好地体现了Spring的基础理念：IoC（Inversion of
                Control，依赖反转）。ResourceLoadingServiceImpl并不依赖FileResourceLoader和WebappResourceLoader，它只依赖它们的接口ResourceLoader。至于如何创建FileResourceLoader、WebappResourceLoader、需要提供哪些参数，这种琐事全由spring包办。</p><p>然而，其实spring本身并不了解如何创建ResourceLoader的对象、需要用哪些参数、如何装配和注入等知识。这些知识全靠应用程序的装配者（assembler）通过上述spring的配置文件来告诉spring的。也就是说，尽管ResourceLoaderServiceImpl类的作者不需要关心这些琐事，但还是有人得关心。</p><p>为了说明问题，我先定义两个角色：“服务提供者”和“服务使用者”（即“装配者”）。在上面的例子中，ResourceLoadingService的作者就是服务的提供者，使用ResourceLoadingService的人，当然就是服务使用者。服务使用者利用spring把ResourceLoadingService和ResourceLoader等其它服务装配在一起，使它们可以协同工作。当然这两个角色有时会是同一个人，但多数情况下会是两个人。因此有必要把这两个角色的职责区分清楚，才能合作。</p><div class="figure"><a id="d0e476"><!--anchor d0e476--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/roles.png" alt="服务提供者和使用者的关系"/></div></div><p class="title"><strong>图 2.2. 服务提供者和使用者的关系</strong></p></div><p>如图所示。虚线左边代表“服务提供者”的职责，虚线右边代表“服务使用者”（即“装配者”）的职责。</p><p>从图中可以看到，Spring的配置文件会依赖于服务实现类的公开API。装配者除非查看源代码（如ResourceLoadingServiceImpl的源码）或者API文档才能精确地获知这些API的细节。这有什么问题呢？</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>没有检验机制，错误必须等到运行时才会被发现。装配者仅从spring配置文件中，无法直观地了解这个配置文件有没有写对？例如：应该从constructor
                            args注入却配成了从properties注入；写错了property的名称；注入了错误的类型等等。</p></li><li class="listitem"><p>无法了解更多约束条件。即使装配者查看API源码，也未必能了解到某些约束条件，例如：哪些properties是必须填写的，哪些是可选的，哪些是互斥的？</p></li><li class="listitem"><p>当服务的实现被改变时，Spring配置文件可能会失败。因为Spring配置文件是直接依赖于服务的实现，而不是接口的。接口相对稳定，而实现是可被改变的。另一方面，这个问题也会阻碍服务提供者改进他们的服务实现。
                        </p></li></ul></div><p>难怪有人诟病Spring说它只不过是用XML来写程序代码而已。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e498"><!--anchor d0e498--></a>2.1.2. Spring Schema</h3></div></div></div><p>这种情况直到Spring 2.0发布以后，开始有所改观。因为Spring 2.0支持用XML Schema来定义配置文件。同样的功能，用Spring
                Schema来定义，可能变成下面的样子：</p><div class="example"><a id="example.resource-loading.spring.schema"><!--anchor example.resource-loading.spring.schema--></a><p class="title"><strong>例 2.2. 用Spring Schema装配Resource Loading服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"resourceLoadingService"</span>
                  <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/file"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${user.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre></div></div><p>怎么样？这个配置文件是不是简单很多呢？和直接使用Spring Beans配置相比，这种方式有如下优点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>很明显，这个配置文件比起前面的Spring
                            Beans风格的配置文件简单易读得多。因为在这个spring配置文件里，它所用的“语言”是“领域相关”的，也就是说，和ResourceLoadingService所提供的服务内容相关，而不是使用像bean、property这样的编程术语。这样自然易读得多。</p></li><li class="listitem"><p>它是可验证的。你不需要等到运行时就能验证其正确性。任何一个支持XML
                            Schema的标准XML编辑器，包括Eclipse自带的XML编辑器，都可以告诉你配置的对错。</p></li><li class="listitem"><p>包含更多约束条件。例如，XML Schema可以告诉你，哪些参数是可选的，哪些是必须填的；参数的类型是什么等等。</p></li><li class="listitem"><p><span class="emphasis"><em>服务的实现细节对装配者隐藏</em></span>。当服务实现改变时，只要XML
                            Schema是不变的，那么Spring的配置就不会受到影响。 </p></li></ul></div><p>以上优点中，最后一点是最重要优点。通过Spring
                Schema来定义配置文件，装配者无须再了解诸如“ResourceLoadingService的实现类是什么”、“需要什么参数”等细节。那么Spring是如何得知这些内容呢？</p><p>奥秘在于所有的schema都会有一个“解释器”和它对应（即BeanDefinitionParser）。这个解释器负责将符合schema定义的XML配置，转换成Spring能解读的beans定义。<span class="emphasis"><em>解释器是由服务的开发者来提供的</em></span>
                —— 在本例中，ResourceLoadingService的开发者会提供这个解释器。 </p><div class="figure"><a id="d0e532"><!--anchor d0e532--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/roles-schema.png" alt="用Schema改善服务角色之间的关系"/></div></div><p class="title"><strong>图 2.3. 用Schema改善服务角色之间的关系</strong></p></div><p>如图所示，虚线右侧的装配者，不再需要了解服务具体实现类的API，它只要遵循标准的XML
                Schema定义来书写spring配置文件，就可以得到正确的配置。这样一来，虚线左侧的服务提供者就有自由可以改变服务的实现类，他相信只要服务的接口和XML
                Schema不改变，服务的使用者就不会受影响。</p><p><span class="emphasis"><em>将和具体实现相关的工作，例如提供类名、property名称和类型等工作，交还给服务的提供者，使服务的使用者（即装配者）可以用它所能理解的语言来装配服务，这是Spring
                    Schema所带来的核心价值。</em></span></p><p>然而，Spring Schema有一个问题 —— 它是不可扩展的。</p><p>仍以ResourceLoadingService为例。仅管在API层面，
                ResourceLoadingService支持任何对ResourceLoader接口的扩展，例如，你可以添加一种新的DatabaseResourceLoader，以便读取数据库中的资源。但在Spring配置文件上，你却无法自由地添加新的元素。比如： </p><div class="example"><a id="example.resource-loading.spring.schema.add.dbloader"><!--anchor example.resource-loading.spring.schema.add.dbloader--></a><p class="title"><strong>例 2.3. 尝试在Spring Schema所装配的Resource Loading服务中，添加新的装载器</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"resourceLoadingService"</span>
                  <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/file"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${user.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/db"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;database-loader</strong> <span class="hl-attribute" style="color: #F5844C">connection</span>=<span class="hl-value" style="color: #993300">"jdbc:mysql:mydb"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.add.dbloader"><!--anchor co.add.dbloader--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.add.dbloader"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>装配者希望在这里添加一种新的装载器：<code class="code">database-loader</code>。然而，如果在设计<code class="code">&lt;resource-loading&gt;</code>的schema时，并没有预先考虑到<code class="code">database-loader</code>这种情况，那么这段配置就会报错。</p></td></tr></table></div></div></div><p>使用Spring Schema时，装配者无法自主地往Spring配置文件中增加新的Resource
                    Loader类型，除非通知服务提供者去修改<code class="code">&lt;resource-loading&gt;</code>的schema ——
                然而这违反了面向对象设计中的基本原则 —— OCP（Open Closed
                Principle）。OCP原则是面向对象设计的强大之源。它使得我们可以轻易地添加新的功能，却不需要改动老的代码；它使设计良好的代码成果可以被叠加和组合，以便实现更复杂的功能。</p><p>从本质意义来讲，Schema是API的另一种表现形式。你可以把Schema看作一种接口，而接口的实质是服务的提供者与使用者之间的合约（contract）。可惜的是，我们只能在传统API层面来贯彻OCP原则，却无法在Schema上同样遵循它。我们无法做到不修改老的schema，就添加新的元素
                —— 这导致Spring Schema的作用被大大削弱。 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e574"><!--anchor d0e574--></a>2.1.3. SpringExt Schema</h3></div></div></div><p>SpringExt改进了Spring，使得Spring Schema可以被扩展。下面的例子对<a class="xref" href="#example.resource-loading.spring.schema" title="例 2.2. 用Spring Schema装配Resource Loading服务">例 2.2 “用Spring Schema装配Resource Loading服务”</a>作了少许修改，使之能被扩展。</p><div class="example"><a id="example.resource-loading.springext.schema"><!--anchor example.resource-loading.springext.schema--></a><p class="title"><strong>例 2.4. 用SpringExt Schema装配Resource Loading服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"resourceLoadingService"</span>
                  <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
                  <span class="hl-attribute" style="color: #F5844C">xmlns:loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.ns.loaders"><!--anchor co.ns.loaders--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/file"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${user.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.ns.loaders.prefix1"><!--anchor co.ns.loaders.prefix1--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:webapp-loader /&gt;</strong> <a id="co.ns.loaders.prefix2"><!--anchor co.ns.loaders.prefix2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.ns.loaders"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>重新定义namespaces ——
                                将<code class="code">ResourceLoader</code>和<code class="code">&lt;resource-loading&gt;</code>所属的namespace分离。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.ns.loaders.prefix1"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.ns.loaders.prefix2"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将<code class="code">file-loader</code>和<code class="code">webapp-loader</code>放在<code class="code">loaders</code>名字空间中，表示它们是Resource
                            Loaders的扩展。</p></td></tr></table></div></div></div><p>上面的配置文件和前例中使用Spring Schema的配置文件差别很小。没错，<span class="emphasis"><em>SpringExt Schema和Spring
                    Schema是完全兼容的</em></span>！唯一的差别是，我们把<code class="code">ResourceLoader</code>和<code class="code">&lt;resource-loading&gt;</code>所属的namespace分开了，然后将<code class="code">ResourceLoader</code>的配置放在专属的namespace
                    “loaders”中。例如：<code class="code">&lt;loaders:file-loader&gt;</code>。这样一来，我们就有办法在不修改<code class="code">&lt;resource-loading&gt;</code>的schema的前提下，添加新的ResourceLoader实现。例如我们要添加一种新的ResourceLoader扩展
                —— <code class="code">DatabaseResourceLoader</code>，只需要做以下两件事： </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>将包含<code class="code">DatabaseResourceLoader</code>所在的jar包添加到项目的依赖中。如果你是用maven来管理项目，那么意味着你需要修改一下项目的<code class="filename">pom.xml</code>。</p></li><li class="listitem"><p>在spring配置文件中添加如下行：</p><div class="example"><a id="example.resource-loading.springext.schema.add.dbloader"><!--anchor example.resource-loading.springext.schema.add.dbloader--></a><p class="title"><strong>例 2.5. 在SpringExt Schema所装配的Resource Loading服务中，添加新的装载器</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"resourceLoadingService"</span>
                  <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
                  <span class="hl-attribute" style="color: #F5844C">xmlns:loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/file"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${user.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/db"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:database-loader</strong> <span class="hl-attribute" style="color: #F5844C">connection</span>=<span class="hl-value" style="color: #993300">"jdbc:mysql:mydb"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.add.dbloader.springext"><!--anchor co.add.dbloader.springext--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.add.dbloader.springext"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>添加一个新的loader，而无须改变<code class="code">&lt;resource-loading&gt;</code>的schema。</p></td></tr></table></div></div></div></li></ol></div><p>完美！你无须通知ResourceLoadingService的作者去修改它的schema，一种全新的ResourceLoader扩展就这样被注入到ResourceLoadingService中。正如同你在程序代码里，无须通知ResourceLoadingService的作者去修改它的实现类，就可以创建一种新的、可被ResourceLoadingService调用的ResourceLoader实现类。这意味着，我们在Spring配置文件的层面上，也满足了OCP原则。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e666"><!--anchor d0e666--></a>2.2. SpringExt原理</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e669"><!--anchor d0e669--></a>2.2.1. XML Schema中的秘密</h3></div></div></div><p>下面这段配置是<a class="xref" href="#example.resource-loading.springext.schema.add.dbloader" title="例 2.5. 在SpringExt Schema所装配的Resource Loading服务中，添加新的装载器">例 2.5 “在SpringExt Schema所装配的Resource Loading服务中，添加新的装载器”</a>的spring配置文件的片段。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/db"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:database-loader</strong> <span class="hl-attribute" style="color: #F5844C">connection</span>=<span class="hl-value" style="color: #993300">"jdbc:mysql:mydb"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> 
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><p>其中，<code class="code">&lt;resource-loading&gt;</code>是由<code class="filename">resource-loading.xsd</code>这个schema来定义的。而在开发<code class="code">resource-loading</code>服务的时候，<code class="code">database-loader</code>这种新的扩展还不存在
                ——
                        也就是说，<span class="emphasis"><em><code class="filename">resource-loading.xsd</code>对于<code class="code">database-loader</code>一无所知</em></span>。可为什么以上配置能通过XML
                    Schema的验证呢？我们只需要查看一下<code class="filename">resource-loading.xsd</code>就可以知道答案了： </p><div class="example"><a id="example.resource-loading.schema.loaders"><!--anchor example.resource-loading.schema.loaders--></a><p class="title"><strong>例 2.6. Schema片段：<code class="code">&lt;resource-loading&gt;</code>中如何定义<code class="code">loaders</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;xsd:element</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"resource"</span> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"ResourceLoadingServiceResourceType"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;xsd:complexType</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"ResourceLoadingServiceResourceType"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;xsd:choice</strong> <span class="hl-attribute" style="color: #F5844C">minOccurs</span>=<span class="hl-value" style="color: #993300">"0"</span> <span class="hl-attribute" style="color: #F5844C">maxOccurs</span>=<span class="hl-value" style="color: #993300">"unbounded"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;xsd:any</strong> <span class="hl-attribute" style="color: #F5844C">namespace</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.resource-loading.loaders"><!--anchor co.resource-loading.loaders--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/xsd:choice&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;xsd:attribute</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"pattern"</span> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"xsd:string"</span> <span class="hl-attribute" style="color: #F5844C">use</span>=<span class="hl-value" style="color: #993300">"required"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/xsd:complexType&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.resource-loading.loaders"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这里运用了XML
                                Schema中的<code class="code">&lt;xsd:any&gt;</code>定义，相当于说：<code class="code">&lt;resource&gt;</code>
                                element下面，可以跟任意多个<code class="code">&lt;loaders:*&gt;</code> elements。</p></td></tr></table></div></div></div><p><code class="code">&lt;xsd:any&gt;</code>定义只关心namespace，不关心element的名称，自然可以接受未知的<code class="code">&lt;database-loader&gt;</code>
                    element，前提是<code class="code">&lt;database-loader&gt;</code>的namespace是“<code class="code">http://www.alibaba.com/schema/services/resource-loading/loaders</code>”。</p><p>在这段配置中，<code class="code">&lt;loaders:database-loader&gt;</code>标签通知SpringExt：将<code class="code">database-loader</code>的实现注入到<code class="code">resource-loading</code>的服务中。这种对应关系是如何建立起来的呢？</p><p>在XML里，<code class="code">loaders</code>前缀代表namespace：“<code class="code">http://www.alibaba.com/schema/services/resource-loading/loaders</code>”；但对SpringExt而言，它还代表一个更重要的意义：<span class="emphasis"><em>扩展点</em></span>，或称为<span class="emphasis"><em>ConfigurationPoint</em></span>。ConfigurationPoint将namespace和可扩展的<code class="code">ResourceLoader</code>接口关联起来。</p><p>在XML里，<code class="code">database-loader</code>代表一个XML
                    element；但对SpringExt而言，它还代表一个更重要的意义：<span class="emphasis"><em>捐献</em></span>，或称为<span class="emphasis"><em>Contribution</em></span>。Contribution将element和对<code class="code">ResourceLoader</code>接口的具体扩展关联起来。</p><div class="figure"><a id="d0e783"><!--anchor d0e783--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/springext-concept.png" alt="SpringExt的概念：扩展点和捐献"/></div></div><p class="title"><strong>图 2.4. SpringExt的概念：扩展点和捐献</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e789"><!--anchor d0e789--></a>2.2.2. 扩展点，Configuration Point</h3></div></div></div><p>SpringExt用“扩展点，Configuration Point”来代表一个可被扩展的接口。每个扩展点都：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>对应一个唯一的名称，例如：<span class="emphasis"><em><code class="code">services/resource-loading/loaders</code></em></span>。</p></li><li class="listitem"><p>对应一个唯一的namespace，例如：<code class="code">http://www.alibaba.com/schema/</code><span class="emphasis"><em><code class="code">services/resource-loading/loaders</code></em></span>。</p></li><li class="listitem"><p>对应一个唯一的schema，例如：<span class="emphasis"><em><code class="code">services-resource-loading-loaders</code></em></span><code class="code">.xsd</code>。
                        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e820"><!--anchor d0e820--></a>2.2.3. 捐献，Contribution</h3></div></div></div><p>SpringExt把每一个对扩展点的具体扩展称作“捐献，Contriubtion”。每个捐献都：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>在对同一扩展点的所有捐献中，拥有一个唯一的名字，例如：<span class="emphasis"><em><code class="code">file-loader</code></em></span>，<span class="emphasis"><em><code class="code">webapp-loader</code></em></span>，<span class="emphasis"><em><code class="code">database-loader</code></em></span>等。</p></li><li class="listitem"><p>对应一个唯一的schema，例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">services/resource-loading/loaders/</code><span class="emphasis"><em><code class="code">file-loader</code></em></span><code class="code">.xsd</code></p></li><li class="listitem"><p><code class="code">services/resource-loading/loaders/</code><span class="emphasis"><em><code class="code">webapp-loader</code></em></span><code class="code">.xsd</code></p></li><li class="listitem"><p><code class="code">services/resource-loading/loaders/</code><span class="emphasis"><em><code class="code">database-loader</code></em></span><code class="code">.xsd</code></p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e872"><!--anchor d0e872--></a>2.2.4. 组件和包</h3></div></div></div><p>在前面的例子中，<code class="code">resource-loading</code>服务调用了<code class="code">loaders</code>扩展点，而<code class="code">file-loader</code>、<code class="code">webapp-loader</code>等则扩展了<code class="code">loaders</code>扩展点。然而事实上，<code class="code">resource-loading</code>服务本身也是对另一个扩展点“<code class="code">services</code>”的扩展。<code class="code">services</code>扩展点是Webx内部定义了一个<span class="emphasis"><em>顶级扩展点</em></span>。</p><p>在SpringExt中，一个模块既可以成为别的模块的扩展，也可以被别的模块来扩展。这样的模块被称为“<span class="emphasis"><em>组件</em></span>”。</p><div class="figure"><a id="d0e909"><!--anchor d0e909--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/springext-component.png" alt="组件"/></div></div><p class="title"><strong>图 2.5. 组件</strong></p></div><p>如图所示，<code class="code">resource-loading</code>组件既扩展了<code class="code">services</code>扩展点，又可被其它组件所扩展。</p><p>当你需要增加一种新的扩展时，你不需要改动原有包（例如<code class="filename">resource-loadings.jar</code>）中的任何内容，你只需要将新的扩展所在的jar包（例如<code class="filename">database-loader.jar</code>）加入到依赖表中即可。假如你使用maven来管理项目，意味着你需要修改项目的<code class="filename">pom.xml</code>描述文件，以便加入新的扩展包。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e934"><!--anchor d0e934--></a>2.2.5. 取得Schemas</h3></div></div></div><p>最后剩下的一个问题是，如何找到Schemas？为了找到schema，我们必须在Spring配置文件中指定Schema的位置。</p><div class="example"><a id="example.schema.locations"><!--anchor example.schema.locations--></a><p class="title"><strong>例 2.7. 在XML中指定Schema Location</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
            </span><span class="emphasis"><em>http://localhost:8080/schema/services.xsd</em></span> <a id="co.schema.location.services"><!--anchor co.schema.location.services--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        http://www.alibaba.com/schema/services/resource-loading/loaders
            <span class="emphasis"><em>http://localhost:8080/schema/services-resource-loading-loaders.xsd</em></span> <a id="co.schema.location.loaders"><!--anchor co.schema.location.loaders--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        http://www.springframework.org/schema/beans
            <span class="emphasis"><em>http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd</em></span> <a id="co.schema.location.beans"><!--anchor co.schema.location.beans--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    "&gt;
    ...
<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.schema.location.services"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.schema.location.loaders"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.schema.location.beans"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定schema的位置。</p></td></tr></table></div></div></div><p>这里看起来有一点奇怪，因为它把schema的位置（<code class="code">xsi:schemaLocation</code>）指向了一台本地服务器：<code class="code">localhost:8080</code>。为什么这样做呢？要回答这个问题，先要搞清楚另一个问题：<span class="emphasis"><em>有哪些部件需要用到schema？</em></span></p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e973"><!--anchor d0e973--></a>2.2.5.1. XML编辑器需要读取schemas</h4></div></div></div><p>XML编辑器通过访问schema，可以实现两大功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>语法提示的功能。</p><div class="figure"><a id="d0e982"><!--anchor d0e982--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/popup-syntax.png" alt="Eclipse XML编辑器弹出的语法提示"/></div></div><p class="title"><strong>图 2.6. Eclipse XML编辑器弹出的语法提示</strong></p></div></li><li class="listitem"><p>验证spring配置文件的正确性。</p><div class="figure"><a id="d0e991"><!--anchor d0e991--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/validate-schema.png" alt="Eclipse XML编辑器验证spring配置文件时，显示的错误信息"/></div></div><p class="title"><strong>图 2.7. Eclipse XML编辑器验证spring配置文件时，显示的错误信息</strong></p></div></li></ul></div><p>
                </p><p>XML编辑器取得schema内容的途径有两条，一条途径是访问<code class="code">schemaLocation</code>所指示的网址。因此，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>假如你声明的<code class="code">schemaLocation</code>为：<span class="emphasis"><em>http://www.alibaba.com/</em></span><code class="code">schema/services.xsd</code>，那么XML编辑器就会尝试访问<code class="code">www.alibaba.com</code>服务器。</p></li><li class="listitem"><p>假如你声明的<code class="code">schemaLocation</code>为：
                                    <span class="emphasis"><em>http://www.springframework.org/</em></span><code class="code">schema/beans/spring-beans.xsd</code>，那么XML编辑器就会尝试访问<code class="code">www.springframework.org</code>服务器。</p></li></ul></div><p>然而，在外部服务器（例如<code class="code">www.alibaba.com</code>和<code class="code">www.springframework.org</code>）上维护一套schema是很困难的，因为： </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>你未必拥有外部服务器的控制权；</p></li><li class="listitem"><p>你很难让外部服务器上的schema和你的组件版本保持一致；</p></li><li class="listitem"><p>当你无法连接外部服务器的时候（例如离线状态），会导致XML编辑器无法帮你验证spring配置文件的正确性，也无法帮你弹出语法提示。</p></li></ul></div><p>
                </p><p>XML编辑器取得schema内容的另一条途径是将所有的schema转换成静态文件，然后定义一个标准的XML
                    Catalog来访问这些schema文件。然而这种方法的难点类似于将schema存放在外部服务器上 ——
                    你很难让这些静态文件和你的组件版本保持一致。</p><p>SpringExt提供了两个解决方案，可以完全解决上述问题 ——
                        使用maven或eclipse插件。你可以使用SpringExt所提供的maven插件，在<code class="code">localhost</code>本机上启动一个监听<code class="code">8080</code>端口的Schema
                    Server，通过它就可以访问到所有的schemas：</p><pre class="screen"><span class="command"><strong>mvn springext:run</strong></span></pre><p>上述命令执行以后，打开浏览器，输入网址<code class="code">http://localhost:8080/schema</code>就可以看到类似下面的内容：</p><div class="figure"><a id="d0e1069"><!--anchor d0e1069--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/schema-exporter.png" alt="用SpringExt maven插件罗列schemas"/></div></div><p class="title"><strong>图 2.8. 用SpringExt maven插件罗列schemas</strong></p></div><p>这就是为什么<a class="xref" href="#example.schema.locations" title="例 2.7. 在XML中指定Schema Location">例 2.7 “在XML中指定Schema Location”</a>中，把<code class="code">schemaLocation</code>指向<code class="code">localhost:8080</code>的原因。只有这样，才能让任何普通的XML编辑器不需要任何特殊的设置，就可以读到正确的schema。</p><p>你也可以使用Eclipse插件 —— 这比maven插件更方便，只要你是用eclipse来开发应用的话。</p><p>关于这两个插件，详情请见：<a class="xref" href="#tool.plugin.springext" title="第 12 章 安装和使用SpringExt插件">第 12 章 <em>安装和使用SpringExt插件</em></a>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1091"><!--anchor d0e1091--></a>2.2.5.2. SpringExt需要读取schemas</h4></div></div></div><p>当SpringExt在初始化容器时，需要读取schema以验证spring配置文件。</p><p>请记住，<span class="emphasis"><em>SpringExt永远不需要通过访问网络来访问schemas</em></span>。事实上，即使你把<a class="xref" href="#example.schema.locations" title="例 2.7. 在XML中指定Schema Location">例 2.7 “在XML中指定Schema Location”</a>中的schema的网址改成指向“外部服务器”的链接，SpringExt也不会真的去访问它们。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>将：<code class="code">http://localhost:8080/schema/</code><span class="emphasis"><em>services.xsd</em></span></p><p>改成：<code class="code">http://www.alibaba.com/schema/</code><span class="emphasis"><em>services.xsd</em></span></p></li><li class="listitem"><p>将：<code class="code">http://localhost:8080/schema/</code><span class="emphasis"><em>services-resource-loading-loaders.xsd</em></span></p><p>改成：<code class="code">http://www.alibaba.com/schema/</code><span class="emphasis"><em>services-resource-loading-loaders.xsd</em></span></p></li><li class="listitem"><p>将：<code class="code">http://localhost:8080/schema/</code><span class="emphasis"><em>www.springframework.org/schema/beans/spring-beans.xsd</em></span></p><p>改成：<code class="code">http://</code><span class="emphasis"><em>www.springframework.org/schema/beans/spring-beans.xsd</em></span>（这个就是spring原来的schema网址了）
                            </p></li></ul></div><p>以上修改在任何时候都不会影响Spring的正常启动。Spring是通过一种SpringExt定制的<code class="code">EntityResolver</code>来访问schemas的。SpringExt其实只关注例子中<span class="emphasis"><em>加亮</em></span>部分的schema网址，而忽略前面部分。</p><p>然而，如前所述，上面两种网址对于普通的XML编辑器来说是有差别的。因此，<span class="emphasis"><em>SpringExt推荐总是以“<code class="code">http://localhost:8080/schema</code>”作为你的<code class="code">schemaLocation</code>网址的前缀</em></span>。下面的图总结了SpringExt是如何取得schemas的。</p><div class="figure"><a id="d0e1163"><!--anchor d0e1163--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o2/get-schemas.png" alt="SpringExt如何取得schemas"/></div></div><p class="title"><strong>图 2.9. SpringExt如何取得schemas</strong></p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e1169"><!--anchor d0e1169--></a>2.3. SpringExt其它特性</h2></div></div></div><p>SpringExt实际上是一个增强了的Spring的<code class="code">ApplicationContext</code>容器。除了提供前面所说的Schema扩展机制以外，SpringExt还提供了一个增强的Resource
            Loading机制。前文例子中所说的Resource
                Loading服务是Webx中的真实功能，而且它能完全取代Spring原有的<code class="code">ResourceLoader</code>功能 ——
                也就是说，<span class="emphasis"><em>应用程序并不需要直接调用ResourceLoading服务，它们可以直接使用Spring本身的ResourceLoader功能，其背后的ResourceLoading机制就会默默地工作</em></span>。</p><p>如果不加额外的配置，SpringExt
                context所用的<code class="code">ResourceLoader</code>实现和Spring自带的完全相同。然而，你只要添加类似下面的配置，Spring的<code class="code">ResourceLoader</code>就会被增强：</p><div class="example"><a id="d0e1191"><!--anchor d0e1191--></a><p class="title"><strong>例 2.8. 配置Webx <code class="code">resource-loading</code>服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:resource-loading</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/classpath"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:resource-loading&gt;</strong></pre></div></div><p>一种典型的Resource
                Loading服务的用途是读取CMS生成的模板。假设模板引擎从装载模板<code class="code">/templates</code>，默认情况下，<code class="code">/templates</code>就在webapp的根目录下。但是有一部分模板<code class="code">/templates/cms</code>是由外部的内容管理系统（CMS）生成的，这些模板文件并不在webapp目录下。对此，我们只需要下面的配置：</p><div class="example"><a id="d0e1210"><!--anchor d0e1210--></a><p class="title"><strong>例 2.9. 配置CMS目录</strong></p><div class="example-contents"><pre class="programlisting">    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/templates/cms"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${cms.dir}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></div></div><p>这样，在模板引擎浑然不知的情况下，我们就把<code class="code">/templates/cms</code>目录指向webapp外部的一个文件系统目录，而保持<code class="code">/templates</code>下其它模板的位置不变。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e1223"><!--anchor d0e1223--></a>2.4. 本章总结</h2></div></div></div><p>至此，我们简单领略了SpringExt所带来的好处和便利。SpringExt完全兼容Spring原来schema的概念和风格，但是却可以让schema像程序代码一样被扩展。Webx完全建立在SpringExt的基础上。这个基础决定了Webx是一个高度可扩展的框架，其配置虽然灵活，却又不失方便和直观。</p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.overview.framework"><!--anchor webx.overview.framework--></a>第 3 章 Webx Framework</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1269">3.1. Webx的初始化</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1272">3.1.1. 初始化级联的Spring容器</a></span></dt><dt><span class="section"><a href="#d0e1330">3.1.2. 初始化日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1385">3.2. Webx响应请求</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1412">3.2.1. 增强request、response、session的功能</a></span></dt><dt><span class="section"><a href="#d0e1566">3.2.2. Pipeline流程机制</a></span></dt><dt><span class="section"><a href="#d0e1673">3.2.3. 异常处理机制</a></span></dt><dt><span class="section"><a href="#webx.overview.framework.devmode">3.2.4. 开发模式工具</a></span></dt><dt><span class="section"><a href="#d0e1901">3.2.5. 响应和处理请求的更多细节</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2093">3.3. 定制Webx Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2096">3.3.1. 定制<code class="code">WebxRootController</code></a></span></dt><dt><span class="section"><a href="#d0e2127">3.3.2. 定制<code class="code">WebxController</code></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2172">3.4. 本章总结</a></span></dt></dl></div><p>Webx是一套基于Java Servlet API的通用Web框架。整个Webx框架分成三个层次，本章将简单介绍其第二个层次：Webx
        Framework。事实上，这是第一个真正涉足WEB技术的层次。前一个层次SpringExt只是提供了一个通用的扩展机制。</p><p>Webx Framework负责完成一系列基础性的任务，如下表所示：</p><div class="table"><a id="d0e1236"><!--anchor d0e1236--></a><p class="title"><strong>表 3.1. Webx Framework的任务</strong></p><div class="table-contents"><table summary="Webx Framework的任务" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">系统初始化</th><th style="border-bottom: 0.5pt solid #6666cc; ">响应请求</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">初始化Spring容器</td><td style="">增强request/response/session的功能</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">初始化日志系统</td><td style="">提供pipeline流程处理机制</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "> </td><td style="">异常处理</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "> </td><td style="">开发模式</td></tr></tbody></table></div></div><p>本章不会涉及太深的细节，如果你想了解更多，请参考其它文档。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e1269"><!--anchor d0e1269--></a>3.1. Webx的初始化</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1272"><!--anchor d0e1272--></a>3.1.1. 初始化级联的Spring容器</h3></div></div></div><p>Webx Framework将负责创建一组级联的Spring容器结构。Webx所创建的Spring容器<span class="emphasis"><em>完全兼容于Spring
                    MVC所创建的容器</em></span>，可被所有使用Spring框架作为基础的WEB框架所使用。</p><div class="example"><a id="d0e1280"><!--anchor d0e1280--></a><p class="title"><strong>例 3.1. 初始化Spring容器 - <code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong><span class="emphasis"><em>com.alibaba.citrus.webx.context.WebxContextLoaderListener</em></span><strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong> <a id="co.init.context"><!--anchor co.init.context--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.init.context"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Webx利用<code class="code">WebxContextLoaderListener</code>来初始化Spring，用来取代Spring的<code class="code">ContextLoaderListener</code>。事实上，前者是从后者派生的。</p></td></tr></table></div></div></div><p>Webx
                Framework将会自动搜索<code class="filename">/WEB-INF</code>目录下的XML配置文件，并创建下面这种级联的spring容器。</p><div class="figure"><a id="d0e1307"><!--anchor d0e1307--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/context-tree.png" alt="级联的Spring容器"/></div></div><p class="title"><strong>图 3.1. 级联的Spring容器</strong></p></div><p>如图所示。Webx Framework将一个WEB应用分解成多个小应用模块：<code class="code">app1</code>、<code class="code">app2</code>，当然名字可以任意取。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>每个小应用模块独享一个Spring Sub Context子容器。两个子容器之间的beans无法互相注入。</p></li><li class="listitem"><p>所有小应用模块共享一个Spring Root
                            Context根容器。根容器中的bean可被注入到子容器的bean中；反之不可以。</p></li></ul></div><p>将一个大的应用分解成若干个小应用模块，并使它们的配置文件相对独立，这是一种很不错的开发实践。然而，如果你的应用确实很简单，你不希望把你的应用分成多个小应用模块，那么，你还是需要配置至少一个小应用模块（子容器）。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1330"><!--anchor d0e1330--></a>3.1.2. 初始化日志系统</h3></div></div></div><p>每个现代的WEB应用，都需要日志系统。流行的日志系统包括Log4j、Logback。</p><p>Webx Framework使用SLF4J作为它的日志框架。因此Webx
                Framework理论上支持所有日志系统。然而目前为止，它只包含了log4j和logback这两种日志系统的初始化模块（如有需要，可以扩充）。初始化日志系统很简单。</p><div class="example"><a id="d0e1337"><!--anchor d0e1337--></a><p class="title"><strong>例 3.2. 初始化日志系统 - <code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong><span class="emphasis"><em>com.alibaba.citrus.logconfig.LogConfiguratorListener</em></span><strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong> <a id="co.init.log"><!--anchor co.init.log--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.init.log"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Webx利用<code class="code">LogConfiguratorListener</code>来初始化日志系统。</p></td></tr></table></div></div></div><p><code class="code">LogConfiguratorListener</code>会根据你当前应用所依赖的日志系统（通常配置在maven project中），来自动选择合适的日志配置文件。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>假设你的应用依赖了logback的jar包，那么listener就会查找<code class="filename">/WEB-INF/logback.xml</code>，并用它来初始化logback；</p></li><li class="listitem"><p>如果你的应用依赖了log4j的jar包，那么listener也会很聪明地查找<code class="filename">/WEB-INF/log4j.xml</code>配置文件。</p></li><li class="listitem"><p>假如以上配置文件不存在，listener会使用默认的配置 —— 把日志打印在控制台上。</p></li><li class="listitem"><p>Listener支持对配置文件中的placeholders进行替换。</p></li><li class="listitem"><p>Listener支持同时初始化多种日志系统。</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关日志系统的使用方法，另有文档详细讲述。</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e1385"><!--anchor d0e1385--></a>3.2. Webx响应请求</h2></div></div></div><div class="figure"><a id="d0e1388"><!--anchor d0e1388--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/request-processing.png" alt="Webx Framework如何响应请求"/></div></div><p class="title"><strong>图 3.2. Webx Framework如何响应请求</strong></p></div><p>当Webx Framework接收到一个来自WEB的请求以后，实际上它主要做了两件事： </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>首先，它会增强request、response、session的功能，并把它们打包成更易使用的<code class="code">RequestContext</code>对象。</p></li><li class="step"><p>其次，它会调用相应子应用的pipeline，用它来做进一步的处理。</p></li><li class="step"><p>假如在上面的过程中出现异常，则会触发Webx Framework处理异常的过程。</p></li></ol></div><p>
        </p><p>此外，Webx Framework还提供了一组辅助开发的功能，例如查看环境变量，查看schema等。这些功能只在开发模式生效，生产模式下自动关闭。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1412"><!--anchor d0e1412--></a>3.2.1. 增强request、response、session的功能</h3></div></div></div><p>Webx Framework提供了一个request contexts服务。Request
                    contexts服务利用<code class="code">HttpServletRequestWrapper</code>和<code class="code">HttpServletResponseWrapper</code>对request和response对象进行包装，以实现新的功能。</p><p>一个基本的request contexts的配置看起来是下面的样子： </p><div class="example"><a id="d0e1425"><!--anchor d0e1425--></a><p class="title"><strong>例 3.3. 配置request contexts服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>Request contexts所有的功能都是可配置、可扩展的 —— 它是基于SpringExt的扩展机制。</p><p>Request contexts所增加的功能对于所有的基于标准Servlet API的应用都是透明的 ——
                这些应用根本不需要知道这些扩展的存在。例如，假如你在request contexts服务中配置了增强的session框架，那么所有通过标准的Servlet
                API取得session的应用，都将获得新功能：</p><div class="example"><a id="d0e1434"><!--anchor d0e1434--></a><p class="title"><strong>例 3.4. 取得增强的session对象</strong></p><div class="example-contents"><pre class="programlisting">HttpSession session = request.getSession();</pre></div></div><p>再比如，只要你配置了upload服务，那么下面的调用将同样适用于<code class="code">multipart/form-data</code>类型的请求（Servlet
                API本身是不支持upload表单的）：</p><div class="example"><a id="d0e1444"><!--anchor d0e1444--></a><p class="title"><strong>例 3.5. 取得upload表单的参数</strong></p><div class="example-contents"><pre class="programlisting">String value = request.getParameter(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关Request Contexts的原理和使用方法的详情，请参阅<a class="xref" href="#webx.filter.requestcontexts.pipeline" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>。</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1454"><!--anchor d0e1454--></a>3.2.1.1. Request contexts中可用的功能</h4></div></div></div><div class="table"><a id="d0e1457"><!--anchor d0e1457--></a><p class="title"><strong>表 3.2. 可用的<code class="code">RequestContext</code>扩展</strong></p><div class="table-contents"><table summary="可用的RequestContext扩展" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c1"/><col width="80%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;basic&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">对输入、输出的数据进行安全检查，排除可能的攻击。例如：XSS过滤、CRLF换行回车过滤等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;buffered&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">对写入response中的数据进行缓存，以便于实现嵌套的页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;lazy-commit&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">延迟提交response，用来支持基于cookie的session。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;parser&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">解析用户提交的参数，无论是普通的请求，还是multipart/form-data这样的用于上传文件的请求。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;set-locale&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">设置当前请求的区域（locale）、编码字符集（charset）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;rewrite&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">改写URL及参数，类似于Apache HTTPD Server中的rewrite模块。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">&lt;session&gt;</code></td><td style="">增强的Session框架，可将session中的对象保存到cookie、数据库或其它存储中。</td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关以上所有Request Contexts的详情，请参阅<a class="xref" href="#webx.requestcontexts" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>和<a class="xref" href="#webx.requestcontext.session" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1522"><!--anchor d0e1522--></a>3.2.1.2. 注入特殊对象</h4></div></div></div><p>在Webx中，你可以这样做，例如：</p><div class="example"><a id="d0e1527"><!--anchor d0e1527--></a><p class="title"><strong>例 3.6. 注入request、response、session</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpSession session;
    ...
}</pre></div></div><p>在这个例子中，<code class="code">LoginAction</code>类可以是一个singleton。一般来说，你<span class="emphasis"><em>不能把request
                            scope的对象，注入到<code class="code">singleton</code>
                            scope的对象中</em></span>。但你<span class="emphasis"><em>可以把<code class="code">HttpServletRequest</code>、<code class="code">HttpServletResponse</code>和<code class="code">HttpSession</code>对象注入到singleton对象中</em></span>。为什么呢？原来，Request
                    contexts服务对这几个常用对象进行了特殊处理，将它们转化成了singleton对象。</p><p>如果没有这个功能，那么我们就不得不将上例中的<code class="code">LoginAction</code>配置成<code class="code">request</code>
                        scope。这增加了系统的复杂性，也成倍地降低了性能。而将<code class="code">LoginAction</code>设置成singleton，只需要在系统启动时初始化一次，以后就可以快速引用它。
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1566"><!--anchor d0e1566--></a>3.2.2. Pipeline流程机制</h3></div></div></div><p>Webx Framework赋予开发者极大的自由，来定制处理请求的流程。这种机制就是pipeline。</p><p>Pipeline的意思是管道，管道中有许多阀门（Valve），阀门可以控制水流的走向。Webx
                Framework中的pipeline可以控制处理请求的流程的走向。如图所示。 </p><div class="figure"><a id="d0e1573"><!--anchor d0e1573--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/pipeline.png" alt="Pipeline工作原理示意"/></div></div><p class="title"><strong>图 3.3. Pipeline工作原理示意</strong></p></div><p>Webx Framework并没有规定管道的内容 —— 定制管道是应用开发者的自由。然而Webx
                Framework提供了一系列通用valves，你可以使用它们：</p><div class="table"><a id="d0e1581"><!--anchor d0e1581--></a><p class="title"><strong>表 3.3. 通用valves</strong></p><div class="table-contents"><table summary="通用valves" cellpadding="10" style="border: none;"><colgroup><col width="16%" class="c1"/><col width="31%" class="c2"/><col width="53%" class="c3"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">分类</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">Valves</th><th style="border-bottom: 0.5pt solid #6666cc; " valign="middle">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2" valign="middle">循环</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;while&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">有条件循环</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;loop&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">无条件循环</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2" valign="middle">选择分支</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;if&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">单分支</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;choose&gt;&lt;when&gt;&lt;otherwise&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">多分支</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="3" valign="middle">中断</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;break&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">无条件中断</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p><code class="code">&lt;break-if&gt;</code></p>
                                <p><code class="code">&lt;break-unless&gt;</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">有条件中断</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;exit&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">无条件退出整个pipeline（结束所有的嵌套层次）</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">异常捕获</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;try-catch-finally&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">类似Java中的try-catch-finally结构</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">嵌套</td><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;sub-pipeline&gt;</code></td><td style="" valign="middle">创建嵌套的子pipeline。 </td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关Pipeline的原理和使用方法的详情，请参阅<a class="xref" href="#webx.filter.requestcontexts.pipeline" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1673"><!--anchor d0e1673--></a>3.2.3. 异常处理机制</h3></div></div></div><p>当应用发生异常时，Webx Framework可以处理这些异常。</p><div class="table"><a id="d0e1678"><!--anchor d0e1678--></a><p class="title"><strong>表 3.4. Webx如何处理异常</strong></p><div class="table-contents"><table summary="Webx如何处理异常" cellpadding="10" style="border: none;"><colgroup><col width="17%" class="c1"/><col width="35%" class="c2"/><col width="48%" class="c3"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">条件</th><th style="border-bottom: 0.5pt solid #6666cc; " valign="middle">处理</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">开发模式</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">展示详细出错信息。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " rowspan="2" valign="middle">生产模式</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">假如存在exception pipeline</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">用exception pipeline来处理异常；</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">不存在exception pipeline</td><td style="" valign="middle">显示web.xml中定义的默认错误页面。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.overview.framework.devmode"><!--anchor webx.overview.framework.devmode--></a>3.2.4. 开发模式工具</h3></div></div></div><p>Webx Framework提供了一个开关，可以让应用运行于“<span class="emphasis"><em>生产模式（Production
                    Mode）</em></span>”或是“<span class="emphasis"><em>开发模式（Development Mode）</em></span>” 。</p><div class="example"><a id="d0e1720"><!--anchor d0e1720--></a><p class="title"><strong>例 3.7. 配置运行模式</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:webx-configuration&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:productionMode&gt;</strong><span class="emphasis"><em>${productionMode:true}</em></span><strong class="hl-tag" style="color: #000096">&lt;/services:productionMode&gt;</strong> <a id="co.webx.running.mode"><!--anchor co.webx.running.mode--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/services:webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.running.mode"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>使用这行配置，并且在启动应用服务器时指定参数“<code class="code">-DproductionMode=false</code>”，就会让Webx以开发模式启动。</p></td></tr></table></div></div></div><p>在开发模式下，会有一系列不同于生产模式的行为。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>不同的主页 —— 在开发模式的主页中，可以查看和查询系统内部的信息。</p><div class="figure"><a id="d0e1743"><!--anchor d0e1743--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-homepage.png" alt="开发模式的主页"/></div></div><p class="title"><strong>图 3.4. 开发模式的主页</strong></p></div></li><li class="listitem"><p>不同的详细出错页面。</p><div class="figure"><a id="d0e1752"><!--anchor d0e1752--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-errorpage.png" alt="开发模式的详细出错页面"/></div></div><p class="title"><strong>图 3.5. 开发模式的详细出错页面</strong></p></div></li><li class="listitem"><p>开发模式下，可展示所有可用的schemas。</p><div class="figure"><a id="d0e1761"><!--anchor d0e1761--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-schemapage.png" alt="开发模式下展示所有可用的schemas"/></div></div><p class="title"><strong>图 3.6. 开发模式下展示所有可用的schemas</strong></p></div></li><li class="listitem"><p>开发模式下，可以查阅容器内部的信息。</p><div class="figure"><a id="d0e1770"><!--anchor d0e1770--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-explorerpage.png" alt="开发模式下查阅容器内部的信息"/></div></div><p class="title"><strong>图 3.7. 开发模式下查阅容器内部的信息</strong></p></div><p>可供查阅的信息包括：</p><div class="table"><a id="d0e1778"><!--anchor d0e1778--></a><p class="title"><strong>表 3.5. 开发模式中可供查阅的容器信息</strong></p><div class="table-contents"><table summary="开发模式中可供查阅的容器信息" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Beans</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看各Spring容器中的全部bean的定义。</p>
                                        <p>这个工具有助于开发者理解用schema所定义的services和spring
                                            beans之间的联系。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Configurations</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看用来创建各Spring容器的配置文件。</p>
                                        <p>这个工具会以树状和语法高亮显示配置文件以及所有被import的配置文件的内容。</p>
                                        <p>不同于Beans工具，Configurations工具只忠实地展现配置文件的内容。而Beans工具展现的是真实的Beans结构。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Resolvable Dependencies</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看所有由框架置入到容器中的对象，例如：<code class="classname">HttpServletRequest</code>对象。这些对象不需要在配置文件中定义，就可被注入到应用中。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Resources</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>跟踪Resources的装载过程，显示Resources的树状结构。</p>
                                        <p>这个工具有助于开发者理解<code class="classname">ResourceLoadingService</code>的工作原理。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">URIs</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看所有的URI brokers。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Pull Tools</td><td style="">
                                        <p>查看所有模板中可用的pull tools。</p>
                                    </td></tr></tbody></table></div></div></li></ul></div><p>事实上，Webx Framework提供了一套专用的内部框架，使你可以往开发模式中添加更多的开发工具。例如，创建下面的功能并非难事：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>查看session对象。</p></li><li class="listitem"><p>提供各种编码、解码的工具，以方便开发、调试应用。例如：将<code class="code">UTF-8</code>编码的字符串转换成<code class="code">GBK</code>编码；或者将字符串进行URL
                            escape编码、解码等。</p></li></ul></div><p>Webx Framework提供了一个接口：<code class="code">ProductionModeAware</code>。Spring
                context中的beans，如果实现了这个接口，就可以感知当前系统的运行模式，从而根据不同的模式选择不同的行为 ——
                例如：在生产模式中打开cache，在开发模式中关闭cache。</p><div class="example"><a id="d0e1877"><!--anchor d0e1877--></a><p class="title"><strong>例 3.8. 利用<code class="code">ProductionModeAware</code>接口感知运行模式，并自动开关cache</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> ModuleLoaderServiceImpl <strong class="hl-keyword" style="color: maroon">implements</strong> ProductionModeAware {  <a id="co.prod.mode.aware.impl"><!--anchor co.prod.mode.aware.impl--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setProductionMode(<strong class="hl-keyword" style="color: maroon">boolean</strong> productionMode) { <a id="co.prod.mode.aware.impl2"><!--anchor co.prod.mode.aware.impl2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-keyword" style="color: maroon">this</strong>.productionMode = productionMode;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword" style="color: maroon">protected</strong> <strong class="hl-keyword" style="color: maroon">void</strong> init() {
        ……
        <strong class="hl-keyword" style="color: maroon">if</strong> (cacheEnabled == null) {
            cacheEnabled = productionMode; <a id="co.prod.mode.aware.cache"><!--anchor co.prod.mode.aware.cache--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        }
        ……
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.prod.mode.aware.impl"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.prod.mode.aware.impl2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>实现<code class="code">ProductionModeAware</code>接口。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.prod.mode.aware.cache"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>根据当前运行模式自动开关cache。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1901"><!--anchor d0e1901--></a>3.2.5. 响应和处理请求的更多细节</h3></div></div></div><p>当一个HTTP请求到达时，首先由WebxFrameworkFilter接手这个请求：</p><div class="example"><a id="d0e1906"><!--anchor d0e1906--></a><p class="title"><strong>例 3.9. 配置<code class="code">WebxFrameworkFilter</code> -
                    <code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>webx<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-class&gt;</strong><span class="emphasis"><em>com.alibaba.citrus.webx.servlet.WebxFrameworkFilter</em></span><strong class="hl-tag" style="color: #000096">&lt;/filter-class&gt;</strong> <a id="co.webx.filter"><!--anchor co.webx.filter--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>excludes<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 需要被“排除”的URL路径，以逗号分隔，前缀!表示“包含”。例如/static, *.jpg, !/uploads/*.jpg --&gt;</em><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>  <a id="co.webx.filter.exclude"><!--anchor co.webx.filter.exclude--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>passthru<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 需要被“略过”的URL路径，以逗号分隔，前缀!表示“不要略过”。例如/myservlet, *.jsp --&gt;</em><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>  <a id="co.webx.filter.passthru"><!--anchor co.webx.filter.passthru--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;filter-mapping&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>webx<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url-pattern&gt;</strong><span class="emphasis"><em>/*</em></span><strong class="hl-tag" style="color: #000096">&lt;/url-pattern&gt;</strong>  <a id="co.webx.filter.mapping"><!--anchor co.webx.filter.mapping--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/filter-mapping&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义<code class="code">WebxFrameworkFilter</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter.exclude"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可选的参数：“排除”指定名称的path，以逗号分隔，例如：<code class="code">/static</code>,
                                <code class="code">*.jpg</code>。如果路径以<code class="code">!</code>开始，表示“不排除”特殊目录。例如：<code class="code">*.jpg,
                                !/uploads/*.jpg</code>表示排除所有JPG图像文件，但不排除<code class="code">/uploads</code>目录下的JPG图像文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter.passthru"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可选的参数：“略过”指定名称的path，以逗号分隔，例如：<code class="code">/myservlet</code>,
                                <code class="code">*.jsp</code>。和<code class="code">excludes</code>参数一样，也支持<code class="code">!</code>前缀，表示“不要略过”特殊目录。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter.mapping"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>匹配所有的path。</p></td></tr></table></div></div></div><p>为什么使用filter而不是servlet呢？传统的WEB框架的控制器一般都是用servlet实现的。原因是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Filter可以“返还控制” —— 上面的配置文件直接把“/*”映射到webx
                            filter中，这意味着webx接管了这个应用的所有请求。静态页面和资源怎么办？没关系，如果webx发现这个请求不应该由webx来处理，就会把控制“返还”给原来的控制器
                            ——
                            可能是另一个filter、servlet或者返回给servlet引擎，以默认的方式来处理。而Servlet是不具备“返还控制”的机制的。</p></li><li class="listitem"><p>Servlet/Filter mapping的局限性 ——
                            标准的servlet引擎将URL映射到filter或servlet时，只支持前缀映射和后缀映射两种方式，非常局限。而实际情况往往复杂得多。Webx建议将所有请求都映射给webx来处理，让webx对请求做更灵活的映射。
                        </p></li></ul></div><p>如果你的web.xml中还有一些其它的servlet
                    mappings，为了避免和Webx的URL起冲突，你可以把这些mapping加在<code class="code">excludes</code>或<code class="code">passthru</code>参数里。这样，WebxFrameworkFilter就会排除或略过指定的URL。例如：</p><pre class="programlisting">        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>excludes<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>/static, *.jpg, !/uploads/*.jpg</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>passthru<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>/myservlet, *.jsp</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong></pre><p>“<code class="code">passthru</code>略过”和“<code class="code">excludes</code>排除”的区别在于，如果一个servlet或filter接手被webx
                    <code class="code">passthru</code>的请求时，它们还是可以访问到webx的部分服务，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">RequestContext</code>服务，例如：解析参数、解析upload请求、重写请求、设置字符集编码和区域、基于cookie的session等。</p></li><li class="listitem"><p>开发模式及工具。</p></li><li class="listitem"><p>异常处理。</p></li><li class="listitem"><p>共享webx的spring容器。</p></li></ul></div><p>也就是说，对于一个被<code class="code">passthru</code>的请求，webx的行为更像是一个普通的filter。而“排除”则不同，如果一个请求被“排除”，webx将会立即放弃控制，将请求交还给服务器。接手控制的servlet或filter将无法访问webx一切的服务。</p><p>下图是WebxFrameworkFilter处理一个WEB请求的过程。</p><div class="figure"><a id="d0e2031"><!--anchor d0e2031--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/request-processing-detailed.png" alt="WebxFrameworkFilter处理请求的详细过程"/></div></div><p class="title"><strong>图 3.8. <code class="code">WebxFrameworkFilter</code>处理请求的详细过程</strong></p></div><p>如图所示，<code class="code">WebxFrameworkFilter</code>接到请求以后，就会调用<code class="code">WebxRootController</code>。从这里开始，进入Spring的世界
                ——
                    此后所有的对象：<code class="code">WebxRootController</code>、<code class="code">WebxController</code>、<code class="code">RequestContext</code>、<code class="code">Pipeline</code>等，全部是通过SpringExt配置在Spring
                Context中的。</p><p><code class="code">WebxRootController</code>对象存在于root
                    context中，它被所有子应用所共享。它会创建<code class="code">RequestContext</code>实例 ——
                    从而增强request、response、session的功能。接下来，<code class="code">WebxController</code>对象会被调用。</p><p><code class="code">WebxController</code>对象是由每个子应用独享的，子应用<code class="code">app1</code>和<code class="code">app2</code>可以有不同的<code class="code">WebxController</code>实现。默认的实现，会调用pipeline。</p><p>Pipeline也是由各子应用自己来配置的。假如pipeline碰到无法处理的请求，如静态页面、图片等，pipeline应当执行<code class="code">&lt;exit/&gt;</code>
                    valve强制退出。然后<code class="code">WebxRootController</code>就会“放弃控制” ——
                    这意味着request将被返还给<code class="filename">/WEB-INF/web.xml</code>中定义的servlet、filter或者返还给servlet
                engine本身来处理。 </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2093"><!--anchor d0e2093--></a>3.3. 定制Webx Framework</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2096"><!--anchor d0e2096--></a>3.3.1. 定制<code class="code">WebxRootController</code></h3></div></div></div><p><code class="code">WebxRootController</code>是被所有子应用所共享的逻辑。
                    假如你想创建一种新的WEB框架，可以自己定义一个新的<code class="code">WebxRootController</code>的实现。这个方案非常适合作为一个新Web框架的起点。</p><div class="example"><a id="d0e2108"><!--anchor d0e2108--></a><p class="title"><strong>例 3.10. 自定义<code class="code">WebxRootController</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;webx-configuration</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;components&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rootController</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyRootController"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.webx.root.controller"><!--anchor co.webx.root.controller--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/components&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.root.controller"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>创建自己的<code class="code">WebxRootController</code>。最简便的方法是：扩展<code class="code">AbstractWebxRootController</code>，免去了创建Servlet/Filter、初始化Spring容器、处理request、response等繁杂事务，并且完全支持SpringExt的所有功能，此外还包含了错误处理、开发模式等Webx
                            Framework中的一切便利。。 </p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2127"><!--anchor d0e2127--></a>3.3.2. 定制<code class="code">WebxController</code></h3></div></div></div><p><code class="code">WebxController</code>是用来控制子应用的。每个子应用可以拥有不同的<code class="code">WebxController</code>实现。</p><p>Webx
                    Framework默认的<code class="code">WebxController</code>是调用pipeline。假如你不想用pipeline，而希望实现自己的针对子应用的逻辑，那么最简单的方法就是实现自己的<code class="code">WebxController</code>或者扩展<code class="code">AbstractWebxController</code>。 </p><div class="example"><a id="d0e2150"><!--anchor d0e2150--></a><p class="title"><strong>例 3.11. 自定义WebxController</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;webx-configuration</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;components</strong> <span class="hl-attribute" style="color: #F5844C">defaultControllerClass</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyController"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.webx.controller.default"><!--anchor co.webx.controller.default--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;component</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"app1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;controller</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyController"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.webx.controller.app"><!--anchor co.webx.controller.app--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/component&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/components&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.controller.default"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定默认的<code class="code">WebxController</code>实现类。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.controller.app"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>对特定子应用明确指定<code class="code">WebxController</code>实现类。</p></td></tr></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2172"><!--anchor d0e2172--></a>3.4. 本章总结</h2></div></div></div><p>Webx Framework提供了一个可剪裁、可扩展的处理WEB请求基本框架。它所提供的基本功能事实上是每个WEB框架都需要用到的。Webx
            Framework为进一步实现WEB框架提供了坚实的基础。</p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.overview.turbine"><!--anchor webx.overview.turbine--></a>第 4 章 Webx Turbine</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2185">4.1. 设计理念</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2197">4.1.1. 页面驱动</a></span></dt><dt><span class="section"><a href="#d0e2214">4.1.2. 约定胜于配置</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2256">4.2. 页面布局</a></span></dt><dt><span class="section"><a href="#d0e2279">4.3. 处理页面的基本流程</a></span></dt><dt><span class="section"><a href="#d0e2479">4.4. 依赖注入</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2482">4.4.1. Spring原生注入手段</a></span></dt><dt><span class="section"><a href="#d0e2508">4.4.2. 注入request、response和session对象</a></span></dt><dt><span class="section"><a href="#d0e2538">4.4.3. 参数注入</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2646">4.5. 定制Webx Turbine</a></span></dt><dt><span class="section"><a href="#d0e2668">4.6. 本章总结</a></span></dt></dl></div><p>Webx是一套基于Java Servlet API的通用Web框架。整个Webx框架分成三个层次，本章将简单介绍其第三个层次：Webx Turbine。Webx
        Turbine建立在Webx Framework的基础上，实现了页面渲染、布局、数据验证、数据提交等一系列工作。</p><p>Webx Turbine之所以叫这个名字，是因为Webx最早的版本，是从Apache
        Turbine项目上发展而来的。到现在，Turbine的代码已经荡然无存，然而Turbine中的一些风格和想法依赖保存在Webx框架中。 </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2185"><!--anchor d0e2185--></a>4.1. 设计理念</h2></div></div></div><p>Webx Turbine所遵循下面的设计理念包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>页面驱动</p></li><li class="listitem"><p>约定胜于配置</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2197"><!--anchor d0e2197--></a>4.1.1. 页面驱动</h3></div></div></div><p>创建一个WEB应用，一般会经历三个阶段：产品设计、用户界面设计、功能实现。分别由产品设计师、用户界面设计师和程序员协作完成。如下图所示。</p><div class="figure"><a id="d0e2202"><!--anchor d0e2202--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o4/co-operations.png" alt="协作图：创建一个WEB应用"/></div></div><p class="title"><strong>图 4.1. 协作图：创建一个WEB应用</strong></p></div><p>通常，界面设计师只完成纯静态页面的设计，需要由程序员来把静态页面转换、分解成模板，才能在最终的WEB应用中被使用。为什么不让界面设计师直接创建模板呢？这样一定可以提高很多效率。然而在一般的WEB框架中，由于模板不能独立于程序元素（如action）而存在，因此在程序员介入以前，界面设计师是没有办法展示模板的效果的。</p><p>Webx
                Turbine推崇页面驱动的理念。它的意思是，在程序员介入以前，让界面设计师可以直接创建模板，并展示模板的效果。页面驱动的反面，是程序驱动，或者是Action驱动 ——
                这是多数WEB框架的模式。</p><p>页面驱动不止提高了开发的效率，也使界面设计师在早期阶段，就可以利用框架所提供的工具，做一些以前做不到的事，例如：页面跳转、简单的表单验证、字符串操作等。这些工具是通过Webx
                Turbine中的一个服务来完成的：pull tools。Pull tools服务预先准备了很多模板中可用的工具，让模板可以“按需”取得这些对象 ——
                这就是pull这个单词的意思。 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2214"><!--anchor d0e2214--></a>4.1.2. 约定胜于配置</h3></div></div></div><p>Webx Turbine的另一个理念，是约定胜于配置。“约定”即规则。规则是预先定义的，工程师只需要按着规则来做事，就不需要额外的“配置”。对比其它一些框架 ——
                往往每增加一个页面，都需要在配置文件中增加若干行内容。</p><p>Webx Turbine的规则主要是指一系列映射规则。 </p><div class="table"><a id="d0e2221"><!--anchor d0e2221--></a><p class="title"><strong>表 4.1. Webx Turbine映射规则</strong></p><div class="table-contents"><table summary="Webx Turbine映射规则" cellpadding="10" style="border: none;"><colgroup><col width="27%" class="c1"/><col width="73%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">映射规则</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">将URL映射成target</td><td style="border-bottom: 0.5pt solid #6666cc; ">target是一个抽象的概念，指明当前请求要完成的任务。Target由pipeline来解释，它可能被解释成模板名，也可能被解释成别的东西。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">将target转换成模板名</td><td style="border-bottom: 0.5pt solid #6666cc; ">模板用来展现页面的内容。Velocity、Freemarker、JSP都可以作为模板的格式，但在Webx建议使用velocity模板。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">将target转换成layout布局</td><td style="border-bottom: 0.5pt solid #6666cc; ">你可以为一组页面选择相同的布局（菜单、导航栏、版权信息等），为另一组页面选择另一种布局。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">将target转换成module</td><td style="">在Webx
                                Turbine中，module是指screen、action、control等，大致相当于其它框架中的action或者controller。</td></tr></tbody></table></div></div><p>工程师只需要根据上述规则，将模板放在指定的目录、按照预定的方式命名module（也就是screen、action、control等），就不再需要额外的配置。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2256"><!--anchor d0e2256--></a>4.2. 页面布局</h2></div></div></div><p>Webx Turbine的页面，由以下几个部分组成：</p><div class="figure"><a id="d0e2261"><!--anchor d0e2261--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o4/page-layout.png" alt="Webx Turbine页面的构成"/></div></div><p class="title"><strong>图 4.2. Webx Turbine页面的构成</strong></p></div><p>其中：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Screen，代表页面的主体。</p></li><li class="listitem"><p>Layout，代表页面的布局。</p></li><li class="listitem"><p>Control，代表嵌在screen和layout中的页面片段。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2279"><!--anchor d0e2279--></a>4.3. 处理页面的基本流程</h2></div></div></div><p>Webx Turbine的处理流程被定义在pipeline中。Webx Framework没有规定Pipeline的内容，但Webx
            Turbine却定义了一系列valves。下面是一个Webx Turbine推荐的pipeline配置：</p><div class="example"><a id="d0e2284"><!--anchor d0e2284--></a><p class="title"><strong>例 4.1. Webx Turbine推荐的pipeline配置 - <code class="filename">pipeline.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 初始化turbine rundata，并在pipelineContext中设置可能会用到的对象(如rundata、utils)，以便valve取得。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;prepareForTurbine /&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 设置日志系统的上下文，支持把当前请求的详情打印在日志中。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;setLoggingContext /&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 分析URL，取得target。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;analyzeURL</strong> <span class="hl-attribute" style="color: #F5844C">homepage</span>=<span class="hl-value" style="color: #993300">"homepage"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <em class="hl-comment" style="color: green">&lt;!-- 检查csrf token，防止csrf攻击和重复提交。假如request和session中的token不匹配，则出错，或显示expired页面。 --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                <em class="hl-comment" style="color: green">&lt;!-- 执行带模板的screen，默认有layout。 --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"null, vm, jsp"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performTemplateScreen /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;renderTemplate /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                <em class="hl-comment" style="color: green">&lt;!-- 执行不带模板的screen，默认无layout。 --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"do"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;performScreen /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong>
                <em class="hl-comment" style="color: green">&lt;!-- 将控制交还给servlet engine。 --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;exit /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 假如rundata.setRedirectTarget()被设置，则循环，否则退出循环。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;breakUnlessTargetRedirected /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div><p>假设用户以URL：<code class="code">http://localhost:8081/</code>来访问Webx应用。域名和端口不重要，取决于应用服务器的配置，这里假设为<code class="code">localhost:8081</code>。Webx
                Framework的处理流程，从<code class="code">WebxFrameworkFilter</code>接收请求，并且一路顺利到达pipeline。然后Pipeline开始依次执行它的valves。（下面的描述略过一些相对次要的步骤。）</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p class="title"><strong><code class="code">&lt;analyzeURL&gt;</code> - 分析URL</strong></p><p>分析URL的目的是取得target。由于用户访问的URL中并没有提供path信息，通常被理解为：用户想要访问“主页”。<code class="code">AnalyzeURL</code>
                        valve提供了一个可选的参数“<code class="code">homepage</code>”，即是在这种情况下起作用 ——
                        <code class="code">http://localhost:8081/</code>对应的target为“<code class="code">homepage</code>”。</p><p>需要注意的是，<span class="emphasis"><em>target不代表模板名，也不代表类名</em></span>。Target只是一个抽象的概念 ——
                        当前页面需要达成的目标。Target可能被后续的valves<span class="emphasis"><em>解释成</em></span>模板名、类名或者其它东西。 </p></li><li class="step"><p class="title"><strong>进入<code class="code">&lt;choose&gt;</code> - 多重分支</strong></p><p>很明显，“<code class="code">homepage</code>”满足了第一个<code class="code">&lt;when&gt;</code>所附带的条件：<code class="code">&lt;target-extension-condition
                        extension="null, vm,
                        jsp"&gt;</code>，意思是target的后缀不存在（<code class="code">null</code>）或为“<code class="code">jsp</code>”或为“<code class="code">vm</code>”。</p></li><li class="step"><p class="title"><strong><code class="code">&lt;performAction&gt;</code> - 执行action</strong></p><p>和其它框架中的action概念不同，在Webx Turbine中，action是用来处理用户提交的表单的。</p><p>因为本次请求未提供action参数，所以跳过该步骤。 </p></li><li class="step"><p class="title"><strong><code class="code">&lt;performTemplateScreen&gt;</code> - 查找并执行screen。</strong></p><p>这里要用到一个规则：target映射成screen module类名的规则。</p><p>假设target为<code class="code">xxx/yyy/zzz</code>，那么Webx Turbine会依次查找下面的screen模块：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">screen.xxx.yyy.Zzz</code>，</p></li><li class="listitem"><p><code class="code">screen.xxx.yyy.Default</code>，</p></li><li class="listitem"><p><code class="code">screen.xxx.Default</code>，</p></li><li class="listitem"><p><code class="code">screen.Default</code>。 </p></li></ul></div><p>本次请求的target为<code class="code">homepage</code>，因此它会尝试查找<code class="code">screen.Homepage</code>和<code class="code">screen.Default</code>这两个类。</p><p>如果找到screen类，Webx
                    Turbine就会执行它。Screen类的功能，通常是读取数据库，然后把模板所需要的对象放到context中。</p><p>如果找不到，也没关系 ——
                    这就是“页面优先”：像<code class="code">homepage</code>这样的主页，通常没有业务逻辑，因此不需要screen类，只需要有模板就可以了。 </p></li><li class="step"><p class="title"><strong><code class="code">&lt;renderTemplate&gt;</code> - 渲染模板</strong></p><p>这里用到两个规则：target映射成screen template，以及target映射成layout template。</p><p>假设target为<code class="code">xxx/yyy/zzz</code>，那么Webx
                        Turbine会查找下面的screen模板：<code class="code">/templates/screen/xxx/yyy/zzz</code>。Screen模板如果未找到，就会报<code class="code">404
                        Not Found</code>错误。 找到screen模板以后，Webx Turbine还会试着查找下面的layout模板：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">/templates/layout/xxx/yyy/zzz</code></p></li><li class="listitem"><p><code class="code">/templates/layout/xxx/yyy/default</code></p></li><li class="listitem"><p><code class="code">/templates/layout/xxx/default</code></p></li><li class="listitem"><p><code class="code">/templates/layout/default</code></p></li></ul></div><p>Layout模板如果找不到，就直接渲染screen模板；如果存在，则把渲染screen模板后的结果，嵌入到layout模板中。</p><p>Layout模板和screen模板中，都可以调用control。每个页面只有一个screen，却可以有任意多个controls。 </p></li><li class="step"><p class="title"><strong><code class="code">&lt;breakUnlessTargetRedirected&gt;</code> - 内部重定向</strong></p><p>在screen和action中，可以进行“内部重定向”。内部重定向实质上就是由<code class="code">&lt;breakUnlessTargetRedirected&gt;</code>实施的
                    —— 如果没有重定向标记，就退出；否则循环到<code class="code">&lt;loop&gt;</code>标签。</p><p>和外部重定向不同，外部重定向是向浏览器返回一个<code class="code">302</code>或<code class="code">303</code>
                        response，其中包含<code class="code">Location</code>
                    header，浏览器看到这样的response以后，就会发出第二个请求。而内部重定向发生在pipeline内部，浏览器并不了解内部重定向。</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2479"><!--anchor d0e2479--></a>4.4. 依赖注入</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2482"><!--anchor d0e2482--></a>4.4.1. Spring原生注入手段</h3></div></div></div><p>依赖注入是Spring的重要特性，Webx既然建立在Spring基础上，当然支持Spring原有的依赖注入手段，例如，你可以在Screen/control/action
                module类中这样写：</p><div class="example"><a id="d0e2487"><!--anchor d0e2487--></a><p class="title"><strong>例 4.2. 通过<code class="code">@Autowired</code> annotation注入</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> UserManager userManager; <a id="co.spring.autowired"><!--anchor co.spring.autowired--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.spring.autowired"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">UserManager</code>是在spring context中配置的bean。</p></td></tr></table></div></div></div><p>在使用Spring原生注入手段时，需要注意beans的scope。你只能注入相同scope或较大的scope中的bean。例如，screen/action/control的scope为singleton，因此用<code class="code">@Autowired</code>注入时，只能注入singleton的对象，不能注入诸如request、session等较小的scope对象。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2508"><!--anchor d0e2508--></a>4.4.2. 注入request、response和session对象</h3></div></div></div><p>在Webx Framework中，你可以这样做：</p><div class="example"><a id="d0e2513"><!--anchor d0e2513--></a><p class="title"><strong>例 4.3. 注入request、response和session对象</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpSession session;
    ...
}</pre></div></div><p>前面我们刚讲过，你<span class="emphasis"><em>不能把request scope的对象，注入到singleton
                        scope的对象中</em></span>。但在Webx中，你<span class="emphasis"><em>可以将<code class="code">HttpServletRequest</code>、<code class="code">HttpServletResponse</code>和<code class="code">HttpSession</code>对象注入到singleton对象中</em></span>。为什么呢？原来，<code class="code">&lt;request-contexts&gt;</code>对这几个常用对象进行了特殊处理，将它们转化成了singleton对象。
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2538"><!--anchor d0e2538--></a>4.4.3. 参数注入</h3></div></div></div><p>有一些对象，是无法通过Spring的bean来注入的，例如：用户提交的参数、表单等。好在Webx
                    Turbine提供了一种可扩展的机制（<code class="code">DataResolver</code>
                service），通过它，我们可以在screen/control/action的方法中注入任意对象。</p><div class="table"><a id="d0e2546"><!--anchor d0e2546--></a><p class="title"><strong>表 4.2. 参数注入</strong></p><div class="table-contents"><table summary="参数注入" cellpadding="10" style="border: none;"><colgroup><col width="22%" class="c1"/><col width="60%" class="c2"/><col width="18%" class="c3"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">功能</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">代码示例</th><th style="border-bottom: 0.5pt solid #6666cc; " valign="middle">适用于module类型</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">注入一个query参数</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetInt(<em><span class="hl-annotation" style="color: gray">@Param("aaa")</span></em> <strong class="hl-keyword" style="color: maroon">int</strong> i)</pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">将query参数注入bean properties</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doSetData(<em><span class="hl-annotation" style="color: gray">@Params</span></em> MyData data) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="3" valign="middle">注入框架对象</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetNavigator(Navigator nav)</pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetContext(Context context) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> execute(ControlParameters params) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">注入context和control参数</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> execute(<em><span class="hl-annotation" style="color: gray">@ContextValue("myvalue")</span></em> <strong class="hl-keyword" style="color: maroon">int</strong> value) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">screen、 action、 control</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2" valign="middle">注入表单对象</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetGroup(<em><span class="hl-annotation" style="color: gray">@FormGroup("myGroup1")</span></em> Group group) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">action</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetGroups(<em><span class="hl-annotation" style="color: gray">@FormGroups("myGroup1")</span></em> Group[] groups) </pre>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">action</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">将表单值注入bean properties</td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">
                                <pre class="programlisting"><strong class="hl-keyword" style="color: maroon">void</strong> doGetGroupsBeans(<em><span class="hl-annotation" style="color: gray">@FormGroups("myGroup1")</span></em> MyData[] data) </pre>
                            </td><td style="" valign="middle">action</td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2646"><!--anchor d0e2646--></a>4.5. 定制Webx Turbine</h2></div></div></div><p>通过改进pipeline中的valves，我们很容易改变webx turbine的行为。</p><p>最常见的一种需求，是要对页面进行授权 —— 只有符合条件的用户才能访问相应的页面。在pipeline中，很容易添加这样的逻辑： </p><div class="example"><a id="d0e2653"><!--anchor d0e2653--></a><p class="title"><strong>例 4.4. 改进pipeline，增加页面授权功能 - <code class="filename">pipeline.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;prepareForTurbine /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;setLoggingContext /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;analyzeURL</strong> <span class="hl-attribute" style="color: #F5844C">homepage</span>=<span class="hl-value" style="color: #993300">"homepage"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;valve</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.mycompany.auth.PageAuthorizationValve"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.pipeline.auth"><!--anchor co.pipeline.auth--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.pipeline.auth"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>插入用于验证权限的valve。</p></td></tr></table></div></div></div><p>事实上，你甚至可以重写整个pipeline，以实现另一种风格的WEB框架。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2668"><!--anchor d0e2668--></a>4.6. 本章总结</h2></div></div></div><p>Webx Turbine建立在pipeline的基础上，基于页面驱动和约定胜于配置的理念，定义了一组处理页面的流程。Webx
            Turbine的灵活性在于，你可以轻易定制pipeline，以改变它的任何一个方面。</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="webx.basic.services"><!--anchor webx.basic.services--></a>部分 II. Webx基础设施服务</h1></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="#webx.resource">第 5 章 Resource Loading服务指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2690">5.1. 资源概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2693">5.1.1. 什么是资源？</a></span></dt><dt><span class="section"><a href="#d0e2738">5.1.2. 如何表示资源？</a></span></dt><dt><span class="section"><a href="#d0e2867">5.1.3. 如何访问资源？</a></span></dt><dt><span class="section"><a href="#d0e2932">5.1.4. 如何遍历资源？</a></span></dt><dt><span class="section"><a href="#d0e2970">5.1.5. 有什么问题？</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3004">5.2. Spring的<code class="code">ResourceLoader</code>机制</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3015">5.2.1. <code class="code">Resource</code>接口</a></span></dt><dt><span class="section"><a href="#d0e3064">5.2.2. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</a></span></dt><dt><span class="section"><a href="#d0e3091">5.2.3. 在代码中取得资源</a></span></dt><dt><span class="section"><a href="#d0e3210">5.2.4. Spring如何装载资源？</a></span></dt><dt><span class="section"><a href="#d0e3390">5.2.5. Spring <code class="code">ResourceLoader</code>的缺点</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3457">5.3. Resource Loading服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3460">5.3.1. 替换Spring <code class="code">ResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.define.newres">5.3.2. 定义新资源</a></span></dt><dt><span class="section"><a href="#webx.resource.rename.res">5.3.3. 重命名资源</a></span></dt><dt><span class="section"><a href="#webx.resource.redirect.res">5.3.4. 重定向资源</a></span></dt><dt><span class="section"><a href="#webx.resource.matching">5.3.5. 匹配资源</a></span></dt><dt><span class="section"><a href="#webx.resource.multi.loaders">5.3.6. 在多个<code class="code">ResourceLoader</code>中查找</a></span></dt><dt><span class="section"><a href="#webx.resource.load.parent">5.3.7. 装载parent容器中的资源</a></span></dt><dt><span class="section"><a href="#webx.resource.modify.res">5.3.8. 修改资源文件的内容</a></span></dt><dt><span class="section"><a href="#webx.resource.using.service">5.3.9. 直接使用<code class="code">ResourceLoadingService</code></a></span></dt><dt><span class="section"><a href="#webx.resource.using.service.nonweb">5.3.10. 在非Web环境中使用Resource Loading服务</a></span></dt></dl></dd><dt><span class="section"><a href="#webx.resource.loaders">5.4. ResourceLoader参考</a></span></dt><dd><dl><dt><span class="section"><a href="#webx.resource.loader.file">5.4.1. <code class="code">FileResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.webapp">5.4.2. <code class="code">WebappResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.classpath">5.4.3. <code class="code">ClasspathResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.super">5.4.4. <code class="code">SuperResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.other">5.4.5. 关于<code class="code">ResourceLoader</code>的其它考虑</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4876">5.5. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.filter.requestcontexts.pipeline">第 6 章 Filter、Request Contexts和Pipeline</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4894">6.1. Filter</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4897">6.1.1. Filter的用途</a></span></dt><dt><span class="section"><a href="#d0e4957">6.1.2. Filter工作原理</a></span></dt><dt><span class="section"><a href="#d0e5017">6.1.3. Filter的限制</a></span></dt><dt><span class="section"><a href="#d0e5045">6.1.4. Webx对filter功能的补充</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5103">6.2. Request Contexts服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5106">6.2.1. Request Contexts工作原理</a></span></dt><dt><span class="section"><a href="#d0e5148">6.2.2. Request Contexts的用途</a></span></dt><dt><span class="section"><a href="#d0e5217">6.2.3. Request Contexts的使用</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5451">6.3. Pipeline服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5454">6.3.1. Pipeline工作原理</a></span></dt><dt><span class="section"><a href="#d0e5477">6.3.2. Pipeline的用途</a></span></dt><dt><span class="section"><a href="#d0e5490">6.3.3. Pipeline的使用</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6044">6.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.requestcontexts">第 7 章 Request Contexts功能指南</a></span></dt><dd><dl><dt><span class="section"><a href="#webx3.requestcontexts.basic">7.1. <code class="code">&lt;basic&gt;</code> - 提供基础特性</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6148">7.1.1. 拦截器接口</a></span></dt><dt><span class="section"><a href="#d0e6263">7.1.2. 默认拦截器</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.setlocale">7.2. <code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6310">7.2.1. Locale基础</a></span></dt><dt><span class="section"><a href="#d0e6385">7.2.2. Charset编码基础</a></span></dt><dt><span class="section"><a href="#d0e6456">7.2.3. Locale和charset的关系</a></span></dt><dt><span class="section"><a href="#d0e6620">7.2.4. 设置locale和charset</a></span></dt><dt><span class="section"><a href="#d0e6788">7.2.5. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.parser">7.3. <code class="code">&lt;parser&gt;</code> - 解析参数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7126">7.3.1. 基本使用方法</a></span></dt><dt><span class="section"><a href="#d0e7262">7.3.2. 上传文件</a></span></dt><dt><span class="section"><a href="#d0e7441">7.3.3. 高级选项</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.buffered">7.4. <code class="code">&lt;buffered&gt;</code> - 缓存response中的内容</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7851">7.4.1. 实现原理</a></span></dt><dt><span class="section"><a href="#d0e7918">7.4.2. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.lazycommit">7.5. <code class="code">&lt;lazy-commit&gt;</code> - 延迟提交response</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8029">7.5.1. 什么是提交</a></span></dt><dt><span class="section"><a href="#d0e8073">7.5.2. 实现原理</a></span></dt><dt><span class="section"><a href="#d0e8092">7.5.3. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.rewrite">7.6. <code class="code">&lt;rewrite&gt;</code> -重写请求的URL和参数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8198">7.6.1. 概述</a></span></dt><dt><span class="section"><a href="#d0e8268">7.6.2. 取得路径</a></span></dt><dt><span class="section"><a href="#d0e8308">7.6.3. 匹配rules</a></span></dt><dt><span class="section"><a href="#d0e8375">7.6.4. 匹配conditions</a></span></dt><dt><span class="section"><a href="#d0e8723">7.6.5. 替换路径</a></span></dt><dt><span class="section"><a href="#d0e8827">7.6.6. 替换参数</a></span></dt><dt><span class="section"><a href="#d0e8904">7.6.7. 后续操作 </a></span></dt><dt><span class="section"><a href="#d0e8971">7.6.8. 重定向</a></span></dt><dt><span class="section"><a href="#d0e9047">7.6.9. 自定义处理器</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9067">7.7. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#webx.requestcontext.session">第 8 章 Request Context之Session指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9084">8.1. Session概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9087">8.1.1. 什么是Session</a></span></dt><dt><span class="section"><a href="#d0e9106">8.1.2. Session数据存在哪？</a></span></dt><dt><span class="section"><a href="#d0e9174">8.1.3. 创建通用的session框架</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9198">8.2. Session框架</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9201">8.2.1. 最简配置</a></span></dt><dt><span class="section"><a href="#d0e9237">8.2.2. Session ID</a></span></dt><dt><span class="section"><a href="#d0e9520">8.2.3. Session的生命期</a></span></dt><dt><span class="section"><a href="#d0e9681">8.2.4. Session Store</a></span></dt><dt><span class="section"><a href="#d0e9822">8.2.5. Session Model</a></span></dt><dt><span class="section"><a href="#d0e9878">8.2.6. Session Interceptor</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9984">8.3. Cookie Store</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10006">8.3.1. 多值Cookie Store</a></span></dt><dt><span class="section"><a href="#d0e10438">8.3.2. 单值Cookie Store</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10791">8.4. 其它Session Store</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10794">8.4.1. Simple Memory Store</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10815">8.5. 本章总结</a></span></dt></dl></dd></dl></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.resource"><!--anchor webx.resource--></a>第 5 章 Resource Loading服务指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2690">5.1. 资源概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2693">5.1.1. 什么是资源？</a></span></dt><dt><span class="section"><a href="#d0e2738">5.1.2. 如何表示资源？</a></span></dt><dt><span class="section"><a href="#d0e2867">5.1.3. 如何访问资源？</a></span></dt><dt><span class="section"><a href="#d0e2932">5.1.4. 如何遍历资源？</a></span></dt><dt><span class="section"><a href="#d0e2970">5.1.5. 有什么问题？</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3004">5.2. Spring的<code class="code">ResourceLoader</code>机制</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3015">5.2.1. <code class="code">Resource</code>接口</a></span></dt><dt><span class="section"><a href="#d0e3064">5.2.2. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</a></span></dt><dt><span class="section"><a href="#d0e3091">5.2.3. 在代码中取得资源</a></span></dt><dt><span class="section"><a href="#d0e3210">5.2.4. Spring如何装载资源？</a></span></dt><dt><span class="section"><a href="#d0e3390">5.2.5. Spring <code class="code">ResourceLoader</code>的缺点</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3457">5.3. Resource Loading服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3460">5.3.1. 替换Spring <code class="code">ResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.define.newres">5.3.2. 定义新资源</a></span></dt><dt><span class="section"><a href="#webx.resource.rename.res">5.3.3. 重命名资源</a></span></dt><dt><span class="section"><a href="#webx.resource.redirect.res">5.3.4. 重定向资源</a></span></dt><dt><span class="section"><a href="#webx.resource.matching">5.3.5. 匹配资源</a></span></dt><dt><span class="section"><a href="#webx.resource.multi.loaders">5.3.6. 在多个<code class="code">ResourceLoader</code>中查找</a></span></dt><dt><span class="section"><a href="#webx.resource.load.parent">5.3.7. 装载parent容器中的资源</a></span></dt><dt><span class="section"><a href="#webx.resource.modify.res">5.3.8. 修改资源文件的内容</a></span></dt><dt><span class="section"><a href="#webx.resource.using.service">5.3.9. 直接使用<code class="code">ResourceLoadingService</code></a></span></dt><dt><span class="section"><a href="#webx.resource.using.service.nonweb">5.3.10. 在非Web环境中使用Resource Loading服务</a></span></dt></dl></dd><dt><span class="section"><a href="#webx.resource.loaders">5.4. ResourceLoader参考</a></span></dt><dd><dl><dt><span class="section"><a href="#webx.resource.loader.file">5.4.1. <code class="code">FileResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.webapp">5.4.2. <code class="code">WebappResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.classpath">5.4.3. <code class="code">ClasspathResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.super">5.4.4. <code class="code">SuperResourceLoader</code></a></span></dt><dt><span class="section"><a href="#webx.resource.loader.other">5.4.5. 关于<code class="code">ResourceLoader</code>的其它考虑</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4876">5.5. 本章总结</a></span></dt></dl></div><p>Webx框架中，包含了一套用来查找和装载资源的服务 —— Resource Loading服务。</p><p>Resource Loading服务从Spring
        <code class="code">ResourceLoader</code>机制中扩展而来，并且和Spring框架融为一体。因此，你不需要写特别的Java代码，就可以让所有利用Spring
            <code class="code">ResourceLoader</code>机制的代码，直接享用Webx所提供的新的Resource Loading机制。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2690"><!--anchor d0e2690--></a>5.1. 资源概述</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2693"><!--anchor d0e2693--></a>5.1.1. 什么是资源？</h3></div></div></div><p>在一个稍具规模的应用程序中，经常要做的一件事，就是查找资源、读取资源的内容。这里所谓的“资源”，是指<span class="emphasis"><em>存放在某一介质中，可以被程序利用的文件、数据</em></span>。例如，基于Java的WEB应用中，常用到下面的资源：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>配置文件：<code class="filename">*.xml</code>、<code class="filename">*.properties</code>等。</p></li><li class="listitem"><p>Java类文件：<code class="filename">*.class</code>。</p></li><li class="listitem"><p>JSP页面、Velocity模板文件：<code class="filename">*.jsp</code>、<code class="filename">*.vm</code>等。</p></li><li class="listitem"><p>图片、CSS、JavaScript文件：<code class="filename">*.jpg</code>、<code class="filename">*.css</code>、<code class="filename">*.js</code>等。
                        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2738"><!--anchor d0e2738--></a>5.1.2. 如何表示资源？</h3></div></div></div><p>在Java中，有多种形式可以表示一个资源：</p><div class="table"><a id="d0e2743"><!--anchor d0e2743--></a><p class="title"><strong>表 5.1. 资源的表示</strong></p><div class="table-contents"><table summary="资源的表示" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c1"/><col width="80%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">可表示资源的对象</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">java.io.​File</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>可代表文件系统中的文件或目录。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>文件系统中的文件：“<code class="filename">c:\config.sys</code>”。</p></li><li class="listitem"><p>文件系统中的目录：“<code class="filename">c:\windows\</code>”。
                                            </p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">java.net.​URL</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>统一资源定位符。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>文件系统中的文件：<code class="filename">c:\config.sys</code>，可以表示成URL：“<code class="code">file:///c:/config.sys</code>”。</p></li><li class="listitem"><p>文件系统中的目录：<code class="filename">c:\windows\</code>，可以表示成URL：“<code class="code">file:///c:/windows/</code>”。</p></li><li class="listitem"><p>远程WEB服务器上的文件：“<code class="code">http://www.springframework.org/schema/beans.xml</code>”。</p></li><li class="listitem"><p>Jar包中的某个文件，可以表示成URL：“<code class="code">jar:file:///c:/my.jar!/my/file.txt</code>”。
                                            </p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">java.io.​InputStream</code></td><td style="" valign="middle">
                                <p>输入流对象，可用来直接访问资源的内容。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>文件系统中的文件：<code class="filename">c:\config.sys</code>，可以用下面的代码来转换成输入流：</p><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">new</strong> FileInputStream(<strong class="hl-string"><em style="color:navy">"c:\\config.sys"</em></strong>);</pre></li><li class="listitem"><p>远程WEB服务器上的文件，可以用下面的代码来转换成输入流：</p><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">new</strong> URL(<strong class="hl-string"><em style="color:navy">"http://www.springframework.org/schema/beans.xml"</em></strong>)​.openStream();</pre></li><li class="listitem"><p>Jar包中的某个文件，可以用下面的代码来转换成输入流： </p><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">new</strong> URL(<strong class="hl-string"><em style="color:navy">"jar:file:///c:/my.jar!/my/file.txt"</em></strong>)​.openStream();</pre></li></ul></div>
                            </td></tr></tbody></table></div></div><p>然而，并不是所有的资源，都可以表现成上述所有的形式。比如，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Windows文件系统中的目录，无法表现为输入流。</p></li><li class="listitem"><p>而远程WEB服务器上的文件无法转换成<code class="code">File</code>对象。</p></li><li class="listitem"><p>多数资源都可以表现成<code class="code">URL</code>形式。但也有例外，例如，如果把数据库中的数据看作资源，那么一般来说这种资源无法表示成<code class="code">URL</code>。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2867"><!--anchor d0e2867--></a>5.1.3. 如何访问资源？</h3></div></div></div><p>不同类型的资源，需要用不同的方法来访问。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">访问CLASSPATH中的资源</span></dt><dd><p>将资源放在CLASSPATH是最简单的做法。我们只要把所需的资源文件打包到Jar文件中，或是在运行java时，用<code class="code">-classpath</code>参数中指定的路径中。接下来我们就可以用下面的代码来访问这些资源：</p><div class="example"><a id="d0e2882"><!--anchor d0e2882--></a><p class="title"><strong>例 5.1. 访问CLASSPATH中的资源</strong></p><div class="example-contents"><pre class="programlisting">URL resourceURL = getClassLoader().getResource(<strong class="hl-string"><em style="color:navy">"java/lang/String.class"</em></strong>); <em class="hl-comment" style="color: green">// 取得URL</em>
InputStream resourceContent = getClassLoader().getResourceAsStream(<strong class="hl-string"><em style="color:navy">"java/lang/String.class"</em></strong>); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问文件系统中的资源</span></dt><dd><p>下面的代码从文件资源中读取信息：</p><div class="example"><a id="d0e2893"><!--anchor d0e2893--></a><p class="title"><strong>例 5.2. 访问文件系统中的资源</strong></p><div class="example-contents"><pre class="programlisting">File resourceFile = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"c:\\test.txt"</em></strong>); <em class="hl-comment" style="color: green">// 取得File</em>
InputStream resourceContent = <strong class="hl-keyword" style="color: maroon">new</strong> FileInputStream(resourceFile); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问Web应用中的资源</span></dt><dd><p>Web应用既可以打包成war文件，也可以展开到任意目录中。因此Web应用中的资源（JSP、模板、图片、Java类、配置文件）不总是可以用文件的方式存取。虽然Servlet
                                API提供了<code class="code">ServletContext.getRealPath()</code>方法，用来取得某个资源的实际文件路径，但该方法很可能返回<code class="code">null</code>
                            —— 这取决于应用服务器的实现，以及Web应用的部署方式。更好的获取WEB应用资源的方法如下：</p><div class="example"><a id="d0e2910"><!--anchor d0e2910--></a><p class="title"><strong>例 5.3. 访问Web应用中的资源</strong></p><div class="example-contents"><pre class="programlisting">URL resourceURL = servletContext.getResource(<strong class="hl-string"><em style="color:navy">"/WEB-INF/web.xml"</em></strong>); <em class="hl-comment" style="color: green">// 取得URL</em>
InputStream resourceContent = servletContext.getResourceAsStream(<strong class="hl-string"><em style="color:navy">"/WEB-INF/web.xml"</em></strong>); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问Jar/Zip文件中的资源</span></dt><dd><p>下面的代码读取被打包在Jar文件中的资源信息：</p><div class="example"><a id="d0e2921"><!--anchor d0e2921--></a><p class="title"><strong>例 5.4. 访问Jar/Zip文件中的资源</strong></p><div class="example-contents"><pre class="programlisting">URL jarURL = <strong class="hl-keyword" style="color: maroon">new</strong> File(System.getProperty(<strong class="hl-string"><em style="color:navy">"java.home"</em></strong>) + <strong class="hl-string"><em style="color:navy">"/lib/rt.jar"</em></strong>).toURI().toURL();
URL resourceURL = <strong class="hl-keyword" style="color: maroon">new</strong> URL(<strong class="hl-string"><em style="color:navy">"jar:"</em></strong> + jarURL + <strong class="hl-string"><em style="color:navy">"!/java/lang/String.class"</em></strong>); <em class="hl-comment" style="color: green">// 取得URL</em>
InputStream resourceContent = resourceURL.openStream(); <em class="hl-comment" style="color: green">// 取得输入流</em></pre></div></div></dd><dt><span class="term">访问其它资源</span></dt><dd><p>还可以想到一些访问资源的方法，例如从数据库中取得资源数据。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2932"><!--anchor d0e2932--></a>5.1.4. 如何遍历资源？</h3></div></div></div><p>有时候，我们不知道资源的路径，但希望能找出所有符合条件的资源，这个操作叫作遍历。例如，找出所有符合pattern
                    “<code class="code">/WEB-INF/webx-*.xml</code>”的配置文件。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">遍历文件系统</span></dt><dd><div class="example"><a id="d0e2945"><!--anchor d0e2945--></a><p class="title"><strong>例 5.5. 遍历文件系统</strong></p><div class="example-contents"><pre class="programlisting">File parentResource = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"c:\\windows"</em></strong>);
File[] subResources = parentResource.listFiles();</pre></div></div></dd><dt><span class="term">遍历WEB应用中的资源</span></dt><dd><div class="example"><a id="d0e2954"><!--anchor d0e2954--></a><p class="title"><strong>例 5.6. 遍历WEB应用中的资源</strong></p><div class="example-contents"><pre class="programlisting">Set&lt;String&gt; subResources = servletContext.getResourcePaths(<strong class="hl-string"><em style="color:navy">"/WEB-INF/"</em></strong>);</pre></div></div></dd><dt><span class="term">遍历Jar/zip文件中的资源</span></dt><dd><div class="example"><a id="d0e2963"><!--anchor d0e2963--></a><p class="title"><strong>例 5.7. 遍历Jar/zip文件中的资源</strong></p><div class="example-contents"><pre class="programlisting">File jar = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"myfile.jar"</em></strong>);
ZipInputStream zis = <strong class="hl-keyword" style="color: maroon">new</strong> ZipInputStream(<strong class="hl-keyword" style="color: maroon">new</strong> FileInputStream(jar));

<strong class="hl-keyword" style="color: maroon">try</strong> {
    <strong class="hl-keyword" style="color: maroon">for</strong> (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {
        <em class="hl-comment" style="color: green">// visit entry</em>
    }
} <strong class="hl-keyword" style="color: maroon">finally</strong> {
    zis.close();
}</pre></div></div></dd></dl></div><p>并非所有类型的资源都支持遍历操作。通常遍历操作会涉及比较复杂的递归算法。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2970"><!--anchor d0e2970--></a>5.1.5. 有什么问题？</h3></div></div></div><p>应用程序访问资源时，有什么问题呢？</p><p>首先，资源表现形式的多样性，给应用程序的接口设计带来一点麻烦。假如，我写一个<code class="code">ConfigReader</code>类，用来读各种配置文件。那么我可能需要在接口中列出所有的资源的形式：</p><div class="example"><a id="d0e2980"><!--anchor d0e2980--></a><p class="title"><strong>例 5.8. 用来读取配置文件的接口</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> ConfigReader {
    Object readConfig(File configFile);
    Object readConfig(URL configURL);
    Object readConfig(InputStream configStream);
}</pre></div></div><p>特别是当一个通用的框架，如Spring和Webx，需要在对象之间传递各种形式的资源的时候，这种多样性将导致很大的编程困难。</p><p>其次，有这么多种查找资源和遍历资源的方法，使我们的应用程序和资源所在的环境高度耦合。这种耦合会妨碍代码的可移植性和可测试性。</p><p>比如，我希望在非WEB的环境下测试一个模块，但这个模块因为要存取Web应用下的资源，而引用了<code class="code">ServletContext</code>对象。在测试环境中并不存在<code class="code">ServletContext</code>而导致该模块难以被测试。再比如，我希望测试的一个模块，引用了classpath下的某个配置文件（这也是一种耦合）。而我希望用另一个专为该测试打造的配置文件来代替这个文件。由于原配置文件是在classpath中，因此是难以替换的。</p><p>对于不打算重用的应用程序来说，这个问题还不太严重：大不了我预先设定好，就从这个地方，以固定的方式存取资源。然而就算这样，也是挺麻烦的。有的人喜欢把资源放在某个子目录下，有的人喜欢把资源放在CLASSPATH下，又有人总是通过<code class="code">ServletContext</code>来存取Web应用下的资源。当你要把这些不同人写的模块整合起来时，你会发现很难管理。</p><p>一种可能发生的情形是，因为某些原因，环境发生改变，导致资源的位置、存取方式不得不跟着改变。比如将老系统升级为新系统。但一些不得不继续使用的老代码，由于引用了旧环境的资源而不能工作
                ——
                除非你去修改这些代码。有时修改老代码是很危险的，可能导致不可预知的错误。又比如，由于存储硬件的改变或管理的需要，我们需要将部分资源移到另一个地方（我们曾经将Web页面模板中的某个子目录，移动到一个新的地方，因为这些模板必须由新的CMS系统自动生成）。想要不影响现有代码来完成这些事，是很困难的。
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e3004"><!--anchor d0e3004--></a>5.2. Spring的<code class="code">ResourceLoader</code>机制</h2></div></div></div><p>Spring内置了一套<code class="code">ResourceLoader</code>机制，很好地解决了访问资源的大部分问题。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3015"><!--anchor d0e3015--></a>5.2.1. <code class="code">Resource</code>接口</h3></div></div></div><p>Spring将所有形式的资源表现概括成一个<code class="code">Resource</code>接口。如下所示（下面的接口定义是被简化的，有意省略了一些东西，以便突出重点）：</p><div class="example"><a id="d0e3025"><!--anchor d0e3025--></a><p class="title"><strong>例 5.9. Spring的<code class="code">Resource</code>接口（简化）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> Resource {
    InputStream getInputStream();
    URL getURL();
    File getFile();
    <strong class="hl-keyword" style="color: maroon">boolean</strong> exists();
}</pre></div></div><p><code class="code">Resource</code>接口向应用程序屏蔽了资源表现形式的多样性。于是，前面例子中的<code class="code">ConfigReader</code>就可以被简化成下面的样子：</p><div class="example"><a id="d0e3040"><!--anchor d0e3040--></a><p class="title"><strong>例 5.10. 用来读取配置文件的接口（简化后）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> ConfigReader {
    Object readConfig(Resource configResource);
}</pre></div></div><p>事实上，Spring正是利用<code class="code">Resource</code>接口来初始化它的<code class="code">ApplicationContext</code>的：</p><div class="example"><a id="d0e3053"><!--anchor d0e3053--></a><p class="title"><strong>例 5.11. Spring用<code class="code">Resource</code>接口来代表用来初始化<code class="code">ApplicationContext</code>的配置文件</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">abstract</strong> <strong class="hl-keyword" style="color: maroon">class</strong> AbstractXmlApplicationContext <strong class="hl-keyword" style="color: maroon">extends</strong> ... {
    ...
    <strong class="hl-keyword" style="color: maroon">protected</strong> <strong class="hl-keyword" style="color: maroon">void</strong> loadBeanDefinitions(XmlBeanDefinitionReader reader) {
        Resource[] configResources = getConfigResources();
        ...
    }

    <strong class="hl-keyword" style="color: maroon">protected</strong> Resource[] getConfigResources();
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3064"><!--anchor d0e3064--></a>5.2.2. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</h3></div></div></div><p>Spring不仅可以通过<code class="code">ResourceLoader</code>接口来取得单一的资源对象，还可以通过<code class="code">ResourcePatternResolver</code>遍历并取得多个符合指定pattern的资源对象。这个设计向应用程序屏蔽了查找和遍历资源的复杂性。</p><div class="figure"><a id="d0e3080"><!--anchor d0e3080--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/spring-interfaces.png" alt="ResourceLoader和ResourcePatternResolver接口"/></div></div><p class="title"><strong>图 5.1. <code class="code">ResourceLoader</code>和<code class="code">ResourcePatternResolver</code>接口</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3091"><!--anchor d0e3091--></a>5.2.3. 在代码中取得资源</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3094"><!--anchor d0e3094--></a>5.2.3.1. 通过<code class="code">ResourceLoader</code>取得资源</h4></div></div></div><div class="example"><a id="d0e3100"><!--anchor d0e3100--></a><p class="title"><strong>例 5.12. 通过<code class="code">ResourceLoader</code>取得资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyBean <strong class="hl-keyword" style="color: maroon">implements</strong> ResourceLoaderAware <a id="co.rl.aware"><!--anchor co.rl.aware--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> {
    <strong class="hl-keyword" style="color: maroon">private</strong> ResourceLoader loader;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setResourceLoader(ResourceLoader loader) <a id="co.rl.aware2"><!--anchor co.rl.aware2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> {
        <strong class="hl-keyword" style="color: maroon">this</strong>.loader = loader;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> func() {
        Resource resource = loader.getResource(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>); <a id="co.rl.aware.getres"><!--anchor co.rl.aware.getres--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        ...
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.aware"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.rl.aware2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>实现了<code class="code">ResourceLoaderAware</code>接口。要取得资源，必须要拿到<code class="code">ResourceLoader</code>对象。而通过<code class="code">ResourceLoaderAware</code>接口拿到<code class="code">ResourceLoader</code>是最简单的方法。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.aware.getres"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>调用所取得的<code class="code">ResourceLoader</code>来取得资源。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3136"><!--anchor d0e3136--></a>5.2.3.2. 直接注入资源</h4></div></div></div><p>另一种更简便的方法是，将资源直接“注入”到bean中 ——
                    你不需要手工调用<code class="code">ResourceLoader</code>来取得资源的方式来设置资源。例如：</p><div class="example"><a id="d0e3144"><!--anchor d0e3144--></a><p class="title"><strong>例 5.13. 直接注入资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyBean {
    <strong class="hl-keyword" style="color: maroon">private</strong> URL resource;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setLocation(URL resource) <a id="co.rl.inject.url"><!--anchor co.rl.inject.url--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> {
        <strong class="hl-keyword" style="color: maroon">this</strong>.resource = resource;
    }

    ……
}</pre><p>Spring配置文件可以这样写：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"myBean"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"MyBean"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"location"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"myFile.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.inject.url"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处注入资源的URL</p></td></tr></table></div></div></div><p>这样，Spring就会把适当的<code class="filename">myFile.xml</code>所对应的资源注入到<code class="code">myBean</code>对象中。此外，Spring会自动把<code class="code">Resource</code>对象转换成<code class="code">URL</code>、<code class="code">File</code>等普通对象。在上面的例子中，<code class="code">MyBean</code>并不依赖于<code class="code">Resource</code>接口，只依赖于<code class="code">URL</code>类。</p><p>将代码稍作修改，就可以注入一组资源：</p><div class="example"><a id="d0e3187"><!--anchor d0e3187--></a><p class="title"><strong>例 5.14. 注入一组资源</strong></p><div class="example-contents"><pre class="programlisting">    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setLocations(URL[] resources) <a id="co.rl.inject.urls"><!--anchor co.rl.inject.urls--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> {
        <strong class="hl-keyword" style="color: maroon">this</strong>.resources = resources;
    }</pre><p>配置文件：</p><pre class="programlisting">    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"locations"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"WEB-INF/webx-*.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.inject.urls"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处注入资源的URL的数组。</p></td></tr></table></div></div></div><p>上例中，可以直接得到所有符合pattern
                        “<code class="code">WEB-INF/webx-*.xml</code>”的配置文件。显然这是通过<code class="code">ResourcePatternResolver</code>取得的。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3210"><!--anchor d0e3210--></a>5.2.4. Spring如何装载资源？</h3></div></div></div><p>Spring是如何装载资源文件的呢？Spring装载资源的方案是由<code class="code">ApplicationContext</code>决定的。不同的<code class="code">ApplicationContext</code>类，实现了不同的资源装载方案。</p><div class="figure"><a id="d0e3221"><!--anchor d0e3221--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/spring-rl-impl.png" alt="Spring ApplicationContext实现了资源装载的具体方案"/></div></div><p class="title"><strong>图 5.2. Spring <code class="code">ApplicationContext</code>实现了资源装载的具体方案</strong></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3230"><!--anchor d0e3230--></a>5.2.4.1. <code class="code">ClassPathXmlApplicationContext</code></h4></div></div></div><p><code class="code">ClassPathXmlApplicationContext</code>支持从classpath中装载资源。</p><div class="example"><a id="d0e3238"><!--anchor d0e3238--></a><p class="title"><strong>例 5.15. <code class="code">ClassPathXmlApplicationContext</code> - 从classpath中装载资源</strong></p><div class="example-contents"><p>假如我以下面的方式启动Spring，那么系统将支持从<span class="emphasis"><em>classpath中</em></span>装载资源。</p><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> ClassPathXmlApplicationContext(<strong class="hl-string"><em style="color:navy">"beans.xml"</em></strong>);</pre><p><code class="code">ClassPathXmlApplicationContext</code>装载资源文件<code class="filename">myFile.xml</code>的逻辑，相当于如下代码：</p><pre class="programlisting">URL resource = getClassLoader().getResource(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3259"><!--anchor d0e3259--></a>5.2.4.2. <code class="code">FileSystemXmlApplicationContext</code></h4></div></div></div><p><code class="code">FileSystemXmlApplicationContext</code>支持从文件系统中装载资源。</p><div class="example"><a id="d0e3267"><!--anchor d0e3267--></a><p class="title"><strong>例 5.16. <code class="code">FileSystemXmlApplicationContext</code> - 从文件系统中装载资源</strong></p><div class="example-contents"><p>假如我以下面的方式启动Spring，那么系统将支持从<span class="emphasis"><em>文件系统中</em></span>装载资源。</p><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> FileSystemXmlApplicationContext(<strong class="hl-string"><em style="color:navy">"beans.xml"</em></strong>);</pre><p><code class="code">FileSystemXmlApplicationContext</code>装载资源文件<code class="filename">myFile.xml</code>的逻辑，相当于如下代码：</p><pre class="programlisting">File resource = <strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3288"><!--anchor d0e3288--></a>5.2.4.3. <code class="code">XmlWebApplicationContext</code></h4></div></div></div><p><code class="code">XmlWebApplicationContext</code>支持从webapp上下文中（也就是<code class="code">ServletContext</code>对象中）装载资源。</p><div class="example"><a id="d0e3299"><!--anchor d0e3299--></a><p class="title"><strong>例 5.17. <code class="code">XmlWebApplicationContext</code> - 从Web应用的根目录中装载资源</strong></p><div class="example-contents"><p>假如我以下面的方式启动Spring，那么系统将支持从<span class="emphasis"><em>Web应用的根目录中</em></span>装载资源。</p><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> XmlWebApplicationContext();

context.setConfigLocation(<strong class="hl-string"><em style="color:navy">"/WEB-INF/beans.xml"</em></strong>);
context.setServletContext(servletContext);
context.refresh();</pre><p>也可以让<code class="code">ContextLoaderListener</code>来创建<code class="code">XmlWebApplicationContext</code>，只需要在<code class="filename">/WEB-INF/web.xml</code>中添加如下配置：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>contextConfigLocation<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>/WEB-INF/beans.xml<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong>org.springframework.web.context.ContextLoaderListener<strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong></pre><p><code class="code">XmlWebApplicationContext</code>装载资源文件<code class="filename">myFile.xml</code>的逻辑，相当于如下代码：</p><pre class="programlisting">URL resource = servletContext.getResource(<strong class="hl-string"><em style="color:navy">"myFile.xml"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3333"><!--anchor d0e3333--></a>5.2.4.4. <code class="code">Classpath</code>和<code class="code">Classpath*</code>前缀</h4></div></div></div><p>除了用<code class="code">ClassPathXmlApplicationContext</code>以外，事实上所有的Spring
                        <code class="code">ApplicationContext</code>实现也都支持装载classpath中的资源。可以用下面两种方法：</p><div class="table"><a id="d0e3349"><!--anchor d0e3349--></a><p class="title"><strong>表 5.2. Spring <code class="code">ApplicationContext</code>装载classpath资源的方法</strong></p><div class="table-contents"><table summary="Spring ApplicationContext装载classpath资源的方法" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="74%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">方法</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">使用<code class="code">classpath:</code>前缀</td><td style="border-bottom: 0.5pt solid #6666cc; ">例如：“<code class="code">classpath:myFile.xml</code>” ——
                                        在classpath中装载资源<code class="code">myFile.xml</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">使用<code class="code">classpath*:</code>前缀</td><td style="">例如：“<code class="code">classpath*:/META-INF/my*.xml</code>” ——
                                    在classpath中装载所有符合pattern的资源。</td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3390"><!--anchor d0e3390--></a>5.2.5. Spring <code class="code">ResourceLoader</code>的缺点</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">鱼和熊掌不可得兼</span></dt><dd><p>Spring
                                <code class="code">ResourceLoader</code>是由<code class="code">ApplicationContext</code>来实现的。而你一次只能选择一种<code class="code">ApplicationContext</code>的实现
                            ——
                                如果你选择了<code class="code">XmlWebApplicationContext</code>，你就放弃了<code class="code">FileSystemXmlApplicationContext</code>；反之亦然。</p><p>在WEB应用中，由于Spring使用了<code class="code">XmlWebApplicationContext</code>，因此你就无法装载文件系统下的资源。</p></dd><dt><span class="term">不透明性</span></dt><dd><p>你必须用“绝对路径”来引用Spring中的资源。</p><p>假如你使用<code class="code">FileSystemXmlApplicationContext</code>来访问资源，你必须使用绝对路径来访问文件或目录资源。这妨碍了应用程序在不同系统中部署的自由。因为在不同的系统中，例如Windows和Linux，文件的绝对路径是不同的。为了系统管理的需要，有时也需要将文件或目录放在不同于开发环境的地方。</p><p>即便是访问WEB应用下的资源，或者是classpath下的资源，你也必须明确指出它们的位置，例如：<code class="code">WEB-INF/myFile.xml</code>、<code class="code">classpath:myFile.xml</code>等。如果我希望把<code class="code">classpath:myFile.xml</code>挪到另一个物理位置，就必须修改所有的引用。</p></dd><dt><span class="term">无扩展性</span></dt><dd><p>我无法在Spring
                                <code class="code">ResourceLoader</code>机制中增加一种新的装载资源的方法。例如，我希望把资源文件保存在数据库中，并用<code class="code">ResourceLoader</code>来取得它。用Spring很难做到这点。</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e3457"><!--anchor d0e3457--></a>5.3. Resource Loading服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3460"><!--anchor d0e3460--></a>5.3.1. 替换Spring <code class="code">ResourceLoader</code></h3></div></div></div><p>Webx Resource Loading服务可作为Spring <code class="code">ResourceLoader</code>机制的替代品（Drop-in Replacement，投入既替换）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>当你不使用它时，Spring原有的<code class="code">ResourceLoader</code>功能不受影响；</p></li><li class="listitem"><p>当你在spring配置文件中添加Resource
                            Loading服务时，<code class="code">ResourceLoader</code>即被切换到新的机制。新的机制可兼容原有的Spring配置和代码，但支持更多的资源装载方式，以及更多的功能，如资源重命名、资源重定向等。</p></li></ul></div><p>你只需要在配置文件中增加以下内容，就可以将Spring <code class="code">ResourceLoader</code>机制替换成Webx的Resource
                Loading服务：</p><div class="example"><a id="d0e3488"><!--anchor d0e3488--></a><p class="title"><strong>例 5.18. Resource Loading服务的基本配置（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.basic.alias.root"><!--anchor co.rl.basic.alias.root--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.basic.def.webroot"><!--anchor co.rl.basic.def.webroot--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong> <a id="co.rl.basic.webroot"><!--anchor co.rl.basic.webroot--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/classpath"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.basic.def.classpath"><!--anchor co.rl.basic.def.classpath--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong> <a id="co.rl.basic.classpath"><!--anchor co.rl.basic.classpath--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/ resource-loading&gt;</strong></pre><div class="calloutlist"><p>关于这段配置的具体含义，请参见本章其它小节：</p><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.alias.root"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="#webx.resource.rename.res" title="5.3.3. 重命名资源">第 5.3.3 节 “重命名资源”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.def.webroot"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.rl.basic.def.classpath"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="#webx.resource.define.newres" title="5.3.2. 定义新资源">第 5.3.2 节 “定义新资源”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.webroot"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="#webx.resource.loader.webapp" title="5.4.2. WebappResourceLoader">第 5.4.2 节 “<code class="code">WebappResourceLoader</code>”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.basic.classpath"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请参见：<a class="xref" href="#webx.resource.loader.classpath" title="5.4.3. ClasspathResourceLoader">第 5.4.3 节 “<code class="code">ClasspathResourceLoader</code>”</a>。</p></td></tr></table></div></div></div><p>这段配置使得Resource Loading服务的行为和原来的Spring <code class="code">ResourceLoader</code>完全兼容：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>仍然支持<code class="code">classpath:</code>和<code class="code">classpath*:</code>前缀所定义的资源。</p></li><li class="listitem"><p>如不加前缀，则代表访问WEB应用根目录下的文件。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="filename">/myFile.xml</code>代表着Web应用根目录下的<code class="filename">/myFile.xml</code>。</p></li><li class="listitem"><p><code class="filename">/WEB-INF/myFile.xml</code>代表着Web应用根目录下的<code class="filename">/WEB-INF/myFile.xml</code>。</p></li></ul></div></li></ul></div><p>加上这段配置以后，虽然功能和原来相比并没有变化，然而它已经准备好向系统中添加新的资源装载的功能了。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.define.newres"><!--anchor webx.resource.define.newres--></a>5.3.2. 定义新资源</h3></div></div></div><p>定义一种新资源，需要回答两个问题：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>资源的名称是什么？</p></li><li class="listitem"><p>资源在哪里（或如何装载资源）？</p></li></ol></div><p>下面的例子定义了一种新的资源，它的名称是“<code class="code">/jdk/*</code>”，通过“<code class="code">file-loader</code>”从文件系统<code class="code">${java.home}</code>文件夹中装载。</p><div class="example"><a id="d0e3589"><!--anchor d0e3589--></a><p class="title"><strong>例 5.19. 定义新资源：<code class="code">/jdk/*</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/jdk"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.define.res.jdk"><!--anchor co.rl.define.res.jdk--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${java.home}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.loader.file"><!--anchor co.rl.loader.file--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.define.res.jdk"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义新资源，资源名以<code class="code">/jdk</code>为前缀。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.loader.file"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;file-loader&gt;</code>表示从文件系统中装载资源。详见：<a class="xref" href="#webx.resource.loader.file" title="5.4.1. FileResourceLoader">第 5.4.1 节 “<code class="code">FileResourceLoader</code>”</a>。</p><p><code class="code">${java.home}</code>是Java提供的system
                            property，它的值指向当前Java运行环境的根目录。</p></td></tr></table></div></div></div><p>前文讲过，Spring可以直接把资源注入到对象中。使用Resource
                    Loading服务以后，你仍然可以这样做。下面的配置把JDK目录下的<code class="code">tools.jar</code>文件（如果存在的话）的URL注入到<code class="code">myBean</code>中：</p><div class="example"><a id="d0e3626"><!--anchor d0e3626--></a><p class="title"><strong>例 5.20. 注入<code class="code">JAVA_HOME/lib/tools.jar</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"myBean"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"MyBean"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"location"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"/jdk/lib/tools.jar"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.rename.res"><!--anchor webx.resource.rename.res--></a>5.3.3. 重命名资源</h3></div></div></div><p>重命名资源是指对于即有的资源，改变其名字。</p><p>为什么需要修改资源的名字？理由是：<span class="emphasis"><em>取消资源名称和环境的关联性</em></span>。有一些资源的名称，具有明显的环境相关性，比如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">classpath:myFile.xml</code>或者<code class="code">/classpath/myFile.xml</code>
                            —— 从资源的名称就可以看出，这些资源是从classpath中装载的。</p></li><li class="listitem"><p><code class="code">/WEB-INF/myFile.xml</code>或者<code class="code">/webroot/WEB-INF/myFile.xml</code>
                            —— 从资源的名称可以看出，这些资源是从web应用中装载的。</p></li></ul></div><p>使用和环境相关的资源名称有什么问题？问题就是，当环境改变时，应用代码会受到影响。最常见的一种状况是：单元测试时，用于测试的资源文件往往被放在专供测试的目录中，这些目录和应用运行时的环境是不同的
                ——
                    你可能希望将<code class="code">classpath:myFile.xml</code>或<code class="code">/WEB-INF/myFile.xml</code>改成<code class="code">/src/test/config/myFile.xml</code>。</p><p>对资源重命名就可以解决这类问题：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>将<code class="code">classpath:myFile.xml</code>或者<code class="code">/WEB-INF/myFile.xml</code>重命名成：<code class="code">myapp/conf/myFile.xml</code>。</p></li><li class="listitem"><p>在测试环境中，将<code class="code">myapp/conf/myFile.xml</code>名称指向另一个物理地址<code class="code">src/test/config/myFile.xml</code>。
                        </p></li></ul></div><p>重命名资源是通过alias别名实现的：</p><div class="example"><a id="d0e3697"><!--anchor d0e3697--></a><p class="title"><strong>例 5.21. 重命名资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.alias.conf"><!--anchor co.rl.alias.conf--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.res.webroot"><!--anchor co.rl.res.webroot--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong> <a id="co.rl.res.webroot.loader"><!--anchor co.rl.res.webroot.loader--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.alias.conf"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义了一个资源的别名：<code class="code">/myapp/conf</code>。</p><p>当你查找<code class="code">/myapp/conf/myFile.xml</code>时，Resource
                                Loading服务实际上会去找<code class="code">/webroot/WEB-INF/myFile.xml</code>。而<code class="code">/webroot/*</code>则是由
                                <a id="co.rl.res.webroot"><!--anchor co.rl.res.webroot--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> 所定义的资源。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.res.webroot"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义以<code class="code">/webroot</code>为前缀的新资源。</p><p>其中，attribute
                                <span class="emphasis"><em><code class="code">internal=true</code></em></span>是一个可选项，当它的值为<code class="code">true</code>时，代表它所修饰的资源是不能被外界所直接访问的。例如，你想直接在<code class="code">myBean</code>中注入<code class="code">/webroot/WEB-INF/myFile.xml</code>是不行的。把<code class="code">internal</code>选项设成<code class="code">true</code>，可以让强制用户转向新的资源名称。<code class="code">Internal</code>参数的默认值为<code class="code">false</code>，意味着，新旧两种名称同时可用。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.res.webroot.loader"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;webapp-loader&gt;</code>表示从Web应用中装载资源。详见：<a class="xref" href="#webx.resource.loader.webapp" title="5.4.2. WebappResourceLoader">第 5.4.2 节 “<code class="code">WebappResourceLoader</code>”</a>。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.redirect.res"><!--anchor webx.resource.redirect.res--></a>5.3.4. 重定向资源</h3></div></div></div><p>重定向资源的意思是，将部分资源名称，指向另外的地址。</p><p>一个常见的需求是这样的：通常我们会把页面模板保存在WEB应用的<code class="code">/templates</code>目录下。但是有一批模板是由外部的CMS系统生成的，这些模板文件不可能和WEB应用打包在一起，而是存放在某个外部的目录下的。我们希望用<code class="code">/templates/cms</code>来引用这些模板。</p><p>由于<code class="code">/templates/cms</code>只不过是<code class="code">/templates</code>的子目录，所以如果没有Resource
                Loading服务所提供的重定向功能，是不可能实现上述功能的。用Resource Loading服务重定向的配置如下：</p><div class="example"><a id="d0e3789"><!--anchor d0e3789--></a><p class="title"><strong>例 5.22. 重定向资源</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/templates"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/templates"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.alias.templates"><!--anchor co.rl.alias.templates--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/templates/cms"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.define.templates.cms"><!--anchor co.rl.define.templates.cms--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${cms_root}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    ...
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.alias.templates"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义了一个资源的别名：<code class="code">/templates</code>，指向internal资源：<code class="code">/webroot/templates</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.define.templates.cms"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将<code class="code">/templates</code>的子目录<code class="code">/templates/cms</code>重定向到某个外部的文件目录<code class="code">${cms_root}</code>中。</p><p>其中<code class="code">cms_root</code>是启动服务器时所指定的system
                                property（<code class="code">-Dcms_root=...</code>）或者spring所定义的placeholder。</p></td></tr></table></div></div></div><p>通过上述配置，可以达到如下效果：</p><div class="table"><a id="d0e3830"><!--anchor d0e3830--></a><p class="title"><strong>表 5.3. 访问<code class="code">/templates</code>目录下的资源</strong></p><div class="table-contents"><table summary="访问/templates目录下的资源" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">资源名</th><th style="border-bottom: 0.5pt solid #6666cc; ">如何装载？</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">/templates/xxx.vm</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">不受重定向影响。访问<code class="code">/webroot/templates/xxx.vm</code>，继而通过<code class="code">webapp-loader</code>访问Web应用根目录下的<code class="filename">/templates/xxx.vm</code>文件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">/templates/cms/yyy.vm</code></td><td style="border-bottom: 0.5pt solid #6666cc; "><span class="emphasis"><em>被重定向</em></span>。通过<code class="code">file-loader</code>访问<code class="code">${cms_root}</code>目录下的文件：<code class="filename">${cms_root}/yyy.vm</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">/templates/subdir/zzz.vm</code></td><td style="">不受重定向影响。访问<code class="code">/webroot/templates/subdir/zzz.vm</code>，继而通过<code class="code">webapp-loader</code>访问Web应用根目录下的<code class="filename">/templates/subdir/zzz.vm</code>文件。</td></tr></tbody></table></div></div><p>最重要的是，<span class="emphasis"><em>访问<code class="code">/templates</code>目录的应用程序并不知道这个资源重定向的存在</em></span>，当cms所对应的实际目录被改变时，应用程序也不会受到任何影响
                —— 这个正是Resource Loading服务的“魔法”。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.matching"><!--anchor webx.resource.matching--></a>5.3.5. 匹配资源</h3></div></div></div><p>无论是定义新资源（<code class="code">&lt;resource&gt;</code>）或是重命名资源（资源别名、<code class="code">&lt;resource-alias&gt;</code>），都需要指定一个<code class="code">pattern</code>
                attribute来匹配资源的名称。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.resource.matching.type"><!--anchor webx.resource.matching.type--></a>5.3.5.1. 匹配绝对路径和相对路径</h4></div></div></div><p>资源或资源别名的pattern支持对绝对路径和相对路径的匹配：</p><div class="table"><a id="d0e3920"><!--anchor d0e3920--></a><p class="title"><strong>表 5.4. 资源或别名的<code class="code">pattern</code>格式</strong></p><div class="table-contents"><table summary="资源或别名的pattern格式" cellpadding="10" style="border: none;"><colgroup><col width="14%" class="c1"/><col width="20%" class="c2"/><col width="66%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">pattern类型</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">格式</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">匹配绝对路径</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p><code class="code">/absolute/path</code></p></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p><span class="emphasis"><em>以<code class="code">/</code>开头的pattern</em></span>代表一个绝对路径的匹配。</p>
                                    <p>例如：<code class="code">pattern="/absolute/path"</code>可以匹配资源名<code class="code">/abslute/path/xxx/yyy</code>，但不能匹配资源名<code class="code">/xxx/abslute/path/yyy</code>。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">匹配相对路径</td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">
                                    <p><code class="code">relative/path</code></p>
                                </td><td style="" valign="middle">
                                    <p><span class="emphasis"><em>不以<code class="code">/</code>开头的pattern</em></span>代表一个相对路径的匹配。</p>
                                    <p>例如：<code class="code">pattern="relative/path"</code>可以匹配资源名<code class="code">/relative/path/xxx/yyy</code>，也可以匹配资源名<code class="code">/xxx/relative/path/yyy</code>。</p>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.resource.matching.wildcard"><!--anchor webx.resource.matching.wildcard--></a>5.3.5.2. 匹配通配符</h4></div></div></div><div class="table"><a id="d0e4003"><!--anchor d0e4003--></a><p class="title"><strong>表 5.5. 通配符格式</strong></p><div class="table-contents"><table summary="通配符格式" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c2"/><col width="80%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">格式</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">星号 <code class="code">*</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">匹配0-n个字符，但不包括“<code class="code">/</code>”。即，“<code class="code">*</code>”只匹配一级目录或文件中的零个或多个字符。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">双星号 <code class="code">**</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">匹配0-n个字符，包括“<code class="code">/</code>”。即，“<code class="code">**</code>”匹配多级目录或文件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">问号 <code class="code">?</code></td><td style="" valign="middle">匹配0-1个字符，但不包括“<code class="code">/</code>”。即，“<code class="code">?</code>”匹配一级目录或文件中的零个或一个字符。</td></tr></tbody></table></div></div><p>所有被通配符匹配的内容，将被按顺序赋给变量“<code class="code">$1</code>”、“<code class="code">$2</code>”、“<code class="code">$3</code>”、“<code class="code">$4</code>”、……。这些变量可以在其它地方被引用。</p><p>通配符匹配的名称既可以是绝对路径，也可以是相对路径。把相对路径和通配符结合起来的最常见用法，就是匹配文件名后缀，例如：<code class="code">pattern="*.xml"</code>。</p><p>下面是一些使用通配符的例子：</p><div class="example"><a id="d0e4076"><!--anchor d0e4076--></a><p class="title"><strong>例 5.23. 用通配符来匹配资源名称或资源别名</strong></p><div class="example-contents"><div class="variablelist"><dl class="variablelist"><dt><span class="term">重命名<code class="code">WEB-INF</code>及其子目录下的所有的xml文件</span></dt><dd><p>例如，将<code class="code">/myapp/conf/my/file.xml</code>转换成<code class="code">/webroot/WEB-INF/my/file.xml</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf/**/*.xml"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF/$1/$2.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></dd><dt><span class="term">修改文件名后缀</span></dt><dd><p>例如，将<code class="code">/myapp/conf/myfile.conf</code>转换成<code class="code">/webroot/WEB-INF/myfile.xml</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf/*.conf"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/WEB-INF/$1.xml"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong></pre></dd><dt><span class="term">按首字母划分子目录</span></dt><dd><p>将<code class="code">a</code>开头的文件名放到<code class="code">a</code>子目录下，<code class="code">b</code>开头的文件名放到<code class="code">b</code>子目录下，以此类推。</p><p>例如，将<code class="code">/profiles/myname</code>转换成文件路径<code class="code">${profile_root}/m/myname</code>；将<code class="code">/profiles/othername</code>转换成文件路径<code class="code">${profile_root}/o/othername</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/profiles/?*"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${profile_root}"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:path&gt;</strong>$1/$1$2<strong class="hl-tag" style="color: #000096">&lt;/res-loaders:path&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/res-loaders:file-loader&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></dd></dl></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.multi.loaders"><!--anchor webx.resource.multi.loaders--></a>5.3.6. 在多个<code class="code">ResourceLoader</code>中查找</h3></div></div></div><p>假如，在我的Web应用中，我有一些配置文件放在<code class="code">/WEB-INF</code>目录中，另外一部分配置放在classpath中。我可以这样做：</p><div class="example"><a id="d0e4156"><!--anchor d0e4156--></a><p class="title"><strong>例 5.24. 在多个<code class="code">ResourceLoader</code>中查找</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.multi.loaders.1.webroot"><!--anchor co.rl.multi.loaders.1.webroot--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/classpath"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.multi.loaders.2.classpath"><!--anchor co.rl.multi.loaders.2.classpath--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/webroot"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.multi.loaders.define.webroot"><!--anchor co.rl.multi.loaders.define.webroot--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/classpath"</span> <span class="hl-attribute" style="color: #F5844C">internal</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.multi.loaders.define.classpath"><!--anchor co.rl.multi.loaders.define.classpath--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

    ...
<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.multi.loaders.1.webroot"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.rl.multi.loaders.2.classpath"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>依次尝试两个loaders。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.multi.loaders.define.webroot"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义internal资源<code class="code">/webroot/*</code>，从Web应用中装载资源。详见<a class="xref" href="#webx.resource.loader.webapp" title="5.4.2. WebappResourceLoader">第 5.4.2 节 “<code class="code">WebappResourceLoader</code>”</a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.multi.loaders.define.classpath"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义internal资源<code class="code">/classpath/*</code>，从classpath中装载资源。详见<a class="xref" href="#webx.resource.loader.classpath" title="5.4.3. ClasspathResourceLoader">第 5.4.3 节 “<code class="code">ClasspathResourceLoader</code>”</a>。</p></td></tr></table></div></div></div><p>Resource Loading服务根据上面的配置，会这样查找资源“<code class="code">/myapp/conf/myFile.xml</code>”：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>先查找：<code class="code">/webroot/WEB-INF/myFile.xml</code>，如果找不到，</p></li><li class="listitem"><p>则再查找：<code class="code">/classpath/myFile.xml</code>，如果找不到，则放弃。</p></li></ol></div><p>在上例中，<code class="code">&lt;super-loader&gt;</code>（详见<a class="xref" href="#webx.resource.loader.super" title="5.4.4. SuperResourceLoader">第 5.4.4 节 “<code class="code">SuperResourceLoader</code>”</a>）是一种特殊的<code class="code">ResourceLoader</code>，它等同于<code class="code">&lt;resource-alias&gt;</code>。下面的两种写法是完全等同的：</p><div class="example"><a id="d0e4223"><!--anchor d0e4223--></a><p class="title"><strong>例 5.25. <code class="code">&lt;super-loader&gt;</code>和等效的<code class="code">&lt;resource-alias&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;resource-alias</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/myapp/conf "</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"/webroot/WEB-INF"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>但是用<code class="code">&lt;resource-alias&gt;</code>没有办法实现上面所述的多重查找的功能。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.load.parent"><!--anchor webx.resource.load.parent--></a>5.3.7. 装载parent容器中的资源</h3></div></div></div><p>在Webx中，Spring容器被安排成级联的结构。</p><div class="figure"><a id="d0e4242"><!--anchor d0e4242--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/context-hierarchy.png" alt="Spring容器的级联结构"/></div></div><p class="title"><strong>图 5.3. Spring容器的级联结构</strong></p></div><p>如图所示，每个Spring容器都可以配置自己的Resource Loading服务。当调用子容器的Resource Loading服务时，遵循这样的逻辑：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>先在子容器的Resource Loading服务中查找资源，如果找不到，</p></li><li class="listitem"><p>则再到parent容器的Resource Loading服务中查找，如果找不到，则放弃。</p></li></ol></div><p>运用这种级联装载资源的方法，子应用可以把共享的资源定义在root context中，而把自己独享的资源定义在自己的容器当中。</p><p>前文所述的<code class="code">&lt;super-loader&gt;</code>也支持级联装载资源。<code class="code">&lt;super-loader&gt;</code>会先在当前容器的Resource
                Loading服务中查找，如果找不到，就到parent容器的Resource
                Loading服务中查找。利用<code class="code">&lt;super-loader&gt;</code>，你甚至可以改变资源搜索的顺序。例如，你可以命令Resource
                Loading服务先查找parent容器中的Resource
                Loading服务，再查找当前容器中的<code class="code">ResourceLoader</code>s：</p><div class="example"><a id="d0e4273"><!--anchor d0e4273--></a><p class="title"><strong>例 5.26. 利用<code class="code">&lt;super-loader&gt;</code>改变资源搜索的顺序</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:super-loader /&gt;</strong> <a id="co.rl.load.parent.1.super"><!--anchor co.rl.load.parent.1.super--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader /&gt;</strong> <a id="co.rl.load.parent.2.file"><!--anchor co.rl.load.parent.2.file--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.load.parent.1.super"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>先找parent容器中的Resource Loading服务。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.load.parent.2.file"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>再找当前容器中的<code class="code">ResourceLoader</code>s。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.modify.res"><!--anchor webx.resource.modify.res--></a>5.3.8. 修改资源文件的内容</h3></div></div></div><p>Resource Loading服务支持内容过滤 ——
                你可以在获取资源以前读取甚至修改资源文件的内容。一种常见的情形是，将XML格式的资源文件用XSLT转换格式：</p><div class="example"><a id="d0e4300"><!--anchor d0e4300--></a><p class="title"><strong>例 5.27. 将XML格式的资源文件用XSLT转换格式</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource-loading</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
        <span class="hl-attribute" style="color: #F5844C">xmlns:res-loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        xmlns:res-filters="http://www.alibaba.com/schema/services/resource-loading/filters"&gt;
    ...

    <strong class="hl-tag" style="color: #000096">&lt;resource-filters</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"test-*.xml"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-filters:xslt-filter</strong> <span class="hl-attribute" style="color: #F5844C">xslt</span>=<span class="hl-value" style="color: #993300">"/stylesheet.for.test/test.xsl"</span> <span class="hl-attribute" style="color: #F5844C">saveTo</span>=<span class="hl-value" style="color: #993300">"/tempdir"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rl.filter.xslt"><!--anchor co.rl.filter.xslt--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/resource-filters&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/tempdir"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rl.filter.tempdir"><!--anchor co.rl.filter.tempdir--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${project.home}/target/test"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/resource-loading&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.filter.xslt"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将<span class="emphasis"><em>所有目录下</em></span>（因为是相对路径）的名称为<code class="filename">test-*.xml</code>文件，用指定的XSL文件进行转换。</p><p>这里引进了一种新的扩展点：<code class="code">ResourceFilter</code>。<code class="code">ResourceFilter</code>可以在应用获取资源之前，取得控制，以便对资源做一点事。</p><p><code class="code">&lt;xslt-filter&gt;</code>是对<code class="code">ResourceFilter</code>的扩展，它能够把XML资源用指定的xsl文件转换成新的格式。假如指定了<code class="code">saveTo</code>参数，就可以把转换的结果保存下来，避免每次访问都重新转换。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.filter.tempdir"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处定义<code class="code">tempdir</code>目录资源，以便保存xslt转换的结果。</p></td></tr></table></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="code">&lt;xslt-filter&gt;</code>的参数<code class="code">xslt</code>所指向的xsl文件，以及参数<code class="code">saveTo</code>所指向的目录，它们本身也是由Resource
                    Loading服务装载的。</p></td></tr></table></div><p>有哪些情况需要这种内容过滤的功能呢？</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>单元测试 —— 我们可能需要对单元测试的资源文件进行特殊的转换。</p></li><li class="listitem"><p>高速缓存 ——
                                有一些<code class="code">ResourceLoader</code>可能会有性能的开销，例如：从数据库中装载资源。利用<code class="code">ResourceFilter</code>功能，就可以把装载的资源缓存在高速cache中，以提高系统的性能。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.using.service"><!--anchor webx.resource.using.service--></a>5.3.9. 直接使用<code class="code">ResourceLoadingService</code></h3></div></div></div><p>前面所讲的Resource Loading服务的用法，对应用程序而言，是完全透明的。也就是说，应用程序并不需要关心Resource
                Loading服务的存在，而是按照Spring <code class="code">ResourceLoader</code>的老用法，就可以工作。</p><p>但是你也可以直接注入<code class="code">ResourceLoadingService</code>对象，以取得更多的功能。</p><div class="example"><a id="d0e4384"><!--anchor d0e4384--></a><p class="title"><strong>例 5.28. 注入<code class="code">ResourceLoadingService</code>对象</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> ResourceLoadingService resourceLoadingService;
}</pre></div></div><p>下面列举了可通过<code class="code">ResourceLoadingService</code>接口实现的功能。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">取得资源</span></dt><dd><div class="example"><a id="d0e4402"><!--anchor d0e4402--></a><p class="title"><strong>例 5.29. 通过<code class="code">ResourceLoadingService</code>接口取得资源</strong></p><div class="example-contents"><pre class="programlisting">Resource resource = resourceLoadingService.getResource(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>); <a id="co.rl.service.getres"><!--anchor co.rl.service.getres--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
Resource resource = resourceLoadingService.getResource(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>,
                                                       ResourceLoadingService.FOR_CREATE); <a id="co.rl.service.getres2"><!--anchor co.rl.service.getres2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.service.getres"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>和Spring不同的是，如果你直接调用<code class="code">ResourceLoadingService</code>取得资源，当资源文件不存在时，你会得到一个<code class="code">ResourceNotFoundException</code>。而Spring无论如何都会取得<code class="code">Resource</code>对象，但随后你需要调用<code class="code">Resource.exists()</code>方法来判断资源存在于否。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.service.getres2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">ResourceLoadingService.getResource()</code>方法还支持一个选项：<code class="code">FOR_CREATE</code>。如果提供了这个选项，那么对于某些类型的资源（如文件系统的资源），即使文件或目录不存在，仍然会返回结果。这样，你就可以创建这个文件或目录
                                        —— 这就是<code class="code">FOR_CREATE</code>参数的意思。</p></td></tr></table></div></div></div></dd><dt><span class="term">取得特定类型的资源</span></dt><dd><div class="example"><a id="d0e4444"><!--anchor d0e4444--></a><p class="title"><strong>例 5.30. 通过<code class="code">ResourceLoadingService</code>接口取得特定类型的资源</strong></p><div class="example-contents"><pre class="programlisting"><em class="hl-comment" style="color: green">// 取得资源文件</em>
File file = resourceLoadingService.getResourceAsFile(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>);

<em class="hl-comment" style="color: green">// 取得资源URL</em>
URL url = resourceLoadingService.getResourceAsURL(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>);

<em class="hl-comment" style="color: green">// 取得资源输入流</em>
InputStream stream = resourceLoadingService.getResourceAsStream(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>);</pre></div></div></dd><dt><span class="term">判断资源存在于否</span></dt><dd><div class="example"><a id="d0e4456"><!--anchor d0e4456--></a><p class="title"><strong>例 5.31. 通过<code class="code">ResourceLoadingService</code>接口判断资源存在于否</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">if</strong> (resourceLoadingService.exists(<strong class="hl-string"><em style="color:navy">"/myapp/conf/myFile.xml"</em></strong>)) {
    ...
}</pre></div></div></dd><dt><span class="term">列举子资源</span></dt><dd><div class="example"><a id="d0e4468"><!--anchor d0e4468--></a><p class="title"><strong>例 5.32. 通过<code class="code">ResourceLoadingService</code>接口列举子资源</strong></p><div class="example-contents"><pre class="programlisting">String[] resourceNames = resourceLoadingService.list(<strong class="hl-string"><em style="color:navy">"/myapp/conf"</em></strong>);
Resource[] resources = resourceLoadingService.listResources(<strong class="hl-string"><em style="color:navy">"/myapp/conf"</em></strong>);</pre></div></div><p>相当于列出当前目录下的所有子目录和文件。</p><p>不是所有的<code class="code">ResourceLoader</code>都支持这个操作 ——
                                <code class="code">FileResourceLoader</code>和<code class="code">WebappResourceLoader</code>支持列举子资源，<code class="code">ClasspathResourceLoader</code>则不支持。
                        </p></dd><dt><span class="term">跟踪取得资源的过程</span></dt><dd><div class="example"><a id="d0e4496"><!--anchor d0e4496--></a><p class="title"><strong>例 5.33. 通过<code class="code">ResourceLoadingService</code>接口跟踪取得资源的过程</strong></p><div class="example-contents"><pre class="programlisting">ResourceTrace trace = resourceLoadingService.trace(<strong class="hl-string"><em style="color:navy">"/myapp/conf/webx.xml"</em></strong>);

<strong class="hl-keyword" style="color: maroon">for</strong> (ResourceTraceElement element : trace) {
    System.out.println(element);
}</pre></div></div><p>这是用来方便调试的功能。有点像<code class="code">Throwable.getStackTrace()</code>方法，可以得到每一个方法调用的历史记录
                            ——
                            <code class="code">ResourceLoadingService.trace()</code>方法可以将取得资源的步骤记录下来。上面代码会在console中输出类似下面的内容：</p><pre class="screen">"/myapp/conf/webx.xml" matched [resource-alias pattern="/myapp/conf"], at "resources.xml", beanName="resourceLoadingService"
"/webroot/WEB-INF/webx.xml" matched [resource pattern="/webroot"], at "resources.xml", beanName="resourceLoadingService"
</pre></dd><dt><span class="term">列出所有可用的资源定义和别名的pattern</span></dt><dd><div class="example"><a id="d0e4518"><!--anchor d0e4518--></a><p class="title"><strong>例 5.34. 通过<code class="code">ResourceLoadingService</code>接口列出所有可用的资源定义和别名的pattern</strong></p><div class="example-contents"><pre class="programlisting">String[] patterns = resourceLoadingService.getPatterns(true);</pre></div></div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.using.service.nonweb"><!--anchor webx.resource.using.service.nonweb--></a>5.3.10. 在非Web环境中使用Resource Loading服务</h3></div></div></div><div class="figure"><a id="d0e4529"><!--anchor d0e4529--></a><div class="figure-contents"><div class="mediaobject"><img src="images/resource/rl-non-web.png" alt="在非Web环境中使用的ResourceLoadingXmlApplicationContext"/></div></div><p class="title"><strong>图 5.4. 在非Web环境中使用的<code class="code">ResourceLoadingXmlApplicationContext</code></strong></p></div><p>在非Web环境中使用Resource
                    Loading服务的最好方法，是创建<code class="code">ResourceLoadingXmlApplicationContext</code>作为Spring容器。</p><div class="example"><a id="d0e4542"><!--anchor d0e4542--></a><p class="title"><strong>例 5.35. 创建<code class="code">ResourceLoadingXmlApplicationContext</code>容器</strong></p><div class="example-contents"><pre class="programlisting">ApplicationContext context = <strong class="hl-keyword" style="color: maroon">new</strong> ResourceLoadingXmlApplicationContext(
                                                          <strong class="hl-keyword" style="color: maroon">new</strong> FileSystemResource(<strong class="hl-string"><em style="color:navy">"beans.xml"</em></strong>));</pre></div></div><p>只要<code class="filename">beans.xml</code>中包含<code class="code">&lt;resource-loading&gt;</code>的配置，就会自动启用Resource
                    Loading服务，并取代Spring原来的<code class="code">ResourceLoader</code>机制。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx.resource.loaders"><!--anchor webx.resource.loaders--></a>5.4. ResourceLoader参考</h2></div></div></div><p>Resource Loading服务的核心是<code class="code">ResourceLoader</code>。和Spring
            <code class="code">ResourceLoader</code>不同，Resource
                Loading服务的<code class="code">ResourceLoader</code>是可扩展的轻量级对象，担负着装载某一种类型的资源的具体任务。例如<code class="code">FileResourceLoader</code>负责装载文件系统的资源；<code class="code">WebappResourceLoader</code>负责装载WEB应用中的资源等等。</p><p>当你需要新的资源装载方式时，你所要做的，就是实现一种新的<code class="code">ResourceLoader</code>。例如，你想从数据库中装载资源，那么就可以实现一个<code class="code">DatabaseResourceLoader</code>。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.file"><!--anchor webx.resource.loader.file--></a>5.4.1. <code class="code">FileResourceLoader</code></h3></div></div></div><p><code class="code">FileResourceLoader</code>的功能是：从文件系统中装载资源。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">基本用法</span></dt><dd><div class="example"><a id="d0e4602"><!--anchor d0e4602--></a><p class="title"><strong>例 5.36. <code class="code">FileResourceLoader</code>的基本用法</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></div></div><p>这样，<code class="code">file-loader</code>会从哪里装载资源呢？</p><p>答案是：<span class="emphasis"><em>从当前配置文件所在的目录中装载</em></span>。假如上述资源配置所在的配置文件是<code class="code">c:/myapp/conf/resources.xml</code>，那么<code class="code">file-loader</code>就会从<code class="code">c:/myapp/conf/myFile.xml</code>文件中装载<code class="code">/my/virtual/myFile.xml</code>资源。</p><p>这样做的思路源自于Apache的一个项目：Ant。Ant是一个广为使用的build工具。每一个Ant项目，都有一个<code class="filename">build.xml</code>脚本，在里面定义了很多target，诸如编译项目、打包等。通常我们都会把<code class="filename">build.xml</code>这个文件放在项目的根目录中，然后<code class="filename">build.xml</code>中的命令全是使用相对于<code class="filename">build.xml</code>所在的项目根目录计算出来的相对路径。例如：</p><div class="example"><a id="d0e4645"><!--anchor d0e4645--></a><p class="title"><strong>例 5.37. Ant脚本（<code class="filename">build.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;target</strong> <span class="hl-attribute" style="color: #F5844C">...&gt;</span>
        <span class="hl-attribute" style="color: #F5844C">&lt;copy</span> <span class="hl-attribute" style="color: #F5844C">todir</span>=<span class="hl-value" style="color: #993300">"bin"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;fileset</strong> <span class="hl-attribute" style="color: #F5844C">dir</span>=<span class="hl-value" style="color: #993300">"src"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/copy&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/target&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre></div></div><p>在上面的Ant脚本中，<code class="code">bin</code>、<code class="code">src</code>目录全是相对于<code class="filename">build.xml</code>所在目录的相对目录。这样做的好处是，当你把项目移到不同的环境中，你也无需改变配置文件和脚本。</p><p><code class="code">FileResourceLoader</code>采用了和Ant完全类似的想法。</p></dd><dt><span class="term">指定<code class="code">basedir</code></span></dt><dd><div class="example"><a id="d0e4674"><!--anchor d0e4674--></a><p class="title"><strong>例 5.38. 在<code class="code">FileResourceLoader</code>中指定<code class="code">basedir</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"${my.basedir}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre></div></div><p><code class="code">FileResourceLoader</code>当然也支持指定<code class="code">basedir</code>根目录。这样，它就会从指定的<code class="code">basedir</code>的子目录中查找资源。</p><p>一般来说，我们需要利用Spring Property
                                Placeholder来设置<code class="code">basedir</code>。在上面的例子中，我们可以在系统启动时，指定JVM参数：<code class="code">-Dmy.basedir=c:/mydata</code>。在不同的系统环境中，必须指定正确的<code class="code">basedir</code>，否则，<code class="code">&lt;file-loader&gt;</code>有可能找不到资源。
                        </p></dd><dt><span class="term">搜索多个路径</span></dt><dd><div class="example"><a id="d0e4712"><!--anchor d0e4712--></a><p class="title"><strong>例 5.39. 在<code class="code">FileResourceLoader</code>中指定多个搜索路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:file-loader</strong> <span class="hl-attribute" style="color: #F5844C">basedir</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:path&gt;</strong>relativePathToBasedir<strong class="hl-tag" style="color: #000096">&lt;/res-loaders:path&gt;</strong> <a id="co.rl.loader.file.relpath"><!--anchor co.rl.loader.file.relpath--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;res-loaders:path</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"absolute"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>c:/absolutePath<strong class="hl-tag" style="color: #000096">&lt;/res-loaders:path&gt;</strong> <a id="co.rl.loader.file.abspath"><!--anchor co.rl.loader.file.abspath--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/res-loaders:file-loader&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.loader.file.relpath"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>搜索路径默认为相对路径，相对于指定的<code class="code">basedir</code>。如果<code class="code">basedir</code>未指定，则相对于当前<code class="code">resource-loading</code>所在的配置文件的路径。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rl.loader.file.abspath"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>搜索路径也可以是绝对路径。</p></td></tr></table></div></div></div><p><code class="code">FileResourceLoader</code>支持搜索多个路径，类似于操作系统在<code class="code">PATH</code>环境变量所指定的路径中，搜索可执行文件；也类似于Java在<code class="code">CLASSPATH</code>参数所指定的路径中，搜索classes。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.webapp"><!--anchor webx.resource.loader.webapp--></a>5.4.2. <code class="code">WebappResourceLoader</code></h3></div></div></div><p><code class="code">WebappResourceLoader</code>的功能是：从当前WEB应用中装载资源，也就是从<code class="code">ServletContext</code>对象中装载资源。</p><div class="example"><a id="d0e4761"><!--anchor d0e4761--></a><p class="title"><strong>例 5.40. 配置<code class="code">WebappResourceLoader</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:webapp-loader /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.classpath"><!--anchor webx.resource.loader.classpath--></a>5.4.3. <code class="code">ClasspathResourceLoader</code></h3></div></div></div><p><code class="code">ClasspathResourceLoader</code>的功能是：从classpath中装载资源，也就是从当前的<code class="code">ClassLoader</code>对象中装载资源。</p><div class="example"><a id="d0e4779"><!--anchor d0e4779--></a><p class="title"><strong>例 5.41. 配置<code class="code">ClasspathResourceLoader</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;resource</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/my/virtual"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;res-loaders:classpath-loader /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.super"><!--anchor webx.resource.loader.super--></a>5.4.4. <code class="code">SuperResourceLoader</code></h3></div></div></div><p><code class="code">SuperResourceLoader</code>的功能是：调用Resource
                    Loading服务来取得资源。它有点像Java里面的<code class="code">super</code>操作符。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">取得新名字所代表的资源</span></dt><dd><div class="example"><a id="d0e4802"><!--anchor d0e4802--></a><p class="title"><strong>例 5.42. 用<code class="code">SuperResourceLoader</code>取得新名字所代表的资源</strong></p><div class="example-contents"><pre class="programlisting">&lt;resource pattern="/my/virtual"&gt;
    &lt;res-loaders:super-loader basedir="/webroot/WEB-INF" /&gt;
&lt;/resource&gt;
</pre></div></div><p>这个操作类似于<code class="code">&lt;resource-alias&gt;</code>。</p><p>如果在当前context的Resource Loading服务中找不到资源，它会前往parent context中查找。 </p></dd><dt><span class="term">在parent context中查找资源</span></dt><dd><div class="example"><a id="d0e4821"><!--anchor d0e4821--></a><p class="title"><strong>例 5.43. 用<code class="code">SuperResourceLoader</code>查找parent context中的资源</strong></p><div class="example-contents"><pre class="programlisting">&lt;resource pattern="/my/virtual"&gt;
    &lt;res-loaders:super-loader /&gt;
&lt;/resource&gt;
</pre></div></div><p>如果你不指定<code class="code">name</code>参数，那么<code class="code">SuperResourceLoader</code>会直接去parent
                            context中查找资源，而不会在当前context的Resource Loading服务中找。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.resource.loader.other"><!--anchor webx.resource.loader.other--></a>5.4.5. 关于<code class="code">ResourceLoader</code>的其它考虑</h3></div></div></div><p>以上所有的<code class="code">ResourceLoader</code>都被设计成可以在任何环境中工作，即使当前环境不适用，也不会报错。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">WebappResourceLoader</code>可以兼容非WEB环境</span></dt><dd><p>在非WEB环境中，例如单元测试环境、你直接通过<code class="code">XmlApplicationContext</code>创建的Spring环境，<code class="code">WebappResourceLoader</code>也不会出错
                            —— 只不过它找不到任何资源而已。</p></dd><dt><span class="term"><code class="code">SuperResourceLoader</code>可以工作于非级联的环境</span></dt><dd><p>也就是说，即使parent context不存在，或者parent context中没有配置Resource
                                Loading服务，<code class="code">SuperResourceLoader</code>也是可以工作的。</p></dd></dl></div><p>这样，同一套资源配置文件，可以被用于所有环境。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e4876"><!--anchor d0e4876--></a>5.5. 本章总结</h2></div></div></div><p>Resource Loading服务提供了一套高度可扩展的、强大的资源装载机制。这套机制和Spring
            <code class="code">ResourceLoader</code>无缝连接。使用它并不需要特殊的技能，只要掌握Spring的风格即可。</p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.filter.requestcontexts.pipeline"><!--anchor webx.filter.requestcontexts.pipeline--></a>第 6 章 Filter、Request Contexts和Pipeline</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4894">6.1. Filter</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4897">6.1.1. Filter的用途</a></span></dt><dt><span class="section"><a href="#d0e4957">6.1.2. Filter工作原理</a></span></dt><dt><span class="section"><a href="#d0e5017">6.1.3. Filter的限制</a></span></dt><dt><span class="section"><a href="#d0e5045">6.1.4. Webx对filter功能的补充</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5103">6.2. Request Contexts服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5106">6.2.1. Request Contexts工作原理</a></span></dt><dt><span class="section"><a href="#d0e5148">6.2.2. Request Contexts的用途</a></span></dt><dt><span class="section"><a href="#d0e5217">6.2.3. Request Contexts的使用</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5451">6.3. Pipeline服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5454">6.3.1. Pipeline工作原理</a></span></dt><dt><span class="section"><a href="#d0e5477">6.3.2. Pipeline的用途</a></span></dt><dt><span class="section"><a href="#d0e5490">6.3.3. Pipeline的使用</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6044">6.4. 本章总结</a></span></dt></dl></div><p>Filter是Servlet规范2.3版及更新版所支持的一种机制。和Servlet/JSP不同，Filter自己往往不会直接产生response，相反，它提供了一种“符加”的功能，可以作用在任何一个servlet、JSP以及其它filter之上。然而，在实际的应用中，我们发现filter有很多不足之处。</p><p>Webx框架提供了两种机制（Request
        Contexts和Pipeline）来作为filter机制的补充。在大多数情况下，它们都可以实现类似filter的功能，但比filter更容易扩展、更容易配置、也更轻量。Webx并没有打算完全替代filter，相反它还是可以和任何filter搭配使用。</p><p>本章先简略介绍filter的功能和不足，再向你介绍Request Contexts和Pipeline的工作原理，及使用方法。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e4894"><!--anchor d0e4894--></a>6.1. Filter</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4897"><!--anchor d0e4897--></a>6.1.1. Filter的用途</h3></div></div></div><p>Filter这种机制常被用来实现下面的功能：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="19%" class="c1"/><col width="81%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">页面授权</td><td style="border-bottom: 0.5pt solid #6666cc; ">根据登录用户的权限，阻止或许可用户访问特定的页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">日志和审计</td><td style="border-bottom: 0.5pt solid #6666cc; ">记录和检查用户访问WEB应用的情况。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">图片转换</td><td style="border-bottom: 0.5pt solid #6666cc; ">改变图片的格式、精度、尺寸等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">页面压缩</td><td style="border-bottom: 0.5pt solid #6666cc; ">压缩页面内容，加快下载速度。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">本地化</td><td style="border-bottom: 0.5pt solid #6666cc; ">显示本地语言和风格的页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">XSLT转换</td><td style="border-bottom: 0.5pt solid #6666cc; ">对XML内容进行XSLT转换，使之适用于多种客户端。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">高速缓存</td><td style="">高速缓存页面，提高响应速度。</td></tr></tbody></table></div><p>当然还有更多种的应用，我们不可能一一列举。</p><p>Filter的通用性很好。任何filter均独立于其它filter和servlet，因此它可以和任意其它filter和servlet组合搭配。下面是一段配置示例
                ── 通过<code class="code">SetLoggingContextFilter</code>，日志系统可以记录当前请求的信息，例如：URL、referrer URL、query
                string等。</p><div class="example"><a id="d0e4949"><!--anchor d0e4949--></a><p class="title"><strong>例 6.1. Filter配置示例（<code class="filename">/WEB-INF/web.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>mdc<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-class&gt;</strong>com.alibaba.citrus.webx.servlet.SetLoggingContextFilter<strong class="hl-tag" style="color: #000096">&lt;/filter-class&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filter-mapping&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>mdc<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url-pattern&gt;</strong>/*<strong class="hl-tag" style="color: #000096">&lt;/url-pattern&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter-mapping&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4957"><!--anchor d0e4957--></a>6.1.2. Filter工作原理</h3></div></div></div><div class="figure"><a id="d0e4960"><!--anchor d0e4960--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/filter-chain.png" alt="Filter Chain"/></div></div><p class="title"><strong>图 6.1. Filter Chain</strong></p></div><p>如图所示。多个filter和至多一个servlet被串联成一个链，被称为Filter
                    Chain。执行的时候，引擎将控制权交给链条中的头一个filter（如果有的话）。然后，就像<span class="emphasis"><em>击鼓传花</em></span>一样，控制权被依次传递给filter chain中的下一个filter或servlet。每一个得到控制权的filter可以做下面的事：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>继续传递控制权或立即终止filter chain。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Filter可将控制权传递给链条中的下一个filter或者最终的servlet。</p></li><li class="listitem"><p>Filter也可以不将控制权传递给下一个filter或servlet，这样便中止了整个filter
                                        chain的执行。</p></li></ul></div></li><li class="listitem"><p>预处理。在传递控制权给下一个filter或servlet之前，filter可以预先做一些事情：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>设置request、response中的参数，例如：character encoding、content
                                        type等。</p></li><li class="listitem"><p>将<code class="code">HttpServletRequestWrapper</code>传递给链条中的下一位，filter可以通过wrapper改变request中的任意值。</p></li><li class="listitem"><p>将<code class="code">HttpServletResponseWrapper</code>传递给链条中的下一位，filter可以通过wrapper来拦截后续filter或servlet对response的修改。</p></li></ul></div></li><li class="listitem"><p>提交。在控制权从filter chain中返回以后，filter还可以做一些后续提交的操作。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>例如，将response中拦截而来的数据，压缩或转换格式，并发送给客户端或filter
                                        chain的上一级。</p></li><li class="listitem"><p>通过<code class="code">try</code>、<code class="code">catch</code>还可以捕获filter
                                        chain下一级所有的异常，并做处理。 </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5017"><!--anchor d0e5017--></a>6.1.3. Filter的限制</h3></div></div></div><p>Filter是很有用的。作为servlet的补充，filter也是很成功的。但是filter并没有被设计用来完成一切事情。事实上，filter的设计限制了filter的用途。每个filter具有下面的限制：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Filter可以访问和修改数据。但它只能访问和修改<code class="code">HttpServletRequest</code>、<code class="code">HttpServletResponse</code>、<code class="code">ServletContext</code>等容器级的对象，而不能（或很难）访问应用程序中的状态。所以filter无法实现和应用逻辑密切相关的功能。</p></li><li class="listitem"><p>Filter可以影响执行流程。但它不能改变filter chain的结构和顺序。Filter
                                chain的结构和顺序是由<code class="filename">web.xml</code>中定义的。当filter得到控制权以后，它只能选择继续下去，或者立即结束，而没法进行循环、分支、条件判断等更复杂的控制。因此，filter只能用来实现粗粒度的流程控制功能（例如，当用户未获授权时，停止执行filter
                            chain），难以应付更细致的应用程序内的控制需求。</p></li><li class="listitem"><p>Filter与其它filter和servlet之间，除了request和response对象以外，无法共享其它的状态。这既是优点又是缺点。优点是使filter更独立、更通用；缺点是filter与其它filter、servlet之间难以协作，有时甚至会引起无谓的性能损失。</p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5045"><!--anchor d0e5045--></a>6.1.4. Webx对filter功能的补充</h3></div></div></div><p>综上所述，一个filter常常做的两件事是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>改变request/response对象（通过<code class="code">HttpServletRequestWrapper</code>和<code class="code">HttpServletResponseWrapper</code>）；</p></li><li class="listitem"><p>改变应用执行的流程。</p></li></ul></div><p>其实，大部分filter只做其中一件事。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>页面压缩filter仅仅改变response，并不改变应用的流程。</p></li><li class="listitem"><p>页面授权filter根据当前请求用户的身份，判定他是否有权限访问当前页面。这个filter会影响应用流程，却不会去改变request和response。
                        </p></li></ul></div><p>当然也有例外。有一些filter不做上面两件事中任何一件。例如，日志filter仅仅读取request对象并记录日志而已，既不改变request/response，也不影响应用的流程。还有一些filter同时做上面两件事。比如高速缓存页面的filter不仅要修改response，而且当cache被命中时，不再执行下一步的流程，而是直接返回cache中的内容，以提高性能。</p><p>Webx框架提供了两个服务，正好吻合了上述两个最常用的filter的功能。</p><div class="informaltable"><table cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Request Contexts服务</td><td style="border-bottom: 0.5pt solid #6666cc; ">该服务负责访问和修改request和response，但不负责改变应用执行的流程。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Pipeline服务</td><td style="">提供应用执行的流程，但不关心request和response。</td></tr></tbody></table></div><p>虽然这两个服务看起来和filter的功能类似，但是它们远比filter要强大和方便 ── 它们克服了上述filter的几个限制：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>和Filter不同，Request Contexts和Pipeline服务可以访问应用内部的状态和资源，效率更高，功能更强。</p></li><li class="listitem"><p>和Filter不同，Pipeline服务可以定义灵活（但仍然简单）地控制应用的流程
                            。Pipeline不仅可以控制流程的中断或继续，还可以实现子流程、循环、条件转移、异常处理等更精细的流程控制。Pipeline服务甚至可以运用在非WEB的环境中。</p></li><li class="listitem"><p>和Filter不同，Request Contexts服务中的每一个环节（Request
                            Context）之间并非完全独立、互不干涉的。每个request context可以访问它所依赖的其它request
                            context中的状态。</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e5103"><!--anchor d0e5103--></a>6.2. Request Contexts服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5106"><!--anchor d0e5106--></a>6.2.1. Request Contexts工作原理</h3></div></div></div><p>Request Context，顾名思义，就是一个请求的上下文。事实上，你可以把Request
                    Context看作是<code class="code">HttpServletRequest</code>和<code class="code">HttpServletResponse</code>这两个对象的总和。除此之外，多个Request
                Context可以被串接起来，被称为Request Context Chain，类似于filter chain。</p><div class="figure"><a id="d0e5117"><!--anchor d0e5117--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/request-context-chain.png" alt="Request Context Chain"/></div></div><p class="title"><strong>图 6.2. Request Context Chain</strong></p></div><p>如上图所示，每一个Request Context都可以包括两个基本的操作：“预处理”和“提交”。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>在一个请求开始的时候，每个Request Context的“预处理”过程被依次调用。最内层的（即最先的）Request
                            Context最先被调用，最外层的（即最后的）Request Context最后被调用；</p></li><li class="listitem"><p>在一个请求结束的时候，每个Request Context的“提交”过程被依次调用。和“预处理”的顺序相反，最外层的（即最后的）Request
                            Context最先被调用，最内层的（即最先的）Request Context最后被调用。</p></li></ul></div><p>Request
                    Context在预处理的时候，可以利用<code class="code">HttpServletRequestWrapper</code>和<code class="code">HttpServletResponseWrapper</code>来包装和修改request和response
                ── 这一点和filter相同。每一层Request Context，都会增加一个新的特性。最先的Request Context成为最内层的包装，最后的Request
                Context成为最外层的包装。如下图所示。</p><div class="figure"><a id="d0e5140"><!--anchor d0e5140--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/request-contexts.png" alt="Request Contexts的嵌套"/></div></div><p class="title"><strong>图 6.3. Request Contexts的嵌套</strong></p></div><p>和filter原理中的图进行对比，你会发现，尽管Request Contexts和Filter的执行方案有明显的不同，但是Request
                Contexts预处理和提交的顺序是和filter
                chain完全一致的。预处理时，由内层执行到外层；提交时，反过来由外层执行到内层。不同的是，filter能够决定是否继续传递控制权给filter
                chain中的下一位，而Request Context则没有这个权利。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5148"><!--anchor d0e5148--></a>6.2.2. Request Contexts的用途</h3></div></div></div><p>Webx目前提供了以下几种request context的实现，每个都有独特的功能。</p><div class="table"><a id="d0e5153"><!--anchor d0e5153--></a><p class="title"><strong>表 6.1. Request Contexts的功能</strong></p><div class="table-contents"><table summary="Request Contexts的功能" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">功能</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;basic&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">提供基础安全特性，例如：过滤response headers、cookies，限制cookie的大小等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;buffered&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">缓存response中的内容。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;lazy-commit&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">延迟提交response。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;parser&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">解析参数，支持multipart/form-data（即上传文件请求）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;rewrite&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">重写请求的URL和参数。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;session&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">一套可扩展的session框架，重新实现了HttpSession接口。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;set-locale&gt;</code></td><td style="" valign="middle">设置locale区域和charset字符集编码。</td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>本章对以上所有的request contexts的功能和用法不作具体的介绍，详情请参阅<a class="xref" href="#webx.requestcontexts" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>和<a class="xref" href="#webx.requestcontext.session" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>。</p></td></tr></table></div><p>需要特别指出的是，你还可以扩展出更多的Request Context，以实现新的功能。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5217"><!--anchor d0e5217--></a>6.2.3. Request Contexts的使用</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5220"><!--anchor d0e5220--></a>6.2.3.1. 配置</h4></div></div></div><p>除了下面例子所示的一段配置之外，你不需要做太多的事，就可以使用Request Contexts。因为Request Contexts对于应用来说是透明的
                    ──
                    多数应用只需要依赖于<code class="code">HttpServletRequest</code>和<code class="code">HttpServletResponse</code>就可以了。</p><div class="example"><a id="d0e5231"><!--anchor d0e5231--></a><p class="title"><strong>例 6.2. Request Context的配置（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:request-contexts</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
                http://localhost:8080/schema/services.xsd
        http://www.alibaba.com/schema/services/request-contexts
                http://localhost:8080/schema/services-request-contexts.xsd
        http://www.springframework.org/schema/beans
                http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <em class="hl-comment" style="color: green">&lt;!-- Optional -
        &lt;session /&gt;
        &lt;rewrite /&gt;
        --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre></div></div><p>由于使用了SpringExt的schema机制，所以在支持schema的XML编辑器的帮助下，很容易书写和验证Request
                    Contexts的配置。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5241"><!--anchor d0e5241--></a>6.2.3.2. 排序</h4></div></div></div><p>Request Contexts之间，有时会有依赖关系，所以Request Contexts出现的先后顺序是非常重要的。例如，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">&lt;session&gt;</code>提供了基于cookie的session支持。然而cookie属于response
                                    header。一旦response被提交，header就无法再修改了。因此<code class="code">&lt;session&gt;</code>依赖于<code class="code">&lt;lazy-commit&gt;</code>，以阻止response过早提交。也就是说，<code class="code">&lt;lazy-commit&gt;</code>必须排在<code class="code">&lt;session&gt;</code>之前。</p></li><li class="listitem"><p><code class="code">&lt;rewrite&gt;</code>需要访问参数，而参数是能过<code class="code">&lt;parser&gt;</code>解析的，所以<code class="code">&lt;parser&gt;</code>要排在<code class="code">&lt;rewrite&gt;</code>之前。</p></li></ul></div><p>类似的约束还有很多。如果把Request
                    Contexts的顺序排错，可能会导致某项功能错误或失效。然而，对于一般的应用开发者而言，这些约束往往是神秘的、并非显而易见的，需要经过细致地分析才能了解它们。</p><p>好在Request Contexts内部提供了一个机制，可以根据预定义的约束条件，对所有的Request
                    Contexts进行自动排序。和Filter不同，应用开发者不需要在意Request Contexts在配置文件中的排列顺序，就可以保证所有的Request
                    Contexts能够正常工作。下面的两种配置文件是等效的：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <div class="example"><a id="d0e5290"><!--anchor d0e5290--></a><p class="title"><strong>例 6.3. Request Contexts等效配置1</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;rewrite /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div>
                                </td><td style="">
                                    <div class="example"><a id="d0e5298"><!--anchor d0e5298--></a><p class="title"><strong>例 6.4. Request Contexts等效配置2</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;rewrite /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div>
                                </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5304"><!--anchor d0e5304--></a>6.2.3.3. 访问特定的Request Context</h4></div></div></div><p>一般来说，Request Contexts对于应用程序是透明的 ── 也就是说，应用程序最多只需要访问Servlet
                        API中的接口：<code class="code">HttpServletRequest</code>和<code class="code">HttpServletResponse</code>即可，就好像Request
                    Contexts不存在一样。</p><p>比如，Request Context
                        <code class="code">&lt;parser&gt;</code>能够解析<code class="code">multipart/form-data</code>类型的请求（即上传图片请求）。但你不需要用另一个API来访问请求中的普通数据，你只需要用<code class="code">HttpServletRequest</code>中定义的方法就可以访问，仿佛这是一个普通的请求：</p><div class="example"><a id="d0e5326"><!--anchor d0e5326--></a><p class="title"><strong>例 6.5. 访问任意类型的请求中的参数</strong></p><div class="example-contents"><pre class="programlisting">String value = request.getParameter(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div><p>再比如，Request Context
                    <code class="code">&lt;session&gt;</code>重新实现了<code class="code">HttpSession</code>的接口，但是应用程序并不需要关心这些，他们还是和原来一样访问session：</p><div class="example"><a id="d0e5339"><!--anchor d0e5339--></a><p class="title"><strong>例 6.6. 访问session</strong></p><div class="example-contents"><pre class="programlisting">HttpSession session = request.getSession();

String value = (String) session.getAttribute(<strong class="hl-string"><em style="color:navy">"myattr"</em></strong>);
session.setAttribute(<strong class="hl-string"><em style="color:navy">"myattr"</em></strong>, newValue);</pre></div></div><p>然而，有一些功能在原有的Servlet
                    API中是不存在的。对于这一类功能，你必须访问特定的<code class="code">RequestContext</code>接口，才能使用它们。例如，你只能用另一个API才能读取用户上传的文件。下面的代码可以用来取得上传文件的信息：</p><div class="example"><a id="d0e5349"><!--anchor d0e5349--></a><p class="title"><strong>例 6.7. 访问特定的<code class="code">RequestContext</code>接口</strong></p><div class="example-contents"><pre class="programlisting">ParserRequestContext parserRequestContext =
                RequestContextUtil.findRequestContext(request, ParserRequestContext.<strong class="hl-keyword" style="color: maroon">class</strong>);

ParameterParser params = parserRequestContext.getParameters();

FileItem myfile = params.getFileItem(<strong class="hl-string"><em style="color:navy">"myfile"</em></strong>);

String filename = myfile.getName();
InputStream istream = myfile.getInputStream();</pre></div></div><p>另外有一些功能，使用Request Context接口比原来的Servlet
                        API接口更方便。例如，原来的<code class="code">request.getParameter()</code>方法只能取得字符串的参数值，但是利用<code class="code">ParserRequestContext</code>所提供的接口，就可以直接取得其它类型的值：</p><div class="example"><a id="d0e5365"><!--anchor d0e5365--></a><p class="title"><strong>例 6.8. 通过<code class="code">ParserRequestContext</code>接口访问参数比<code class="code">HttpServletRequest</code>更方便</strong></p><div class="example-contents"><pre class="programlisting">ParameterParser params = parserRequestContext.getParameters();

String stringValue = params.getString(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>); <em class="hl-comment" style="color: green">// 取得字符串值，默认为null</em>
<strong class="hl-keyword" style="color: maroon">int</strong> intValue = params.getInt(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>); <em class="hl-comment" style="color: green">// 取得整数值，默认为0</em>
<strong class="hl-keyword" style="color: maroon">boolean</strong> booleanValue = params.getBoolean(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, true); <em class="hl-comment" style="color: green">// 取得boolean值，指定默认值为true</em></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5376"><!--anchor d0e5376--></a>6.2.3.4. 注入request作用域的对象</h4></div></div></div><p>Spring最强大的功能是依赖注入。但是依赖注入有一个限制：小作用域的对象不能被注入到大作用域的对象。你不能够把request和session作用域的对象注入到singleton对象中。前者在每次WEB请求时，均会创建新的实例，每个线程独享这个request/session作用域的对象；后者是在Spring初始化或第一次使用时被创建，然后被所有的线程共享。假如你把某个request/session作用域的对象意外注入到singleton对象中，将可能产生致命的应用错误，甚至导致数据库的错乱。</p><div class="table"><a id="d0e5381"><!--anchor d0e5381--></a><p class="title"><strong>表 6.2. Webx中的重要对象及其作用域</strong></p><div class="table-contents"><table summary="Webx中的重要对象及其作用域" cellpadding="10" style="border: none;"><colgroup><col width="62%" class="c1"/><col width="38%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">对象类型</th><th style="border-bottom: 0.5pt solid #6666cc; ">作用域</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">ServletContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Singleton scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">HttpServletRequest</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Request scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">HttpServletResponse</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Request scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">HttpSession</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Session scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">所有<code class="code">RequestContext</code>对象，如：<code class="code">ParserRequestContext</code>、<code class="code">SessionRequestContext</code>等</td><td style="" valign="middle">Request scope</td></tr></tbody></table></div></div><p><span class="emphasis"><em>在一般的情况下</em></span>，对于一个singleton对象而言，例如，Webx中的action module、pipeline
                    valve对象等，下面的代码是错误的：</p><div class="example"><a id="d0e5436"><!--anchor d0e5436--></a><p class="title"><strong>例 6.9. 在action（singleton对象）中注入request scope的对象</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> ParserRequestContext parser;
}</pre></div></div><p>因为你不能把一个短期的对象如request、response和request
                        context注入到<code class="code">MyAction</code>这个singleton对象。然而，<span class="emphasis"><em>在Webx中，这样做是可以的</em></span>！奥秘在于Request
                    Contexts服务对上表所列的这些短期对象作了特殊的处理，使它们可以被注入到singleton对象中。事实上，被注入的只是一个“空壳”，真正的对象是在被访问到的时候才会从线程中取得的。</p><p>Webx鼓励应用程序使用singleton作用域的对象，不仅更简单，也更高效。经过上述技术处理以后，singleton对象访问request作用域对象的方法被大大简化了。
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e5451"><!--anchor d0e5451--></a>6.3. Pipeline服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5454"><!--anchor d0e5454--></a>6.3.1. Pipeline工作原理</h3></div></div></div><p>Pipeline的意思是管道，管道中有许多阀门（Valve），阀门可以控制水流的走向。在Webx中，pipeline的作用就是控制应用程序流程的走向。</p><div class="figure"><a id="d0e5459"><!--anchor d0e5459--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/pipeline-valves.png" alt="Pipeline和Valves"/></div></div><p class="title"><strong>图 6.4. Pipeline和Valves</strong></p></div><p>Pipeline的设计和filter非常相似，也是击鼓传花式的流程控制。但是有几点不同：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Pipeline只能控制流程，不能改变request和response。</p></li><li class="listitem"><p>Pipeline是轻量级组件，它甚至不依赖于WEB环境。Pipeline既可以在程序中直接装配，也可以由spring和schema来配置。</p></li><li class="listitem"><p>Pipeline支持更复杂的流程结构，例如：子流程、条件分支、循环等。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5477"><!--anchor d0e5477--></a>6.3.2. Pipeline的用途</h3></div></div></div><p>Pipeline可以说是Webx框架的核心功能之一。利用pipeline，你可以定制一个请求处理过程的每一步。</p><div class="example"><a id="d0e5482"><!--anchor d0e5482--></a><p class="title"><strong>例 6.10. 一个典型的Webx应用的pipeline配置文件（<code class="filename">pipeline.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:pl-conditions</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/conditions"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:pl-valves</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
                http://localhost:8080/schema/services.xsd
        http://www.alibaba.com/schema/services/pipeline/conditions
                http://localhost:8080/schema/services-pipeline-conditions.xsd
        http://www.alibaba.com/schema/services/pipeline/valves
                http://localhost:8080/schema/services-pipeline-valves.xsd
        http://www.springframework.org/schema/beans
                http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 初始化turbine rundata，并在pipelineContext中设置可能会用到的对象(如rundata、utils)，以便valve取得。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;prepareForTurbine /&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 设置日志系统的上下文，支持把当前请求的详情打印在日志中。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;setLoggingContext /&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 分析URL，取得target。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;analyzeURL</strong> <span class="hl-attribute" style="color: #F5844C">homepage</span>=<span class="hl-value" style="color: #993300">"homepage"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 检查csrf token，防止csrf攻击和重复提交。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong>

        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 执行带模板的screen，默认有layout。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"null, vm, jsp"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performTemplateScreen /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;renderTemplate /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 执行不带模板的screen，默认无layout。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"do"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performScreen /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 将控制交还给servlet engine。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;exit /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>

            <em class="hl-comment" style="color: green">&lt;!-- 假如rundata.setRedirectTarget()被设置，则循环，否则退出循环。 --&gt;</em>
            <strong class="hl-tag" style="color: #000096">&lt;breakUnlessTargetRedirected /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5490"><!--anchor d0e5490--></a>6.3.3. Pipeline的使用</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5493"><!--anchor d0e5493--></a>6.3.3.1. 创建一个valve</h4></div></div></div><div class="example"><a id="d0e5496"><!--anchor d0e5496--></a><p class="title"><strong>例 6.11. 一个简单的valve实现</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyValve <strong class="hl-keyword" style="color: maroon">implements</strong> Valve {
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invoke(PipelineContext pipelineContext) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        System.out.println(<strong class="hl-string"><em style="color:navy">"valve started."</em></strong>);

        pipelineContext.invokeNext(); <em class="hl-comment" style="color: green">// 调用后序valves</em>

        System.out.println(<strong class="hl-string"><em style="color:navy">"valve ended."</em></strong>);
    }
}</pre><p>配置（<code class="filename">pipeline.xml</code>）</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;valve</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.myapp.pipeline.MyValve"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div><p>上面的代码和配置创建了一个基本的valve ── 事实上，它只是打印了一些消息，然后把控制权传递给后序的valves。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5510"><!--anchor d0e5510--></a>6.3.3.2. 执行一个pipeline</h4></div></div></div><div class="example"><a id="d0e5513"><!--anchor d0e5513--></a><p class="title"><strong>例 6.12. 在代码中执行pipeline</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<strong class="hl-keyword" style="color: maroon">private</strong> Pipeline myPipeline;

<strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invokePipeline() {
    PipelineInvocationHandle invocation = myPipeline.newInvocation();

    invocation.invoke();

    System.out.println(invocation.isFinished());
    System.out.println(invocation.isBroken());
}</pre></div></div><p>从spring容器中取得一个pipeline对象以后（一般是通过注入取得），我们就可以执行它。上面代码中，<code class="code">PipelineInvocationHandle</code>对象代表此次执行pipeline的状态。Pipeline执行结束以后，访问<code class="code">invocation</code>对象就可以了解到pipeline的执行情况
                    ── 正常结束还是被中断？</p><p>Pipeline对象是线程安全的，可被所有线程所共享。但<code class="code">PipelineInvocationHandle</code>对象不是线程安全的，每次执行pipeline时，均需要取得新的<code class="code">invocation</code>对象。
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5534"><!--anchor d0e5534--></a>6.3.3.3. 调用子流程</h4></div></div></div><p>Pipeline支持子流程。事实上，子流程不过是另一个pipeline对象而已。</p><div class="figure"><a id="d0e5539"><!--anchor d0e5539--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/sub-pipelines.png" alt="Pipeline和子流程"/></div></div><p class="title"><strong>图 6.5. Pipeline和子流程</strong></p></div><p>子流程是从valve中发起的。下面的Valve代码启动了一个子流程。</p><div class="example"><a id="d0e5547"><!--anchor d0e5547--></a><p class="title"><strong>例 6.13. 在valve中发起一个子流程</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyNestableValve <strong class="hl-keyword" style="color: maroon">implements</strong> Valve {
    <strong class="hl-keyword" style="color: maroon">private</strong> Pipeline subPipeline;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setSubPipeline(Pipeline subPipeline) {
        <strong class="hl-keyword" style="color: maroon">this</strong>.subPipeline = subPipeline;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invoke(PipelineContext pipelineContext) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        <em class="hl-comment" style="color: green">// 发起子流程，以当前流程的pipelineContext为参数</em>
        PipelineInvocationHandle subInvocation = subPipeline.newInvocation(pipelineContext);

        subInvocation.invoke();

        System.out.println(subInvocation.isFinished());
        System.out.println(subInvocation.isBroken());

        pipelineContext.invokeNext(); <em class="hl-comment" style="color: green">// 别忘了调用后序的valves</em>
    }
}</pre><p>配置文件（<code class="filename">pipeline.xml</code>）</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;valve</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.myapp.pipeline.MyNestableValve"</span> <span class="hl-attribute" style="color: #F5844C">p:subPipeline-ref</span>=<span class="hl-value" style="color: #993300">"subPipeline"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5559"><!--anchor d0e5559--></a>6.3.3.4. 中断一个pipeline</h4></div></div></div><p>Pipeline可以被中断。当有多级子pipeline时，你可以中断到任何一级pipeline。</p><div class="example"><a id="d0e5564"><!--anchor d0e5564--></a><p class="title"><strong>例 6.14. 中断一个pipeline</strong></p><div class="example-contents"><pre class="programlisting">pipelineContext.breakPipeline(<span class="hl-number">0</span>); <em class="hl-comment" style="color: green">// level=0，中断当前pipeline</em>
pipelineContext.breakPipeline(<span class="hl-number">1</span>); <em class="hl-comment" style="color: green">// level=1，中断上一级pipeline</em>

pipelineContext.breakPipeline(<strong class="hl-string"><em style="color:navy">"label"</em></strong>); <em class="hl-comment" style="color: green">// 中断到指定label的上级pipeline</em>
<em class="hl-comment" style="color: green">// 以上调用相当于：</em>
pipelineContext.breakPipeline(pipelineContext.findLabel(<strong class="hl-string"><em style="color:navy">"label"</em></strong>));

pipelineContext.breakPipeline(Pipeline.TOP_LABEL); <em class="hl-comment" style="color: green">// 终止所有pipelines</em></pre></div></div><div class="figure"><a id="d0e5569"><!--anchor d0e5569--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/breaking-pipelines.png" alt="中断一个pipeline"/></div></div><p class="title"><strong>图 6.6. 中断一个pipeline</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5575"><!--anchor d0e5575--></a>6.3.3.5. 条件分支、循环</h4></div></div></div><p>条件分支和循环其实只不过是子流程的运用而已：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="27%" class="c1"/><col width="73%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">条件分支</td><td style="border-bottom: 0.5pt solid #6666cc; ">根据一定的条件，来决定是否要执行子流程、执行哪一个子流程（多条件分支）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">循环</td><td style="">多次执行子流程。</td></tr></tbody></table></div><p>下面的valve将子流程执行了至多10遍。如果子流程内部中断了流程，则循环终止。</p><div class="example"><a id="d0e5597"><!--anchor d0e5597--></a><p class="title"><strong>例 6.15. 将子流程循环执行10次</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> Loop10 <strong class="hl-keyword" style="color: maroon">implements</strong> Valve {
    <strong class="hl-keyword" style="color: maroon">private</strong> Pipeline loopBody;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setLoopBody(Pipeline loopBody) {
        <strong class="hl-keyword" style="color: maroon">this</strong>.loopBody = loopBody;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invoke(PipelineContext pipelineContext) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        PipelineInvocationHandle handle = loopBody.newInvocation(pipelineContext);

        <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> i = <span class="hl-number">0</span>; i &lt; <span class="hl-number">10</span> &amp;&amp; !handle.isBroken(); i++) {
            handle.invoke();
        }

        pipelineContext.invokeNext();
    }
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5602"><!--anchor d0e5602--></a>6.3.3.6. 存取pipeline的状态</h4></div></div></div><p>当一个pipeline在运行时，你可以通过<code class="code">PipelineContext</code>取得一些上下文信息：</p><div class="example"><a id="d0e5610"><!--anchor d0e5610--></a><p class="title"><strong>例 6.16. 在valve中存取pipeline的状态</strong></p><div class="example-contents"><pre class="programlisting">pipelineContext.index(); <em class="hl-comment" style="color: green">// 当前valve在pipeline中的序号</em>
pipelineContext.level(); <em class="hl-comment" style="color: green">// 当前pipeline在所有子pipeline中的级别</em>
pipelineContext.isBroken(); <em class="hl-comment" style="color: green">// 当前pipeline是否已经被中断</em>
pipelineContext.isFinished(); <em class="hl-comment" style="color: green">// 当前pipeline的所有valves是否已经执行完</em>

<em class="hl-comment" style="color: green">// 存取任意数据</em>
pipelineContext.getAttribute(key);
pipelineContext.setAttribute(key, value);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5615"><!--anchor d0e5615--></a>6.3.3.7. 现成可用的valves</h4></div></div></div><p>一般情况下，你并不需要写前面例子中的代码，因为Webx已经为你提供了一系列现成的valves来实现同样的功能。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">无条件循环 - <code class="code">&lt;loop&gt;</code></span></dt><dd><div class="example"><a id="d0e5627"><!--anchor d0e5627--></a><p class="title"><strong>例 6.17. 无条件循环</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span> <span class="hl-attribute" style="color: #F5844C">maxLoopCount</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.loop.params"><!--anchor co.valve.loop.params--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.loop.break"><!--anchor co.valve.loop.break--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.loop.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义循环变量<code class="code">loopCounterName</code>，这个变量值将被保存在<code class="code">PipelineContext</code>中，且可被其它的valve所访问。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.loop.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义<code class="code">maxLoopCount=10</code>最大循环圈数，以避免循环失控。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.loop.break"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件循环一定要和<code class="code">&lt;break&gt;</code>、<code class="code">&lt;break-if&gt;</code>或<code class="code">&lt;break-unless&gt;</code>等valve相配合。</p></td></tr></table></div></div></div></dd><dt><span class="term">条件循环 - <code class="code">&lt;while&gt;</code></span></dt><dd><div class="example"><a id="d0e5670"><!--anchor d0e5670--></a><p class="title"><strong>例 6.18. 条件循环</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;while</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"count &amp;lt;= 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.while.params"><!--anchor co.valve.while.params--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/while&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;while</strong> <span class="hl-attribute" style="color: #F5844C">maxLoopCount</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.while.maxLoop"><!--anchor co.valve.while.maxLoop--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.while.condition"><!--anchor co.valve.while.condition--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/while&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义循环变量<code class="code">loopCounterName</code>，这个变量值将被保存在<code class="code">PipelineContext</code>中，且可被其它的valve所访问。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>通过判断循环变量“<code class="code">count &lt;= 2</code>”，循环2次。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.maxLoop"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义<code class="code">maxLoopCount=10</code>，以避免循环失控。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.condition"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可以自定义任意条件。</p></td></tr></table></div></div></div></dd><dt><span class="term">单条件分支 - <code class="code">&lt;if&gt;</code></span></dt><dd><div class="example"><a id="d0e5712"><!--anchor d0e5712--></a><p class="title"><strong>例 6.19. 单条件分支</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"1 == 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.if.test"><!--anchor co.valve.if.test--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;if&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.if.condition"><!--anchor co.valve.if.condition--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.if.test"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>JEXL条件表达式。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.if.condition"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>自定义任意条件。</p></td></tr></table></div></div></div></dd><dt><span class="term">多条件分支 - <code class="code">&lt;choose&gt;&lt;when&gt;&lt;otherwise&gt;</code></span></dt><dd><div class="example"><a id="d0e5734"><!--anchor d0e5734--></a><p class="title"><strong>例 6.20. 多条件分支</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;when</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"1 == 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.choose.b1"><!--anchor co.valve.choose.b1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong> <a id="co.valve.choose.b2"><!--anchor co.valve.choose.b2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong> <a id="co.valve.choose.b3"><!--anchor co.valve.choose.b3--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.choose.b1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>条件分支1，用JEXL表达式来判断。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.choose.b2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>条件分支2，用任意条件判断。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.choose.b3"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>分支3，当所有条件均不符合时，选择该分支。</p></td></tr></table></div></div></div></dd><dt><span class="term">无条件中断 - &lt;break&gt;</span></dt><dd><div class="example"><a id="d0e5759"><!--anchor d0e5759--></a><p class="title"><strong>例 6.21. 无条件中断</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong> <a id="co.valve.break.loop1"><!--anchor co.valve.break.loop1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break /&gt;</strong> <a id="co.valve.break.level0"><!--anchor co.valve.break.level0--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong> <a id="co.valve.break.loop2"><!--anchor co.valve.break.loop2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;break</strong> <span class="hl-attribute" style="color: #F5844C">levels</span>=<span class="hl-value" style="color: #993300">"1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.break.level1"><!--anchor co.valve.break.level1--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">label</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.break.loop3"><!--anchor co.valve.break.loop3--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;break</strong> <span class="hl-attribute" style="color: #F5844C">toLabel</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.break.label"><!--anchor co.valve.break.label--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.break.level0"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件中止当前的pipeline（即loop循环<a id="co.valve.break.loop1"><!--anchor co.valve.break.loop1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>）。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.break.level1"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件中止上一层（<code class="code">levels=1</code>）的pipeline（即loop循环<a id="co.valve.break.loop2"><!--anchor co.valve.break.loop2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>）。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.break.label"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件中止指定label的pipeline（即loop循环<a id="co.valve.break.loop3"><!--anchor co.valve.break.loop3--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>）。</p></td></tr></table></div></div></div></dd><dt><span class="term">有条件中断 -
                            <code class="code">&lt;break-if&gt;</code>、<code class="code">&lt;break-unless&gt;</code></span></dt><dd><p>有条件中断是<code class="code">&lt;break&gt;</code>和<code class="code">&lt;if&gt;</code>的组合。</p><div class="example"><a id="d0e5812"><!--anchor d0e5812--></a><p class="title"><strong>例 6.22. 有条件中断</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"count &amp;gt; 2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.breakif.test"><!--anchor co.valve.breakif.test--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">label</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-if</strong> <span class="hl-attribute" style="color: #F5844C">toLabel</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.breakif.params"><!--anchor co.valve.breakif.params--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>  <a id="co.valve.breakif.condition"><!--anchor co.valve.breakif.condition--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/break-if&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-unless</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"count &amp;lt;= 2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>  <a id="co.valve.breakunless.test"><!--anchor co.valve.breakunless.test--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakif.test"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>当<code class="code">count&gt;2</code>时中断。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakif.params"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;break-if&gt;</code>和<code class="code">&lt;break-unless&gt;</code>均支持和<code class="code">&lt;break&gt;</code>类似的其它选项：<code class="code">levels</code>和<code class="code">toLabel</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakif.condition"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>和<code class="code">&lt;if&gt;</code>类似，也支持任意condition。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakunless.test"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;break-unless&gt;</code>和<code class="code">&lt;break-if&gt;</code>的条件相反：<span class="emphasis"><em>除非</em></span><code class="code">count&lt;=2</code>，否则中断。</p></td></tr></table></div></div></div></dd><dt><span class="term">无条件退出整个pipeline - <code class="code">&lt;exit&gt;</code></span></dt><dd><p>退出整个pipeline，意思是结束所有的嵌套层次。</p><div class="example"><a id="d0e5876"><!--anchor d0e5876--></a><p class="title"><strong>例 6.23. 无条件退出整个pipeline</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;exit /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div><p>对于Webx而言，<code class="code">&lt;exit&gt;</code>还有一层特殊的含义：放弃<code class="code">WebxFrameworkFilter</code>的控制权，把它交还给servlet
                                engine。以URL
                                <code class="code">http://localhost:8081/myapp/myimage.jpg</code>为例，把控制权交还给servlet
                                engine，意味着让servlet
                                    engine去显示myapp应用目录下的静态图片：<code class="filename">myimage.jpg</code>。</p></dd><dt><span class="term">异常捕获和finally处理 - <code class="code">&lt;try-catch-finally&gt;</code></span></dt><dd><p>类似Java中的<code class="code">try/catch/finally</code>结构。</p><div class="example"><a id="d0e5906"><!--anchor d0e5906--></a><p class="title"><strong>例 6.24. 异常捕获和finally处理</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;try-catch-finally&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;try&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/try&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;catch</strong> <span class="hl-attribute" style="color: #F5844C">exceptionName</span>=<span class="hl-value" style="color: #993300">"myexception"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.catch.exceptionName"><!--anchor co.valve.catch.exceptionName--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/catch&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;finally&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/finally&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/try-catch-finally&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.catch.exceptionName"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;catch&gt;</code>标签可以将捕获的异常以指定名称保存在<code class="code">PipelineContext</code>中，以便其它valve取得。</p></td></tr></table></div></div></div></dd><dt><span class="term">创建子流程 - <code class="code">&lt;sub-pipeline&gt;</code></span></dt><dd><p>单纯使用这个valve，对执行结果不会有任何影响。但可用来对较长的pipeline进行分段管理。</p><div class="example"><a id="d0e5930"><!--anchor d0e5930--></a><p class="title"><strong>例 6.25. 创建子流程</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;sub-pipeline</strong> <span class="hl-attribute" style="color: #F5844C">label</span>=<span class="hl-value" style="color: #993300">"mylabel"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/sub-pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5935"><!--anchor d0e5935--></a>6.3.3.8. 条件</h4></div></div></div><p>在前文所述的各种条件valve（例如<code class="code">&lt;if&gt;</code>、<code class="code">&lt;when&gt;</code>、<code class="code">&lt;while&gt;</code>、<code class="code">&lt;break-if&gt;</code>、<code class="code">&lt;break-unless&gt;</code>等）中，都用到一个共同的对象：condition。<code class="code">Condition</code>是一个简单的接口。</p><div class="example"><a id="d0e5958"><!--anchor d0e5958--></a><p class="title"><strong>例 6.26. <code class="code">Condition</code>接口</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> Condition {
    <strong class="hl-tag" style="color: blue">/**
     * 如满足条件，则返回&lt;code&gt;true&lt;/code&gt;。
     */</strong>
    <strong class="hl-keyword" style="color: maroon">boolean</strong> isSatisfied(PipelineStates pipelineStates);
}</pre></div></div><p>为了方便起见，Webx默认提供了一个<code class="code">JexlCondtion</code>。</p><div class="example"><a id="d0e5970"><!--anchor d0e5970--></a><p class="title"><strong>例 6.27. 使用<code class="code">JexlCondition</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;if&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;conditions:jexl-condition</strong> <span class="hl-attribute" style="color: #F5844C">expr</span>=<span class="hl-value" style="color: #993300">"loopCount == 2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;break /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong></pre><p>以上配置可以简化为：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"loopCount == 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;break /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong></pre></div></div><p>JEXL表达式是Apache的一个小项目，表达式语法详见：<a class="link" href="http://commons.apache.org/jexl/reference/syntax.html" target="_top">http://commons.apache.org/jexl/reference/syntax.html</a>。在JEXL表达式中，你可以使用<code class="code">pipelineContext.getAttribute()</code>所能取得的所有状态值。例如，loop循环时，如果你设置了<code class="code">loopCounterName</code>，那么循环计数器就可以被JEXL表达式所访问。</p><p>除此之外，Webx还提供了三个组合式的条件。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">&lt;all-of&gt;</code></span></dt><dd><p>要求所有条件均满足，相当于Java中的<code class="code">&amp;&amp;</code>操作符。</p><div class="example"><a id="d0e6004"><!--anchor d0e6004--></a><p class="title"><strong>例 6.28. <code class="code">组合式的条件：&lt;all-of&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;all-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition1 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition2 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition3 /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/all-of&gt;</strong></pre></div></div></dd><dt><span class="term"><code class="code">&lt;any-of&gt;</code></span></dt><dd><p>只要求任一条件满足，相当于Java中的<code class="code">||</code>操作符。</p><div class="example"><a id="d0e6020"><!--anchor d0e6020--></a><p class="title"><strong>例 6.29. <code class="code">组合式的条件：&lt;any-of&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;any-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition1 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition2 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition3 /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/any-of&gt;</strong></pre></div></div></dd><dt><span class="term"><code class="code">&lt;none-of&gt;</code></span></dt><dd><p>要求所有条件均不满足，相当于Java中的<code class="code">!</code>操作符。</p><div class="example"><a id="d0e6036"><!--anchor d0e6036--></a><p class="title"><strong>例 6.30. <code class="code">组合式的条件：&lt;none-of&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;none-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition1 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition2 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition3 /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/none-of&gt;</strong></pre></div></div></dd></dl></div><p>这三个组合式条件可以互相组合，以构成任意复杂的条件判断语句。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e6044"><!--anchor d0e6044--></a>6.4. 本章总结</h2></div></div></div><p>Request Contexts和Pipeline是Webx框架中的两个核心服务。它们分别从两个方面实现了原本需要由Filter来实现的功能 ── Request
            Contexts提供了包装和修改request/response的机制，而pipeline则提供了流程控制的能力。Request
            contexts和pipeline组合起来的功能比servlet
            filter机制更加强大。因为它们是基于Spring的轻量组件，其性能、配置的方便性、扩展性都优于filter。</p><p>当然，Request Contexts和Pipeline并不想取代filter。在好几种场合，filter仍然是唯一的选择：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>如果你既想要修改request/response，又想要控制流程；</p></li><li class="listitem"><p>如果你希望独立于任何框架。 </p></li></ul></div><p>但在你接到一个需求，正打算用filter来实现之前，请考虑一下，是否可以采用Webx所提供的这两种机制来取代。倘若可行，必然会带来更多的好处。</p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.requestcontexts"><!--anchor webx.requestcontexts--></a>第 7 章 Request Contexts功能指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#webx3.requestcontexts.basic">7.1. <code class="code">&lt;basic&gt;</code> - 提供基础特性</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6148">7.1.1. 拦截器接口</a></span></dt><dt><span class="section"><a href="#d0e6263">7.1.2. 默认拦截器</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.setlocale">7.2. <code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6310">7.2.1. Locale基础</a></span></dt><dt><span class="section"><a href="#d0e6385">7.2.2. Charset编码基础</a></span></dt><dt><span class="section"><a href="#d0e6456">7.2.3. Locale和charset的关系</a></span></dt><dt><span class="section"><a href="#d0e6620">7.2.4. 设置locale和charset</a></span></dt><dt><span class="section"><a href="#d0e6788">7.2.5. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.parser">7.3. <code class="code">&lt;parser&gt;</code> - 解析参数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7126">7.3.1. 基本使用方法</a></span></dt><dt><span class="section"><a href="#d0e7262">7.3.2. 上传文件</a></span></dt><dt><span class="section"><a href="#d0e7441">7.3.3. 高级选项</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.buffered">7.4. <code class="code">&lt;buffered&gt;</code> - 缓存response中的内容</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7851">7.4.1. 实现原理</a></span></dt><dt><span class="section"><a href="#d0e7918">7.4.2. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.lazycommit">7.5. <code class="code">&lt;lazy-commit&gt;</code> - 延迟提交response</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8029">7.5.1. 什么是提交</a></span></dt><dt><span class="section"><a href="#d0e8073">7.5.2. 实现原理</a></span></dt><dt><span class="section"><a href="#d0e8092">7.5.3. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="#webx3.requestcontexts.rewrite">7.6. <code class="code">&lt;rewrite&gt;</code> -重写请求的URL和参数</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8198">7.6.1. 概述</a></span></dt><dt><span class="section"><a href="#d0e8268">7.6.2. 取得路径</a></span></dt><dt><span class="section"><a href="#d0e8308">7.6.3. 匹配rules</a></span></dt><dt><span class="section"><a href="#d0e8375">7.6.4. 匹配conditions</a></span></dt><dt><span class="section"><a href="#d0e8723">7.6.5. 替换路径</a></span></dt><dt><span class="section"><a href="#d0e8827">7.6.6. 替换参数</a></span></dt><dt><span class="section"><a href="#d0e8904">7.6.7. 后续操作 </a></span></dt><dt><span class="section"><a href="#d0e8971">7.6.8. 重定向</a></span></dt><dt><span class="section"><a href="#d0e9047">7.6.9. 自定义处理器</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9067">7.7. 本章总结</a></span></dt></dl></div><p>在<a class="xref" href="#webx.filter.requestcontexts.pipeline" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>中，我们已经介绍了Request
        Contexts服务的作用和原理。本章我们将介绍除了session机制以外，每一个可用的Request
            Context的功能和用法。由于Session机制比较复杂，所以我们另辟单独的一章（<a class="xref" href="#webx.requestcontext.session" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>）来解释它。</p><p>本章涉及的内容包括： </p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="16%" class="c1"/><col width="33%" class="c2"/><col width="51%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">接口</th><th style="border-bottom: 0.5pt solid #6666cc; ">功能</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;basic&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">BasicRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">提供基础安全特性，例如：过滤response headers、cookies，限制cookie的大小等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;set-locale&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">SetLocaleRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">设置locale区域和charset字符集编码。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;parser&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">ParserRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">解析参数，支持<code class="code">multipart/form-data</code>（即上传文件请求）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;buffered&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">BufferedRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">缓存response中的内容。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;lazy-commit&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">LazyCommitRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">延迟提交response。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;rewrite&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">RewriteRequestContext</code></td><td style="" valign="middle">重写请求的URL和参数。</td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.basic"><!--anchor webx3.requestcontexts.basic--></a>7.1. <code class="code">&lt;basic&gt;</code> - 提供基础特性</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6148"><!--anchor d0e6148--></a>7.1.1. 拦截器接口</h3></div></div></div><p><code class="code">BasicRequestContext</code>提供了一组interceptors拦截器接口，通过它们，你可以拦截并干预一些事件。</p><div class="figure"><a id="d0e6155"><!--anchor d0e6155--></a><div class="figure-contents"><div class="mediaobject"><img src="images/requestcontexts/basic-rc.png" alt="BasicRequestContext所提供的拦截器"/></div></div><p class="title"><strong>图 7.1. <code class="code">BasicRequestContext</code>所提供的拦截器</strong></p></div><p>你可以在<code class="code">&lt;basic&gt;</code>中指定上图所示的任何一个<code class="code">Interceptor</code>接口，以便干预特定的事件：</p><div class="table"><a id="d0e6171"><!--anchor d0e6171--></a><p class="title"><strong>表 7.1. <code class="code">BasicRequestContext</code>所提供的拦截器</strong></p><div class="table-contents"><table summary="BasicRequestContext所提供的拦截器" cellpadding="10" style="border: none;"><colgroup><col width="43%" class="c1"/><col width="57%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">拦载器接口</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <code class="code">RequestContextLifecycleInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截“预处理（prepare）”和“提交（commit）”事件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <code class="code">ResponseHeaderInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对response header的修改。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">HeaderNameInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对header的修改、添加操作。可修改header name，或拒绝对header的修改。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">HeaderValueInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对header的修改、添加操作。可修改header value，或拒绝对header的修改。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">CookieInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对cookie的添加操作。可修改或拒绝cookie对象。需要注意的是，有两种方法可以添加cookie：通过cookie对象，或者直接写response
                                    header。对于后者，需要使用<code class="code">CookieHeaderValueInterceptor</code>才能拦截得到。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">CookieHeaderValueInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有通过添加header来创建cookie的操作。可修改或拒绝该cookie。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">RedirectLocaitonInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有外部重定向的操作。可修改或拒绝重定向URL。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">StatusMessageInterceptor</code>
                            </td><td style="" valign="middle">拦截所有设置status message的操作。可以修改或拒绝该message。</td></tr></tbody></table></div></div><p>通过下面的配置，就可以指定任意多个interceptor的实现。</p><div class="example"><a id="d0e6255"><!--anchor d0e6255--></a><p class="title"><strong>例 7.1. 配置interceptors（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;request-contexts:interceptors</strong>
            <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts/basic/interceptors"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/request-contexts:interceptors&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/basic&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6263"><!--anchor d0e6263--></a>7.1.2. 默认拦截器</h3></div></div></div><p>即使你不加说明，<code class="code">BasicRequestContext</code>也总是会启用一个默认的interceptor实现：<code class="code">ResponseHeaderSecurityFilter</code>。这个类实现了下列功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>避免header name和value中出现CRLF字符 ──
                            在header中嵌入CRLF（回车换行）字符是一种常见的攻击手段。攻击者嵌入CRLF以后，使服务器对HTTP请求发生错误判断，从而执行攻击者的恶意代码。事实上，现在的servlet引擎如tomcat已经可以防御这种攻击。但作为框架，并不能依赖于特定的servlet引擎，所以加上这个额外的安全检查，确保万无一失。</p></li><li class="listitem"><p>将status message用HTML entity编码重写 ── 通常status
                            message会被显示在HTML页面中。攻击者可以利用这一点在页面中嵌入恶意代码。将status message以HTML
                            entity编码重写以后，就可以避免这个问题。</p></li><li class="listitem"><p>限制cookie的总大小 ──
                            过大的cookie可能使WEB服务器拒绝响应请求。攻击者同样可以利用这一点使用户无法正常访问网站。限制cookie的总大小可以部分地解决这种危机。</p></li></ul></div><p>如果需要，你可以对<code class="code">ResponseHeaderSecurityFilter</code>指定一些参数。</p><div class="example"><a id="d0e6289"><!--anchor d0e6289--></a><p class="title"><strong>例 7.2. 配置<code class="code">ResponseHeaderSecurityFilter</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;request-contexts:interceptors</strong>
            <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts/basic/interceptors"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;response-header-security-filter</strong> <span class="hl-attribute" style="color: #F5844C">maxSetCookieSize</span>=<span class="hl-value" style="color: #993300">"5K"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/request-contexts:interceptors&gt;</strong></pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.setlocale"><!--anchor webx3.requestcontexts.setlocale--></a>7.2. <code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码</h2></div></div></div><p>区域和编码问题（尤其是后者）是每个WEB应用都必须处理好的基本问题。它虽然本身并不复杂，但是在现实开发中，由于涉及面很广，一旦发生问题（例如乱码）经常让人手足无措。<code class="code">&lt;set-locale&gt;</code>提供了一个机制，确保Web应用能够设置正确的区域和编码。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6310"><!--anchor d0e6310--></a>7.2.1. Locale基础</h3></div></div></div><p>Locale是国际化的基础。</p><p>一个locale的格式是：<code class="code">language_country_variant</code>，例如：<code class="code">zh_CN</code>、<code class="code">zh_TW</code>、<code class="code">en_US</code>、<code class="code">es_ES_Traditional_WIN</code>等。</p><p>Java和框架根据不同的locale，可以取得不同的文本、对象。下面的Java代码根据不同的locale，取得不同语言版本的文字： </p><div class="example"><a id="d0e6334"><!--anchor d0e6334--></a><p class="title"><strong>例 7.3. 利用<code class="code">ResourceBundle</code>和locale取得国际化字符</strong></p><div class="example-contents"><pre class="programlisting">Locale.setDefault(Locale.US);

String s1 = getResourceBundle(Locale.CHINA).getString(<strong class="hl-string"><em style="color:navy">"happy"</em></strong>); <em class="hl-comment" style="color: green">// 快乐</em>
String s2 = getResourceBundle(Locale.TAIWAN).getString(<strong class="hl-string"><em style="color:navy">"happy"</em></strong>); <em class="hl-comment" style="color: green">// 快樂</em>
String s3 = getResourceBundle(Locale.US).getString(<strong class="hl-string"><em style="color:navy">"happy"</em></strong>); <em class="hl-comment" style="color: green">// happy</em>
...
ResourceBundle getResourceBundle(Locale locale) {
    <strong class="hl-keyword" style="color: maroon">return</strong> ResourceBundle.getBundle(<strong class="hl-string"><em style="color:navy">"ApplicationResources"</em></strong>, locale);
}</pre><p>其中所用到的<code class="code">ResourceBundle</code>文件定义如下：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="filename">ApplicationResources.properties</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">happy </span>= happy</pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="filename">ApplicationResources_zh_CN.properties</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">happy </span>= \u5FEB\u4E50</pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="filename">ApplicationResources_zh_TW.properties</code>
                                </td><td style="">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">happy </span>= \u5FEB\u6A02</pre>
                                </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6385"><!--anchor d0e6385--></a>7.2.2. Charset编码基础</h3></div></div></div><p>Charset全称Character
                    Encoding或字符集编码。Charset是将字符（characters）转换成字节（bytes）或者将字节转换成字符的算法。Java内部采用unicode来表示一个字符。将unicode字符转换成字节的过程，称为“<span class="emphasis"><em>编码</em></span>”；将字节恢复成unicode字符的过程，称为“<span class="emphasis"><em>解码</em></span>”。</p><p>浏览器发送给WEB应用的request参数，是以字节流的方式来表示的。Request参数必须经过解码才能被Java程序所解读。用来解码request参数的charset被称为“<span class="emphasis"><em>输入字符集编码（Input
                    Charset）</em></span>”；</p><p>WEB应用返回给浏览器的response响应内容必须编码成字节流，才能被浏览器或客户端解读。用来编码response内容的charset被称为“<span class="emphasis"><em>输出字符集编码（Output
                    Charset）</em></span>”。</p><p>一般情况下，input charset和output
                    charset是相同的。因为浏览器发送表单数据时，总是采用当前页面的charset来编码的。例如，有一个表单页面，它的“<code class="code">contentType=text/html;
                    charset=GBK</code>”，那么用户填完全表单并提交时，浏览器会以<code class="code">GBK</code>来编码用户所输入的表单数据。如果input
                charset和output charset不相同，服务器就不能正确解码浏览器根据output charset所发回给WEB应用的表单数据。</p><p>然而有一些例外情况下面，输入和输出的charset可能会不同：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>通过Java
                            Script发送的表单，总是用<code class="code">UTF-8</code>编码的。这意味着你必须用<code class="code">UTF-8</code>作为input
                            charset方能正确解码参数。这样，除非output
                            charset也是<code class="code">UTF-8</code>，否则两者就是不同的。</p></li><li class="listitem"><p>应用间互相用HTTP访问时，可能采用不同的编码。例如，应用A以<code class="code">UTF-8</code>访问应用B，而应用B是以<code class="code">GBK</code>作为input/output
                            charset的。此时会产生参数解码的错误。</p></li><li class="listitem"><p>直接在浏览器地址栏里输入包含参数的URL，根据不同的浏览器和操作系统的设置，会有不同的结果：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>例如，中文Windows中，无论ie还是firefox，经试验，默认都以<code class="code">GBK</code>来编码参数。IE对直接输入的参数，连URL
                                        encoding也没做。</p></li><li class="listitem"><p>而在mac系统中，无论safari还是firefox，经试验，默认都是以<code class="code">UTF-8</code>来编码参数。
                                    </p></li></ul></div></li></ul></div><p>框架必须要能够应付上面各种不确定的charset编码。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6456"><!--anchor d0e6456--></a>7.2.3. Locale和charset的关系</h3></div></div></div><p>Locale和charset是相对独立的两个参数，但是又有一定的关系。</p><p>Locale决定了要显示的文字的语言，而charset则将这种语言的文字编码成bytes或从bytes解码成文字。因此，charset必须能够涵盖locale所代表的语言文字，如果不能，则可能出现乱码。下表列举了一些locale和charset的组合：</p><div class="table"><a id="d0e6463"><!--anchor d0e6463--></a><p class="title"><strong>表 7.2. Locale和Charset的关系</strong></p><div class="table-contents"><table summary="Locale和Charset的关系" cellpadding="10" style="border: none;"><colgroup><col width="40%" align="center" class="c1"/><col width="16%" align="center" class="c2"/><col width="8%" align="center" class="c3"/><col width="8%" align="center" class="c4"/><col width="8%" align="center" class="c5"/><col width="12%" align="center" class="c6"/><col width="8%" align="center" class="c7"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; " rowspan="2" align="center" valign="middle">Locale</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">英文字符集</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " colspan="3" align="center" valign="middle">中文字符集</th><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2" align="center" valign="middle">全字符集</th></tr><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">ISO-8859-1</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">GB2312</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">Big5</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">GBK</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">GB18030</code>
                            </th><th style="border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">UTF-8</code>
                            </th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"><code class="code">en_US</code>（美国英文）</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"><code class="code">zh_CN</code>（简体中文）</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle"><code class="code">zh_TW</code>、<code class="code">zh_HK</code>（台湾中文、香港中文）</td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="" align="center" valign="middle">√</td></tr></tbody></table></div></div><p>在所有charset中，有几个“全能”编码：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">UTF-8</code></span></dt><dd><p>涵盖了unicode中的所有字符。然而用<code class="code">UTF-8</code>来编码中文为主的页面时，每个中文会占用3个字节。建议以非中文为主的页面采用<code class="code">UTF-8</code>编码。</p></dd><dt><span class="term"><code class="code">GB18030</code></span></dt><dd><p>中文国际标准，和<code class="code">UTF-8</code>一样，涵盖了unicode中的所有字符。用<code class="code">GB18030</code>来编码中文为主的页面时有一定优势，因为绝大多数常用中文仅占用2个字节，比<code class="code">UTF-8</code>短1/3。然而<code class="code">GB18030</code>在非中文的操作系统中，有可能不能识别，其通用性不如<code class="code">UTF-8</code>好。因此仅建议以中文为主的页面采用<code class="code">GB18030</code>编码。</p></dd><dt><span class="term"><code class="code">GBK</code></span></dt><dd><p>严格说，<code class="code">GBK</code>不是全能编码（例如对很多西欧字符就支持不好），也不是国际标准。但它支持的字符数量接近于<code class="code">GB18030</code>。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6620"><!--anchor d0e6620--></a>7.2.4. 设置locale和charset</h3></div></div></div><p>在Servlet API中，以下API是和locale和charset有关的。</p><div class="table"><a id="d0e6625"><!--anchor d0e6625--></a><p class="title"><strong>表 7.3. 和locale、charset相关的servlet API</strong></p><div class="table-contents"><table summary="和locale、charset相关的servlet API" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="35%" class="c1"/><col width="27%" class="c2"/><col width="38%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3"><code class="code">HttpServletRequest</code></th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getCharacterEncoding()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">读取输入编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setCharacterEncoding(charset)</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">设置输入编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>必须在第一次调用<code class="code">request.getParameter()</code>
                                                和<code class="code">request.getParameterMap()</code>前设置，否则无效。</p></li><li class="listitem"><p>如果不设置，则默认以<code class="code">ISO-8859-1</code>来解码参数。</p></li><li class="listitem"><p>一般只影响POST请求参数的解码，但这里有一些复杂性，参见<a class="xref" href="#webx3.requestcontexts.parser" title="7.3. &lt;parser&gt; - 解析参数">第 7.3 节 “<code class="code">&lt;parser&gt;</code> - 解析参数”</a>。</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getLocale()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得Accept-Language中浏览器首选的locale</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getLocales()</code></td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">取得所有Accept-Language中所指定的locales</td><td style="" valign="middle"> </td></tr></tbody></table><table summary="和locale、charset相关的servlet API" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="35%" class="c1"/><col width="27%" class="c2"/><col width="38%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3"><code class="code">HttpServletResponse</code></th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getCharacterEncoding()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得输出编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setCharacterEncoding(charset)</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">设置输出编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Since Servlet 2.4</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getContentType()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得content type</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Since Servlet 2.4</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setContentType(contentType)</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">设置content type</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Content type中可能包含charset定义，例如：<code class="code">text/html;
                                                charset=GBK</code></p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getLocale()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得输出locale</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setLocale(locale)</code></td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">设置输出locale</td><td style="" valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>必须在response被commit之前调用，否则无效。</p></li><li class="listitem"><p>它同时也会设置charset，除非content
                                            type已经被设置过，并用包含了charset的定义。</p></li></ul></div>
                            </td></tr></tbody></table></div></div><p>设置locale和charset是一件看起来容易，做起来不容易的事：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>输入编码必须<span class="emphasis"><em>在第一个读取request参数的调用之前</em></span>设置好，否则就无效。只有把<code class="code">&lt;set-locale&gt;</code>作为Request
                            Contexts服务的一环，才有可能确保读取request参数之前，设置好输入编码。</p></li><li class="listitem"><p>在Servlet 2.3之前，设置输出参数的唯一方法，是通过设置带有charset定义的content type。这一点在Servlet
                                2.4以后得到改进，添加了独立的设置输出编码的方法。<code class="code">&lt;set-locale&gt;</code>弥补了Servlet
                            2.3和Servlet 2.4之间的差异，使WEB应用在所有的环境下，都可以独立设置content type和charset。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6788"><!--anchor d0e6788--></a>7.2.5. 使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6791"><!--anchor d0e6791--></a>7.2.5.1. 使用默认值</h4></div></div></div><div class="example"><a id="d0e6794"><!--anchor d0e6794--></a><p class="title"><strong>例 7.4. 设置默认的locale和charset</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"GB18030"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div><p>上面的配置，将WEB应用的输入charset、输出charset均设置成<code class="code">GB18030</code>，将输出locale设置成<code class="code">zh_CN</code>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6807"><!--anchor d0e6807--></a>7.2.5.2. 临时覆盖默认的charset</h4></div></div></div><p>前面讲到在一些情况下面，服务器所收到的参数（表单数据）不是用应用默认的charset来编码的。例如Java
                        Script总是以<code class="code">UTF-8</code>来提交表单；系统间通过HTTP协议通信；或者用户直接在浏览器地址栏中输入参数。</p><p>如何应付这些不确定的charset呢？<code class="code">&lt;set-locale&gt;</code>提供的方法是，在URL中指定输入编码，并覆盖默认值。</p><p>假设当前应用的默认值是<code class="code">defaultLocale=zh_CN</code>、<code class="code">defaultCharset=GB18030</code>，那么下面的请求将使用默认的<code class="code">GB18030</code>来解码参数，并用默认的<code class="code">GB18030</code>来输出页面：</p><pre class="screen">http://localhost:8081/myapp/myform</pre><p>假如你希望改用<code class="code">UTF-8</code>来解码参数，那么可以使用下面的URL来覆盖默认值：</p><div class="example"><a id="d0e6841"><!--anchor d0e6841--></a><p class="title"><strong>例 7.5. 在URL中覆盖默认的input charset</strong></p><div class="example-contents"><pre class="screen">http://localhost:8081/myapp/myform<span class="emphasis"><em>?_input_charset=UTF-8</em></span></pre></div></div><p>这样，Webx将采用<code class="code">UTF-8</code>来解码参数，但<span class="emphasis"><em>仍然使用默认的<code class="code">GB18030</code>来输出页面</em></span>。</p><p>需要注意的是，对于POST请求，你必须把<code class="code">_input_charset</code>这个特殊的参数写在URL中，而不能写成普通的表单字段，例如：</p><div class="example"><a id="d0e6864"><!--anchor d0e6864--></a><p class="title"><strong>例 7.6. 在POST表单中覆盖默认的input charset</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">"http://localhost:8081/myapp/myform?_input_charset=UTF-8"</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"POST"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.charset.override.post"><!--anchor co.charset.override.post--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"param1"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"value1"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"param2"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"value2"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.charset.override.post"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>必须把<code class="code">_input_charset</code>这个特殊的参数写在URL中，即便是POST类型的表单。</p></td></tr></table></div></div></div><p>在写AJAX Java Script代码时，也要注意：</p><div class="example"><a id="d0e6880"><!--anchor d0e6880--></a><p class="title"><strong>例 7.7. 在AJAX代码中覆盖默认的input charset</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">var</strong> xhreq = <strong class="hl-keyword" style="color: maroon">new</strong> XMLHttpRequest();
xhreq.open(<strong class="hl-string"><em style="color:navy">"post"</em></strong>, <strong class="hl-string"><em style="color:navy">"/myapp/myform?_input_charset=UTF-8"</em></strong>, true); <a id="co.charset.override.ajax"><!--anchor co.charset.override.ajax--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
...
xhreq.send(<strong class="hl-string"><em style="color:navy">"a=1&amp;b=2"</em></strong>);</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.charset.override.ajax"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>必须把<code class="code">_input_charset</code>这个特殊的参数写在URL中。</p></td></tr></table></div></div></div><p>此外，<code class="code">&lt;set-locale&gt;</code>也提供了临时覆盖输出编码的方法：</p><div class="example"><a id="d0e6899"><!--anchor d0e6899--></a><p class="title"><strong>例 7.8. 在URL中覆盖默认的output charset</strong></p><div class="example-contents"><pre class="screen">http://localhost:8081/myapp/myform<span class="emphasis"><em>?_output_charset=UTF-8</em></span></pre></div></div><p>临时覆盖的输入、输出编码只会影响当前请求，它不会被记住。当一个不带有覆盖参数的请求进来时，将仍然按照默认值来设置输入、输出编码。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6908"><!--anchor d0e6908--></a>7.2.5.3. 持久覆盖默认的locale和charset</h4></div></div></div><p>还有一种需求，就是多语言网页的支持。用户可以选择自己的语言：简体中文、繁体中文等。一旦用户作出选择，那么后续的网页将全部以用户所选择的语言和编码来显示。<code class="code">&lt;set-locale&gt;</code>直接支持这个功能。只要你按下面的URL访问页面，用户的语言和编码即被切换成简体中文和<code class="code">UTF-8</code>编码。</p><div class="example"><a id="d0e6919"><!--anchor d0e6919--></a><p class="title"><strong>例 7.9. 持久覆盖默认的locale和charset</strong></p><div class="example-contents"><pre class="screen">http://localhost:8081/myapp<span class="emphasis"><em>?_lang=zh_CN:UTF-8</em></span></pre></div></div><p>参数值<code class="code">_lang=zh_CN:UTF-8</code>将被保存在session中，后续的请求不需要再次指定<code class="code">_lang</code>参数。用户所作出的选择将一直持续在整个session中，直到session被作废。</p><p>需要说明的是，假如我们采用了<code class="code">&lt;session&gt;</code> request
                    context来取代原来的session机制，那么该参数实际的保存位置将取决于session框架的设置 ──
                        例如：你可以把参数值保存在某个cookie中。然而，<code class="code">&lt;set-locale&gt;</code>并不需要关心于session的实现细节或是用来保存参数的cookie的细节。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6942"><!--anchor d0e6942--></a>7.2.5.4. <code class="code">&lt;set-locale&gt;</code>的影响力</h4></div></div></div><p><code class="code">&lt;set-locale&gt;</code>所设置的<span class="emphasis"><em>输出locale</em></span>和<span class="emphasis"><em>输出charset</em></span>值将会被保存在当前线程中，从而对整个线程产生影响。</p><div class="table"><a id="d0e6957"><!--anchor d0e6957--></a><p class="title"><strong>表 7.4. 被&lt;set-locale&gt;影响的API</strong></p><div class="table-contents"><table summary="被&lt;set-locale&gt;影响的API" cellpadding="10" style="border: none;"><colgroup><col width="43%" class="c1"/><col width="57%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">API</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">LocaleUtil.getContext().getLocale()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="2">可以通过这两个方法取得当前线程的输出locale和charset。Webx框架中凡是要用到默认locale和charset的地方，都会从这里去取得值。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">LocaleUtil.getContext().getCharset()</code>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">StringEscapeUtil.escapeURL()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="2">Webx调用这两个方法进行URL编码、解码时，不需要指定charset（不同于JDK的<code class="code">URLEncoder</code>/<code class="code">URLDecoder</code>）。这两个函数将从<code class="code">LocaleUtil.getContext().getCharset()</code>中取得当前线程的输出charset。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">StringEscapeUtil.unescapeURL()</code>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">TemplateService</code>
                                </td><td style=""><code class="code">TemplateService</code>如果指定了<code class="code">searchLocalizedTemplates=true</code>参数，那么它会利用当前线程的locale来搜索本地化的模板，例如：
                                        <code class="code">screen/myTemplate_zh_CN.vm</code></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7022"><!--anchor d0e7022--></a>7.2.5.5. <code class="code">&lt;set-locale&gt;</code>的配置参数</h4></div></div></div><div class="example"><a id="d0e7027"><!--anchor d0e7027--></a><p class="title"><strong>例 7.10. <code class="code">&lt;set-locale&gt;</code>的配置参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"..."</span>
            <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"..."</span>
            <span class="hl-attribute" style="color: #F5844C">inputCharsetParam</span>=<span class="hl-value" style="color: #993300">"_input_charset"</span>
            <span class="hl-attribute" style="color: #F5844C">outputCharsetParam</span>=<span class="hl-value" style="color: #993300">"_output_charset"</span>
            <span class="hl-attribute" style="color: #F5844C">paramKey</span>=<span class="hl-value" style="color: #993300">"_lang"</span>
            <span class="hl-attribute" style="color: #F5844C">sessionKey</span>=<span class="hl-value" style="color: #993300">"_lang"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><div class="table"><a id="d0e7034"><!--anchor d0e7034--></a><p class="title"><strong>表 7.5. <code class="code">&lt;set-locale&gt;</code>配置参数说明</strong></p><div class="table-contents"><table summary="&lt;set-locale&gt;配置参数说明" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">defaultLocale</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">默认locale。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">defaultCharset</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">默认charset。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">inputCharsetParam</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">用来临时改变输入charset的参数名，支持多个名称，以“<code class="code">|</code>”分隔，例如“<code class="code">_input_charset|ie</code>”。
                                        默认值为“<code class="code">_input_charset</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">outputCharsetParam</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">用来临时改变输出charset的参数名，支持多个名称，以“<code class="code">|</code>”分隔，例如“<code class="code">_output_charset|oe</code>”。
                                        默认为“<code class="code">_output_charset</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">paramKey</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">用来持久改变输出locale和charset的参数名，默认为“<code class="code">_lang</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">sessionKey</code>
                                </td><td style="">用来在session中保存用户所选择的locale和charset的key，默认为“<code class="code">_lang</code>”。</td></tr></tbody></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.parser"><!--anchor webx3.requestcontexts.parser--></a>7.3. <code class="code">&lt;parser&gt;</code> - 解析参数</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7126"><!--anchor d0e7126--></a>7.3.1. 基本使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7129"><!--anchor d0e7129--></a>7.3.1.1. 基本配置</h4></div></div></div><div class="example"><a id="d0e7132"><!--anchor d0e7132--></a><p class="title"><strong>例 7.11. <code class="code">&lt;parser&gt;</code>基本配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span> <span class="hl-attribute" style="color: #F5844C">fileSizeMax</span>=<span class="hl-value" style="color: #993300">"2M"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>绝大多数情况，你只需要上面的配置就足够了 ── <code class="code">&lt;parser&gt;</code>会自动解析所有类型的请求，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GET请求</p></li><li class="listitem"><p>普通的POST请求（Content
                                    Type：<code class="code">application/x-www-form-urlencoded</code>）</p></li><li class="listitem"><p>可上传文件的POST请求（Content Type：<code class="code">multipart/form-data</code>）</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7160"><!--anchor d0e7160--></a>7.3.1.2. 通过<code class="code">HttpServletRequest</code>接口访问参数</h4></div></div></div><p><code class="code">&lt;parser&gt;</code>对于大部分应用是透明的。也就是说，你不需要知道<code class="code">&lt;parser&gt;</code>的存在，就可以访问所有的参数，包括访问<code class="code">multipart/form-data</code>请求的参数。</p><div class="example"><a id="d0e7176"><!--anchor d0e7176--></a><p class="title"><strong>例 7.12. 通过<code class="code">HttpServletRequest</code>接口访问参数</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
HttpServletRequest request;

...
String s = request.getParameter(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7184"><!--anchor d0e7184--></a>7.3.1.3. 通过<code class="code">ParserRequestContext</code>接口访问参数</h4></div></div></div><p>你也可以选择使用<code class="code">ParserRequestContext</code>接口。</p><div class="example"><a id="d0e7195"><!--anchor d0e7195--></a><p class="title"><strong>例 7.13. 通过<code class="code">ParserRequestContext</code>接口访问参数</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
ParserRequestContext parser;

...
String s = parser.getParameters().getString(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div><p>和<code class="code">HttpServletRequest</code>接口相比，<code class="code">ParserRequestContext</code>提供了如下便利：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">直接取得指定类型的参数，例如：直接取得<code class="code">int</code>、<code class="code">boolean</code>值等。</span></dt><dd><div class="example"><a id="d0e7222"><!--anchor d0e7222--></a><p class="title"><strong>例 7.14. 直接取得指定类型的参数</strong></p><div class="example-contents"><pre class="programlisting"><em class="hl-comment" style="color: green">// myparam=true, myparam=false</em>
parser.getParameters().getBoolean(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);

<em class="hl-comment" style="color: green">// myparam=123</em>
parser.getParameters().getInt(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div></dd><dt><span class="term">如果参数值未提供，或者值为空，则返回指定默认值。</span></dt><dd><div class="example"><a id="d0e7231"><!--anchor d0e7231--></a><p class="title"><strong>例 7.15. 取得参数的默认值</strong></p><div class="example-contents"><pre class="programlisting">parser.getParameters().getBoolean(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, false);
parser.getParameters().getString(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, <strong class="hl-string"><em style="color:navy">"no_value"</em></strong>);
parser.getParameters().getInt(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, -<span class="hl-number">1</span>);</pre></div></div></dd><dt><span class="term">取得上传文件的<code class="code">FileItem</code>对象（这是Apache Jakarta
                                项目commons-fileupload所定义的接口）。</span></dt><dd><div class="example"><a id="d0e7243"><!--anchor d0e7243--></a><p class="title"><strong>例 7.16. 取得<code class="code">FileItem</code>上传文件</strong></p><div class="example-contents"><pre class="programlisting">FileItem fileItem = parser.getParameters().getFileItem(<strong class="hl-string"><em style="color:navy">"myfile"</em></strong>);
FileItem[] fileItems = parser.getParameters().getFileItems(<strong class="hl-string"><em style="color:navy">"myfile"</em></strong>);</pre></div></div></dd><dt><span class="term"><code class="code">ParserRequestContext</code>还提供了比较方便的访问cookie值的方法。</span></dt><dd><div class="example"><a id="d0e7257"><!--anchor d0e7257--></a><p class="title"><strong>例 7.17. 访问cookie值</strong></p><div class="example-contents"><pre class="programlisting">parser.getCookies().getString(<strong class="hl-string"><em style="color:navy">"mycookie"</em></strong>);</pre></div></div></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7262"><!--anchor d0e7262--></a>7.3.2. 上传文件</h3></div></div></div><p>用于上传文件的请求是一种叫作<code class="code">multipart/form-data</code>的特殊请求，它的格式类似于富文本电子邮件的样子。下面HTML创建了一个支持上传文件的表单：</p><div class="example"><a id="d0e7270"><!--anchor d0e7270--></a><p class="title"><strong>例 7.18. 创建<code class="code">multipart/form-data</code>表单</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"post"</span> <span class="hl-attribute" style="color: #F5844C">enctype</span>=<span class="hl-value" style="color: #993300">"multipart/form-data"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"file"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myfile"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">""</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre></div></div><p>提示：不是只有需要上传文件时，才可以用<code class="code">multipart/form-data</code>表单。<span class="emphasis"><em>假如你的表单中包含富文本字段（即字段的内容是以
                        HTML或类似的技术描述的），特别是当字段的内容比较长的时候，用<code class="code">multipart/form-data</code>比用普通的表单更高效，生成的HTTP请求也更短</em></span>。</p><p>只要upload服务存在，那么<code class="code">&lt;parser&gt;</code>就可以解析<code class="code">multipart/form-data</code>（即上传文件）的请求。Upload服务扩展于Apache
                Jakarta的一个项目：commons-fileupload。 </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7297"><!--anchor d0e7297--></a>7.3.2.1. 配置Upload服务</h4></div></div></div><div class="example"><a id="d0e7300"><!--anchor d0e7300--></a><p class="title"><strong>例 7.19. Upload服务的配置参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span>
                 <span class="hl-attribute" style="color: #F5844C">fileSizeMax</span>=<span class="hl-value" style="color: #993300">"2M"</span>
                 <span class="hl-attribute" style="color: #F5844C">repository</span>=<span class="hl-value" style="color: #993300">"/tmp"</span>
                 <span class="hl-attribute" style="color: #F5844C">sizeThreshold</span>=<span class="hl-value" style="color: #993300">"10K"</span>
                 <span class="hl-attribute" style="color: #F5844C">keepFormFieldInMemory</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>各参数的说明如下：</p><div class="table"><a id="d0e7307"><!--anchor d0e7307--></a><p class="title"><strong>表 7.6. Upload服务配置参数说明</strong></p><div class="table-contents"><table summary="Upload服务配置参数说明" cellpadding="10" style="border: none;"><colgroup><col width="33%" class="c1"/><col width="67%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">sizeMax</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">HTTP请求的最大尺寸（字节，支持K/M/G），超过此尺寸的请求将被抛弃。值<code class="code">-1</code>表示没有限制。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">fileSizeMax</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">单个文件允许的最大尺寸（字节，支持K/M/G），超过此尺寸的文件将被抛弃。值<code class="code">-1</code>表示没有限制。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">repository</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">暂存上传文件的目录。 注意，这个目录是用Spring
                                        <code class="code">ResourceLoader</code>装载的，而不是一个物理路径。关于<code class="code">ResourceLoader</code>，详见ResourceLoading服务的文档。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">sizeThreshold</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">将文件放在内存中的阈值（字节，支持K/M/G），小于此值的文件被保存在内存中。 </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">keepFormFieldInMemory</code>
                                </td><td style="">是否将普通的form field保持在内存里？
                                        默认为<code class="code">false</code>，但当<code class="code">sizeThreshold</code>为<code class="code">0</code>时，默认为<code class="code">true</code>。</td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>当上传文件的请求的总尺寸超过<code class="code">sizeMax</code>的值时，整个请求将被抛弃 ——
                            这意味着你不可能读到请求中的其它任何参数。而当某个上传文件的尺寸超出<code class="code">fileSizeMax</code>的限制，但请求的总尺寸仍然在<code class="code">sizeMax</code>的范围内时，只有超出该尺寸的单个上传文件被抛弃，而你还是可以读到其余的参数。</p></td></tr></table></div><p>假如有多个upload服务（当然这种情况极少），你也可以明确指定<code class="code">&lt;parser&gt;</code>使用哪个upload服务：</p><div class="example"><a id="d0e7401"><!--anchor d0e7401--></a><p class="title"><strong>例 7.20. 明确指定upload服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">uploadServiceRef</span>=<span class="hl-value" style="color: #993300">"myUpload"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7406"><!--anchor d0e7406--></a>7.3.2.2. 手工解析上传请求</h4></div></div></div><p>在默认情况下，当<code class="code">&lt;parser&gt;</code>收到一个上传文件的请求时，会立即解析并取得所有的参数和文件。然而你可以延迟这个过程，在需要的时候，再手工解析上传请求。</p><div class="example"><a id="d0e7414"><!--anchor d0e7414--></a><p class="title"><strong>例 7.21. 手工解析upload请求</strong></p><div class="example-contents"><p>首先，你需要关闭自动上传</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">autoUpload</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre><p>可选参数<code class="code">autoUpload</code>默认值为<code class="code">true</code>，当你把它改成<code class="code">false</code>时，就可以实现延迟手工解析请求。在你需要解析请求时，只需要调用下面的语句即可：</p><pre class="programlisting">parser.getParameters().parseUpload();</pre><p>手工调用<code class="code">parseUpload</code>可以指定和默认不同的参数：</p><pre class="programlisting">UploadParameters params = <strong class="hl-keyword" style="color: maroon">new</strong> UploadParameters();
        
params.applyDefaultValues();
params.setSizeMax(<strong class="hl-keyword" style="color: maroon">new</strong> HumanReadableSize(<strong class="hl-string"><em style="color:navy">"10M"</em></strong>));
params.setFileSizeMax(<strong class="hl-keyword" style="color: maroon">new</strong> HumanReadableSize(<strong class="hl-string"><em style="color:navy">"1M"</em></strong>));
params.setRepository(<strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"mydir"</em></strong>));
        
parser.getParameters().parseUpload(params);</pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7441"><!--anchor d0e7441--></a>7.3.3. 高级选项</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7444"><!--anchor d0e7444--></a>7.3.3.1. 参数名称大小写转换</h4></div></div></div><p>在默认情况下，假设有一个参数名为：<code class="code">myProductId</code>，那么你可以使用下列<span class="emphasis"><em>任意一种方法</em></span>来访问到它：</p><div class="example"><a id="d0e7455"><!--anchor d0e7455--></a><p class="title"><strong>例 7.22. 取得参数<code class="code">myProductId</code>的值的方法</strong></p><div class="example-contents"><pre class="programlisting">request.getParameter(<strong class="hl-string"><em style="color:navy">"MyProductId"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"myProductId"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"my_product_id"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"MY_PRODUCT_ID"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"MY_productID"</em></strong>);</pre></div></div><p>假如你不希望具备这种灵活性，则需要修改配置以关闭大小写转换功能：</p><div class="example"><a id="d0e7465"><!--anchor d0e7465--></a><p class="title"><strong>例 7.23. 关闭大小写转换功能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">caseFolding</span>=<span class="hl-value" style="color: #993300">"none"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7470"><!--anchor d0e7470--></a>7.3.3.2. 参数值去空白</h4></div></div></div><p>在默认情况下，假设有一个参数：<code class="code">id=" 123
                        "</code>（两端有空白字符），那么<code class="code">&lt;parser&gt;</code>会把它转化成<code class="code">"123"</code>（两端没有空白字符）。
                        假如你不希望<code class="code">&lt;parser&gt;</code>做这件事，则需要修改配置： </p><div class="example"><a id="d0e7487"><!--anchor d0e7487--></a><p class="title"><strong>例 7.24. 关闭参数值去空白功能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">trimming</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div><p>这样，所有的参数值将会保持原状，不会被去除空白。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7494"><!--anchor d0e7494--></a>7.3.3.3. 参数值entity解码</h4></div></div></div><p>浏览器在提交表单时，如果发现被提交的字符不能以当前的charset来编码，浏览器就会把该字符转换成<code class="code">&amp;#unicode;</code>这样的形式。例如，假设一个表单页面的content
                            type为：<span class="emphasis"><em><code class="code">text/html;
                        charset=ISO-8859-1</code></em></span>。在这个页面的输入框中输入汉字“你好”，然后提交。你会发现，提交的汉字变成了这个样子：<code class="code">param=</code><span class="emphasis"><em><code class="code">"&amp;#20320;&amp;#22909;"</code></em></span>。 </p><p>在默认情况下，<code class="code">&lt;parser&gt;</code>会对上述参数进行entity解码，使之恢复成“你好”。但是，其它的entity如“<code class="code">&amp;lt;</code>”、“<code class="code">&amp;amp;</code>”等并不会被转换。
                        如果你不希望<code class="code">&lt;parser&gt;</code>还原上述内容，则需要修改配置：</p><div class="example"><a id="d0e7526"><!--anchor d0e7526--></a><p class="title"><strong>例 7.25. 关闭参数值entity解码功能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">unescapeParameters</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7531"><!--anchor d0e7531--></a>7.3.3.4. 取得任意类型的参数值</h4></div></div></div><p>前面提到，<code class="code">ParserRequestContext</code>支持直接取得<code class="code">boolean</code>、<code class="code">int</code>等类型的参数值。事实上，它还支持取得任意类型的参数值
                    —— 只要Spring中有相应的<code class="code">PropertyEditor</code>支持即可。</p><p>假设<code class="code">MyEnum</code>是一个<code class="code">enum</code>类型，这是Spring原生支持的一种类型。你可以用下面的代码来取得它：</p><div class="example"><a id="d0e7556"><!--anchor d0e7556--></a><p class="title"><strong>例 7.26. 将参数值转换成<code class="code">enum</code>类型</strong></p><div class="example-contents"><pre class="programlisting">MyEnum myEnum = params.getObjectOfType(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, MyEnum.<strong class="hl-keyword" style="color: maroon">class</strong>);</pre></div></div><p>但是，下面的语句就不是那么顺利了 ——
                        因为Spring不知道怎么把一个参数值，例如：“<code class="code">1975-12-15</code>”，转换成<code class="code">java.util.Date</code>类型。</p><div class="example"><a id="d0e7572"><!--anchor d0e7572--></a><p class="title"><strong>例 7.27. 将参数值转换成<code class="code">java.util.Date</code>类型</strong></p><div class="example-contents"><pre class="programlisting">Date birthday = params.getObjectOfType(<strong class="hl-string"><em style="color:navy">"birthday"</em></strong>, Date.<strong class="hl-keyword" style="color: maroon">class</strong>);</pre><p>好在<code class="code">&lt;parser&gt;</code>提供了一种扩展机制，可以添加新的类型转换机制。对于<code class="code">Date</code>类型，你只需要添加下面的配置，就可以被支持了。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property-editor-registrar</strong>
        <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.configuration.support.CustomDateRegistrar"</span>
        <span class="hl-attribute" style="color: #F5844C">p:format</span>=<span class="hl-value" style="color: #993300">"yyyy-MM-dd"</span> <span class="hl-attribute" style="color: #F5844C">p:locale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">p:timeZone</span>=<span class="hl-value" style="color: #993300">"GMT+8"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.propedit.date"><!--anchor co.propedit.date--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/parser&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.propedit.date"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">PropertyEditorRegistrar</code>是Spring提供的一种类型注册机制，其细节详见Spring的文档。</p></td></tr></table></div></div></div><p>另一个问题是，如果类型转换失败怎么办？<code class="code">&lt;parser&gt;</code>支持两种方法。默认情况下，类型转换失败会“保持安静”（不抛异常），然后返回默认值。但你也可以选择让类型转换失败的异常被抛出来，以便应用程序处理。</p><div class="example"><a id="d0e7603"><!--anchor d0e7603--></a><p class="title"><strong>例 7.28. 设置“非安静”模式：当类型转换失败时，抛出异常</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">converterQuiet</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre><p>程序里这样写：</p><pre class="programlisting">MyEnum myEnum = null;

<strong class="hl-keyword" style="color: maroon">try</strong> {
    myEnum = params.getObjectOfType(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, MyEnum.<strong class="hl-keyword" style="color: maroon">class</strong>);
} <strong class="hl-keyword" style="color: maroon">catch</strong> (TypeMismatchException e) {
    ...
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7612"><!--anchor d0e7612--></a>7.3.3.5. 解析GET请求的参数</h4></div></div></div><p>GET请求是最简单的请求方式。它的参数以URL编码的方式包含在URL中。当你在浏览器地址栏中敲入“<code class="code">http://localhost:8081/user/login.htm?name=%E5%90%8D%E5%AD%97&amp;password=password</code>”这样一个址址的时候，浏览器就会向<code class="code">localhost:8081</code>服务器出如下HTTP请求：</p><pre class="screen">GET /user/login.htm?name=%E5%90%8D%E5%AD%97&amp;password=password HTTP/1.1
Host: localhost:8081</pre><p>GET请求中的参数是以<code class="code">application/x-www-form-urlencoded</code>方式和特定的charset编码的。假如用来编码URL参数的charset与应用的默认charset不同，那么你必须通过特殊的参数来指定charset（参见<a class="xref" href="#webx3.requestcontexts.setlocale" title="7.2. &lt;set-locale&gt; -设置locale区域和charset字符集编码">第 7.2 节 “<code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码”</a>）：</p><pre class="screen">GET /user/login.htm?<span class="emphasis"><em>_input_charset=UTF-8</em></span>&amp;name=%E5%90%8D%E5%AD%97&amp;password=password HTTP/1.1</pre><p>可是，上面的请求在不同的Servlet引擎中，会产生不确定的结果。这是怎么回事呢？</p><p>原来，尽管<code class="code">&lt;set-locale&gt;</code>会调用<code class="code">request.setCharacterEncoding(charset)</code>这个方法来设置input
                    charset编码，然而根据Servlet API的规范，这个设定只能对request
                        content生效，而不对URL生效。换句话说，<code class="code">request.setCharacterEncoding(charset)</code>方法只能用来解析POST请求的参数，而不是GET请求的参数。</p><p>那么，应该怎样处理GET请求的参数呢？根据URL规范，URL中非US-ASCII的字符必须进行基于<code class="code">UTF-8</code>的URL编码。然而实际上，从浏览器到服务器，没有人完全遵守这些规范，于是便造成了一些混乱。目前应用服务器端，我们所遇到的，有下面几种不同的解码方案：</p><div class="table"><a id="d0e7655"><!--anchor d0e7655--></a><p class="title"><strong>表 7.7. 服务器对参数进行解码的逻辑</strong></p><div class="table-contents"><table summary="服务器对参数进行解码的逻辑" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务器</th><th style="border-bottom: 0.5pt solid #6666cc; ">解码的逻辑</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Tomcat 4</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>根据<code class="code">request.setCharacterEncoding(charset)</code>所设置的值来解码GET参数；</p></li><li class="listitem"><p>如果未特别指定charset，则默认采用<code class="code">ISO-8859-1</code>来解码参数。
                                            </p></li></ul></div>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Tomcat 5及更新版 以及搭载Tomcat 5以上版本的JBoss </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>如果Tomcat配置文件<code class="filename">conf/server.xml</code>中设置了：
                                                  <code class="code">&lt;Connector
                                                  useBodyEncodingForURI="true"&gt;</code>那么根据<code class="code">request.setCharacterEncoding(charset)</code>所设置的值来解码GET参数。</p></li><li class="listitem"><p>如未设置<code class="code">useBodyEncodingForURI</code>，或其值为<code class="code">false</code>，则根据<code class="filename">conf/server.xml</code>中的配置<code class="code">&lt;Connector
                                                  URIEncoding="xxx"&gt;</code>所指定的编码，来解码GET请求的参数。</p></li><li class="listitem"><p>如未配置<code class="code">URIEncoding</code>，默认采用<code class="code">ISO-8859-1</code>。
                                            </p></li></ul></div>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Jetty Server</td><td style="">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Jetty总是以<code class="code">UTF-8</code>来解码GET请求的参数。</p></li></ul></div>
                                </td></tr></tbody></table></div></div><p>综上所述，所有的应用服务器对于POST请求的参数的处理方法是没有差别的，然而对于GET请求的参数处理方法各有不同。</p><p>如果不加任何特别的设置，Tomcat最新版是以<code class="code">ISO-8859-1</code>来解码GET请求的参数，而Jetty却是以<code class="code">UTF-8</code>来解码的。因此，无论你以哪一种charset来编码GET请求的参数，都不可能在所有服务器上取得相同的结果
                    ──
                        除非修改服务器的配置，但这是一件既麻烦又容易出错的事情。为了使应用程序对服务器的配置依赖较少，且可以灵活地处理GET请求的解码，<code class="code">&lt;parser&gt;</code>对GET请求进行了手工解码，从而解决了应用服务器解码的不确定性。</p><p><code class="code">&lt;parser&gt;</code>完全解决了上面的问题。<span class="emphasis"><em>依据默认值，<code class="code">&lt;parser&gt;</code>会以<code class="code">&lt;set-locale&gt;</code>中设定的input
                        charset为准，来解码所有类型的请求</em></span>，包括GET和POST请求，以及<code class="code">multipart/form-data</code>（上传文件）类型的请求。</p><p>然而<code class="code">&lt;parser&gt;</code>仍保留了一些可选方案，以备不时之需。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">保留Servlet引擎的解码机制</span></dt><dd><div class="example"><a id="d0e7782"><!--anchor d0e7782--></a><p class="title"><strong>例 7.29. 使用Servlet引擎原来的解码机制</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">useServletEngineParser</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p><span class="emphasis"><em>这个选项在用HttpUnit进行单元测试时非常有用</em></span>。因为HttpUnit单元测试工具并没有完全遵循Servlet
                                API的规范 ── 目前版本的HttpUnit不能正确取得query
                                    string，从而导致<code class="code">&lt;parser&gt;</code>解析GET参数错误。</p></dd><dt><span class="term">使用固定的charset来解码GET请求</span></dt><dd><div class="example"><a id="d0e7798"><!--anchor d0e7798--></a><p class="title"><strong>例 7.30. 使用固定的charset来解码GET请求</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">URIEncoding</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span> <span class="hl-attribute" style="color: #F5844C">useBodyEncodingForURI</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>上面的配置强制所有的GET请求均使用<code class="code">UTF-8</code>作为固定的charset编码。这段逻辑和tomcat的完全相同，但你却不需要去修改tomcat的<code class="filename">conf/server.xml</code>就可以实现上面的逻辑。
                                事实上，使用固定的charset来解码GET请求的参数是符合Servlet
                                    API规范以及URL的规范的。而根据情况设置charset是一种对现实的妥协。然而<span class="emphasis"><em>你有选择的自由 ──
                                        无论你选择何种风格，<code class="code">&lt;parser&gt;</code>都支持你</em></span>。 </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7817"><!--anchor d0e7817--></a>7.3.3.6. 过滤参数</h4></div></div></div><p>出于安全的考虑，<code class="code">&lt;parser&gt;</code>还支持对输入参数进行过滤。请看示例：</p><div class="example"><a id="d0e7825"><!--anchor d0e7825--></a><p class="title"><strong>例 7.31. 配置过滤参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filters&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parser-filters:uploaded-file-whitelist</strong> <span class="hl-attribute" style="color: #F5844C">extensions</span>=<span class="hl-value" style="color: #993300">"jpg, gif, png"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filters&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/parser&gt;</strong></pre></div></div><p>上面的配置将会禁止文件名后缀不在列表中的文件被上传到服务器上。如果做得更好一点，你甚至可以对上传文件进行病毒扫描。</p><p>目前，<code class="code">&lt;parser&gt;</code>支持两种过滤器接口：<code class="code">ParameterValueFilter</code>和<code class="code">UploadedFileFilter</code>。前者用来对普通的参数值进行过滤（例如排除可能造成攻击的HTML代码）；后者用来对上传文件的file
                        item对象进行过滤，就像刚才的<code class="code">uploaded-file-whitelist</code>的例子。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.buffered"><!--anchor webx3.requestcontexts.buffered--></a>7.4. <code class="code">&lt;buffered&gt;</code> - 缓存response中的内容</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7851"><!--anchor d0e7851--></a>7.4.1. 实现原理</h3></div></div></div><p>Webx
                Turbine支持用layout/screen/control等部件共同购成一个页面。其中，每个layout可包含一个screen和多个control，每个screen可包含多个control，每个control还可以再包含其它的control。Screen和control的内容都可以用程序代码直接生成：</p><div class="example"><a id="d0e7856"><!--anchor d0e7856--></a><p class="title"><strong>例 7.32. 在Screen中直接输出页面内容</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyScreenOrControl {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute() <strong class="hl-keyword" style="color: maroon">throws</strong> IOException {
        PrintWriter out = response.getWriter();

        out.println(<strong class="hl-string"><em style="color:navy">"&lt;p&gt;hello world&lt;/p&gt;"</em></strong>);
    }
}</pre></div></div><p>上面的代码是非常直观、易理解的。事实上，如果你写一个简单的servlet来生成页面，代码也是和上面的类似。</p><p>但是，在简单的代码后面有一个玄机 ——
                那就是这段代码可被用于生成嵌套的页面部件，它所生成的内容可被上一层嵌套的部件所利用。例如，一个screen中包含了一个control，那么screen可以获得它所调用的control的完整的渲染内容。</p><p>这个玄机就是靠<code class="code">&lt;buffered&gt;</code>来实现的。<code class="code">&lt;buffered&gt;</code>改变了response的输出流，包括output
                stream（二进制流）和writer（文本流），使写到输出流中的内容被暂存在内存中。当需要时，可以取得缓存中的所有内容。</p><div class="figure"><a id="d0e7873"><!--anchor d0e7873--></a><div class="figure-contents"><div class="mediaobject"><img src="images/requestcontexts/buffered-rc.png" alt="Webx利用&lt;buffered&gt;机制生成嵌套式页面的过程"/></div></div><p class="title"><strong>图 7.2. Webx利用<code class="code">&lt;buffered&gt;</code>机制生成嵌套式页面的过程</strong></p></div><p>如图所示。<code class="code">BufferedRequestContext</code>主要包括了两条用来操作buffer栈的指令：push和pop。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>每次push就会在栈顶创建一个新的buffer。</p></li><li class="listitem"><p>每次pop就会弹出栈顶buffer，并返回其内容。当最后一个buffer被弹出时，就会自动push一个新的buffer，从而确保任何时候栈都非空。</p></li><li class="listitem"><p>所有写入<code class="code">response.getWriter()</code>和<code class="code">response.getOutputStream()</code>输出流的数据，将被保存在栈顶的buffer中。</p></li><li class="listitem"><p>Push和pop必须成对出现。如果在commit时发现栈内有两个或两个以上的buffer存在，说明有push/pop未匹配，则报错。</p></li><li class="listitem"><p>Commit时，将仅存的栈顶buffer提交给浏览器。</p></li></ul></div><p><code class="code">&lt;buffered&gt;</code>还有一个重要的作用，就是可以用来支持基于cookie的session机制（参见：<a class="xref" href="#webx.requestcontext.session" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>）。因为cookie是response
                    header的一部分，根据HTTP协议，headers出现在content的前面。一旦content开始向浏览器输出，headers就不可能再被改变了。这会导致基于cookie的session无法保存的问题。<code class="code">&lt;buffered&gt;</code>将所有的输出内容缓存在内存中，从而避免了response过早地提交给浏览器，也就解决了cookie无法保存的问题。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7918"><!--anchor d0e7918--></a>7.4.2. 使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7921"><!--anchor d0e7921--></a>7.4.2.1. 配置</h4></div></div></div><p><code class="code">&lt;buffered&gt;</code>的配置比较简单，没有任何额外的参数。只要像下面这样写就可以了：</p><div class="example"><a id="d0e7928"><!--anchor d0e7928--></a><p class="title"><strong>例 7.33. 配置<code class="code">&lt;buffered&gt;</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7939"><!--anchor d0e7939--></a>7.4.2.2. 操作buffer栈</h4></div></div></div><div class="example"><a id="d0e7942"><!--anchor d0e7942--></a><p class="title"><strong>例 7.34. 操作buffer栈</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
BufferedRequestContext buffered;

<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
HttpServletResponse response;

...

PrintWriter out = response.getWriter();

buffered.pushBuffer(); <em class="hl-comment" style="color: green">// 创建新buffer，并压入栈顶</em>
out.print(<strong class="hl-string"><em style="color:navy">"world"</em></strong>);  <em class="hl-comment" style="color: green">// 在新buffer中写入</em>

String content = buffered.popCharBuffer(); <em class="hl-comment" style="color: green">// 弹出顶层buffer</em>

out.print(<strong class="hl-string"><em style="color:navy">"hello, "</em></strong>);
out.print(content); <em class="hl-comment" style="color: green">// 写入较低层的buffer</em></pre></div></div><p>需要注意的是，response中有两种输出流：二进制流<code class="code">response.getOutputStream()</code>和文本流<code class="code">response.getWriter()</code>。与之对应的，<code class="code">BufferedRequestContext</code>也会创建两种类型的buffer。这两种buffer类型是互斥的：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>假如你的应用使用了<code class="code">response.getWriter()</code>，那么，你必须使用<code class="code">buffered.popCharBuffer()</code>以取得文本buffer的内容；</p></li><li class="listitem"><p>假如你的应用使用了<code class="code">response.getOutputStream()</code>，那么，你必须使用<code class="code">buffered.popByteBuffer()</code>以取得二进制buffer的内容。</p></li><li class="listitem"><p>如果用错，则抛<code class="code">IllegalStateException</code>。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7983"><!--anchor d0e7983--></a>7.4.2.3. 关闭buffer机制</h4></div></div></div><p>Buffer机制会延迟服务器对用户的响应。在大部分情况下，这不会造成明显的问题。但在某些情况下会产生严重的问题。此时，你需要把buffer机制关闭。</p><p>例如，动态生成excel文件、PDF文件以及图片文件。这样的需求有如下特点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>数据量大 —— 有可能达到几兆。如果把这样大的数据放在内存中，势必导致服务器性能的下降。</p></li><li class="listitem"><p>没有layout/screen/control这样的嵌套页面的需求，因此不需要buffer这样的机制来帮倒忙。</p></li><li class="listitem"><p>无状态，不需要修改session，因此也不需要buffer机制来帮助延迟提交。反过来，对于这样的大文件，提交越早越好 ——
                                甚至可以在文档还未完全生成的时候，就开始向用户浏览器输出，边生成边下载，从而节省大量的下载时间。</p></li></ul></div><p>下面的程序代码模拟了一种情况 ——
                    生成一个120M的PDF文件。每生成1M内容，就故意暂停半秒。这样一来，120M的文件需要大约一分钟才能生成完毕。</p><div class="example"><a id="d0e8002"><!--anchor d0e8002--></a><p class="title"><strong>例 7.35. 模拟生成PDF文档，关闭buffer以提高性能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyDocument {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> BufferedRequestContext buffered;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute() <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        buffered.setBuffering(false);

        response.setContentType(<strong class="hl-string"><em style="color:navy">"application/pdf"</em></strong>);
        response.setHeader(<strong class="hl-string"><em style="color:navy">"Content-Disposition"</em></strong>, <strong class="hl-string"><em style="color:navy">"attachment; filename=\"mydocument.pdf\""</em></strong>);

        OutputStream out = response.getOutputStream();

        <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> m = <span class="hl-number">0</span>; m &lt; <span class="hl-number">120</span>; m++) {
            <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> k = <span class="hl-number">0</span>; k &lt; <span class="hl-number">1024</span>; k++) {
                <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> b = <span class="hl-number">0</span>; b &lt; <span class="hl-number">1024</span>; b++) {
                    out.write((<strong class="hl-keyword" style="color: maroon">byte</strong>) b);
                }
            }

            <em class="hl-comment" style="color: green">// 每生成1M，暂停半秒</em>
            Thread.sleep(<span class="hl-number">500</span>);
        }
    }
}</pre></div></div><p>把上述类代码，放在screen目录中。然后访问URL：<code class="code">http://localhost:8081/myapp/my_document.do</code>，就可以启动下载。</p><p>假如不关闭buffer机制，从用户点击下载，到浏览器提示保存文件，中间会相隔一分钟。这种用户体验是不可接受的。更糟糕的是，文件会占用至少120M的服务器内存，这也是几乎不可接受的。关闭buffer机制以后，以上两个问题就没有了：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>用户点击下载链接，浏览器立即提示保存文件。</p></li><li class="listitem"><p>边下载边生成数据，生成数据的时间是一分钟，下载所需的时间也是一分钟左右。</p></li><li class="listitem"><p>生成的数据立即输出，不会占用过多的内存。 </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.lazycommit"><!--anchor webx3.requestcontexts.lazycommit--></a>7.5. <code class="code">&lt;lazy-commit&gt;</code> - 延迟提交response</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8029"><!--anchor d0e8029--></a>7.5.1. 什么是提交</h3></div></div></div><p>当浏览器向服务器发出请求，服务器就会返回一个response响应。每个response分成两部分：headers和content。下面是一个HTTP响应的例子：</p><div class="example"><a id="d0e8034"><!--anchor d0e8034--></a><p class="title"><strong>例 7.36. HTTP请求的headers和content</strong></p><div class="example-contents"><pre class="screen">HTTP/1.0 200 OK
Date: Sat, 08 Jan 2011 23:19:52 GMT
Server: Apache/2.0.63 (Unix)
...

&lt;html&gt;...</pre></div></div><p>在服务器应用响应request的全过程中，都可以向浏览器输出response的内容。然而，已经输出到浏览器上的内容，是不可更改的；还没有输出的内容，还有改变的余地。这个输出的过程，被称为提交（commit）。</p><p>Servlet API中有一个方法，可以判定当前的response是否已经被提交。</p><div class="example"><a id="d0e8043"><!--anchor d0e8043--></a><p class="title"><strong>例 7.37. 判断response是否已经被提交</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">if</strong> (response.isCommitted()) {
    ...
}</pre></div></div><p>在Servlet API中，有下列操作可能导致response被提交：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">response.sendError()</code></p></li><li class="listitem"><p><code class="code">response.sendRedirect()</code></p></li><li class="listitem"><p><code class="code">response.flushBuffer()</code></p></li><li class="listitem"><p><code class="code">response.setContentLength()</code>
                                或者<code class="code">response.setHeader("Content-Length", length)</code></p></li><li class="listitem"><p>response输出流被写入并达到内部buffer的最大值（例如：8KB）</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8073"><!--anchor d0e8073--></a>7.5.2. 实现原理</h3></div></div></div><p>当response被提交以后，一切headers都不可再改变。这对于某些应用（例如cookie-based session）的实现是一个问题。</p><p><code class="code">&lt;lazy-commit&gt;</code>通过拦截response中的某些方法，来将可能导致提交的操作延迟到请求处理结束的时候，也就是request
                context本身被提交的时候。</p><p><code class="code">&lt;lazy-commit&gt;</code>必须和<code class="code">&lt;buffered&gt;</code>配合，才能完全实现延迟提交。如前所述，<code class="code">&lt;buffered&gt;</code>将所有的输出暂存在内存里，从而避免了因输出流达到内部buffer的最大值（例如：8KB）而引起的提交。
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8092"><!--anchor d0e8092--></a>7.5.3. 使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8095"><!--anchor d0e8095--></a>7.5.3.1. 配置</h4></div></div></div><p><code class="code">&lt;lazy-commit&gt;</code>的配置比较简单，没有任何额外的参数。只要像下面这样写就可以了：</p><div class="example"><a id="d0e8102"><!--anchor d0e8102--></a><p class="title"><strong>例 7.38. 配置<code class="code">&lt;lazy-commit&gt;</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8113"><!--anchor d0e8113--></a>7.5.3.2. 取得当前response的状态</h4></div></div></div><p>通过<code class="code">LazyCommitRequestContext</code>接口，你可以访问当前response的一些状态：</p><div class="table"><a id="d0e8121"><!--anchor d0e8121--></a><p class="title"><strong>表 7.8. 通过<code class="code">LazyCommitRequestContext</code>访问response状态</strong></p><div class="table-contents"><table summary="通过LazyCommitRequestContext访问response状态" cellpadding="10" style="border: none;"><colgroup><col width="36%" class="c1"/><col width="64%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">LazyCommitRequestContext</code>方法名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">isError()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前请求是否已出错</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">getErrorStatus()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">如果<code class="code">sendError()</code>方法曾被调用，则该方法返回一个error状态值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">getErrorMessage()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">如果<code class="code">sendError()</code>方法曾被调用，则该方法返回一个error信息。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">isRedirected()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前请求是否已被重定向。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">getRedirectLocation()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">取得重定向的URI。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">getStatus()</code>
                                </td><td style="">取得最近设置的HTTP status</td></tr></tbody></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.rewrite"><!--anchor webx3.requestcontexts.rewrite--></a>7.6. <code class="code">&lt;rewrite&gt;</code> -重写请求的URL和参数</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8198"><!--anchor d0e8198--></a>7.6.1. 概述</h3></div></div></div><p>&lt;rewrite&gt;的功能和设计完全类似于Apache HTTPD
                Server所提供的mod_rewrite模块。它可以根据规则，在运行时修改URL和参数。</p><div class="figure"><a id="d0e8203"><!--anchor d0e8203--></a><div class="figure-contents"><div class="mediaobject"><img src="images/requestcontexts/rewrite-rc.png" alt="Rewrite工作原理"/></div></div><p class="title"><strong>图 7.3. Rewrite工作原理</strong></p></div><p>当一个请求进入<code class="code">&lt;rewrite&gt;</code>以后，它的处理过程如上图所示。过程可分为两个大的步骤，即：匹配和执行。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>匹配</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>取得URL中的path路径。</p></li><li class="listitem"><p>用所取得的path，依次匹配rule1、rule2、rule3中的pattern，直到找到第一个匹配。</p></li><li class="listitem"><p>假如rule中包含conditions，则测试conditions。如果condtions不满足，则当前的rule匹配失败，回到第2步，继续匹配下一个rules。</p></li><li class="listitem"><p>假如rule不包含conditions，或者conditions被满足，则当前的rule匹配成功，进入“执行”阶段。 </p></li></ol></div></li><li class="listitem"><p>执行</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>执行substitution替换。这可能导致path和参数的改变。</p></li><li class="listitem"><p>执行所有的handlers。这为编程者提供了更灵活的手段来改变request中的数据。</p></li><li class="listitem"><p>根据substitution中的指示，结束<code class="code">&lt;rewrite&gt;</code>的执行、或者回到匹配阶段，用新的path和参数继续匹配后续的rules。</p></li><li class="listitem"><p><code class="code">&lt;rewrite&gt;</code>结束时，根据substitution中的指示，改写request或者重定向到新的URL。
                            </p></li></ol></div></li></ul></div><p>下面是一个<code class="code">&lt;rewrite&gt;</code>配置的模板：</p><div class="example"><a id="d0e8257"><!--anchor d0e8257--></a><p class="title"><strong>例 7.39. 配置<code class="code">&lt;rewrite&gt;</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;rewrite&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- rule 1 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/substitution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;handlers&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/handlers&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- rule 2 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- rule 3 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;/rewrite&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8268"><!--anchor d0e8268--></a>7.6.2. 取得路径</h3></div></div></div><p>和Apache mod_rewrite不同，用来匹配rules的路径并不是URL的整个路径，而是由<code class="code">servletPath +
                    pathInfo</code>两部分组成，其中并不包含<code class="code">contextPath</code>。</p><p>这是因为<code class="code">&lt;rewrite&gt;</code>是属于WEB应用的，它只能匹配当前应用中的路径。在基于servlet的WEB应用中，一个完整的URL路径是由<code class="code">contextPath
                    + servletPath +
                    pathInfo</code>三部分组成的。其中<code class="code">contextPath</code>是用来区分应用的，所以对<code class="code">&lt;rewrite&gt;</code>没有意义。</p><p>例如，URL是<code class="code">http://localhost:8081/myapp</code><span class="emphasis"><em><code class="code">/myservlet/path/path</code></em></span>，那么<code class="code">&lt;rewrite&gt;</code>用来匹配rules的路径是：<span class="emphasis"><em><code class="code">/myservlet/path/path</code></em></span>。
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8308"><!--anchor d0e8308--></a>7.6.3. 匹配rules</h3></div></div></div><p>下面是一个简单的rule。</p><div class="example"><a id="d0e8313"><!--anchor d0e8313--></a><p class="title"><strong>例 7.40. 匹配规则的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/test1/hello\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>其中，rule pattern是一个正则表达式。特别需要注意的是，<span class="emphasis"><em>这个正则表达式是部分匹配的</em></span>。如上例pattern可以匹配下面的路径：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span></p></li><li class="listitem"><p><code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span></p></li><li class="listitem"><p><code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span><code class="code">/mypath
                            </code></p></li></ul></div><p>如果你希望匹配整个path，请使用正则表达式的“<code class="code">^</code>”和“<code class="code">$</code>”标记。例如：</p><div class="example"><a id="d0e8353"><!--anchor d0e8353--></a><p class="title"><strong>例 7.41. 匹配整个path</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/test1/hello\.htm$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div><p>部分匹配的正则表达式为你提供了较灵活的匹配能力，例如，下面的rule可以用来匹配所有以jpg为后缀的URL。</p><div class="example"><a id="d0e8360"><!--anchor d0e8360--></a><p class="title"><strong>例 7.42. 后缀匹配</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"\.jpg$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div><p>此外，rules pattern还支持否定的pattern ——
                即在正常的pattern前加上“<code class="code">!</code>”即可。例如下面的rule匹配所有不以jpg为后缀的URL：</p><div class="example"><a id="d0e8370"><!--anchor d0e8370--></a><p class="title"><strong>例 7.43. 否定匹配</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"!\.jpg$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8375"><!--anchor d0e8375--></a>7.6.4. 匹配conditions</h3></div></div></div><p>每个rule都可以包含多个额外的conditions。Conditions提供了除path匹配以外的其它条件。下面是condition配置的基本格式：</p><div class="example"><a id="d0e8380"><!--anchor d0e8380--></a><p class="title"><strong>例 7.44. 配置conditions</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/path"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>每个condition由两个主要的参数：测试表达式和pattern。测试表达式中可以使用下面的变量：</p><div class="table"><a id="d0e8387"><!--anchor d0e8387--></a><p class="title"><strong>表 7.9. Condition变量</strong></p><div class="table-contents"><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">客户端信息</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REMOTE_HOST}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">客户端主机名。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRemoteHost()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REMOTE_ADDR}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">客户端地址。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRemoteAddr()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REMOTE_USER}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">用户名。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRemoteUser()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{AUTH_TYPE}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">验证用户的方法。例如BASIC、FORM、CLIENT_CERT、DIGEST等。</td><td style="">相当于<code class="code">request.getAuthType()</code></td></tr></tbody></table><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">服务端信息</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{SERVER_NAME}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务器主机名。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getServerName()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{SERVER_PORT}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务器端口。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getServerPort()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{SERVER_PROTOCOL}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">服务器协议。</td><td style="">相当于<code class="code">request.getProtocol()</code></td></tr></tbody></table><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">请求信息</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REQUEST_METHOD}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">HTTP方法名。例如GET、POST等。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getMethod()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REQUEST_URI}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">所请求的URI，不包括主机名、端口和参数。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRequestURI()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{QUERY_STRING}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数和值。注意，对于POST请求取得QUERY_STRING，可能会影响性能。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getQueryString()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{QUERY:param}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">取得参数值。无论哪一种类型的请求（GET/POST/上传文件），都可以取得参数值。 </td><td style="">相当于<code class="code">request.getParameter("param")</code></td></tr></tbody></table><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">HTTP headers</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_USER_AGENT}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">浏览器名称。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("User-Agent")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_REFERER}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">前一个URL。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("Referer")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_HOST}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">HTTP请求中的主机名，一般代表虚拟主机。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("Host")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_ACCEPT}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">浏览器可以接受的文档类型。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("Accept")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_COOKIE}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">浏览器发送过来的cookie。</td><td style="">相当于<code class="code">request.getHeader("Cookie")</code></td></tr></tbody></table></div></div><p>Condition pattern和rule
                pattern类似，也是<span class="emphasis"><em>部分匹配的正则表达式，并且支持否定的pattern</em></span>。举例说明：</p><div class="example"><a id="d0e8623"><!--anchor d0e8623--></a><p class="title"><strong>例 7.45. Condition patterns</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/path"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rewrite.conditions.rule1"><!--anchor co.rewrite.conditions.rule1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{SERVER_NAME}:%{SERVER_PORT}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"www.(\w+).com:8080"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>  <a id="co.rewrite.conditions.c1"><!--anchor co.rewrite.conditions.c1--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:x}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"!1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c2"><!--anchor co.rewrite.conditions.c2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:y}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c3"><!--anchor co.rewrite.conditions.c3--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>上面的rule匹配符合以下条件的请求：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.rule1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>匹配路径<code class="code">/path</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c1"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>服务器名为<code class="code">www.*.com</code>，端口为<code class="code">8080</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c2"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>并且参数<code class="code">x!=1</code></p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c3"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>并且参数<code class="code">y=2</code></p></td></tr></table></div></div></div><p>默认情况下，必须所有的conditions条件都符合，rule才会继续执行下去。但是condition还支持一个选项：<code class="code">OR</code>或者<code class="code">ornext</code>。如果condtion带有这个选项，只要符合当前condition<span class="emphasis"><em>或者</em></span>后续的conditions，rule就会执行下去。例如：</p><div class="example"><a id="d0e8675"><!--anchor d0e8675--></a><p class="title"><strong>例 7.46. 部分匹配conditions</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/path"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rewrite.conditions.rule2"><!--anchor co.rewrite.conditions.rule2--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:x}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"1"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"OR"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c4"><!--anchor co.rewrite.conditions.c4--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:y}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"2"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"ornext"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c5"><!--anchor co.rewrite.conditions.c5--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:z}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c6"><!--anchor co.rewrite.conditions.c6--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>上例中，“<code class="code">OR</code>”和“<code class="code">ornext</code>”代表完全一样的意思。这个rule匹配符合以下条件的请求：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.rule2"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>匹配路径<code class="code">/path</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c4"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>参数<code class="code">x=1</code>，</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c5"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><span class="emphasis"><em>或者</em></span><code class="code">y=2</code>，</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c6"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><span class="emphasis"><em>或者</em></span><code class="code">z=3</code>。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8723"><!--anchor d0e8723--></a>7.6.5. 替换路径</h3></div></div></div><p>当路径匹配，并且conditions也匹配（如果有的话），那么<code class="code">&lt;rewrite&gt;</code>就会执行所匹配的rule。</p><div class="example"><a id="d0e8731"><!--anchor d0e8731--></a><p class="title"><strong>例 7.47. 替换路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/test1/hello\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/test1/new_hello\.htm"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>上例中的rule将执行下面的替换（别忘了，rule支持部分匹配，只有匹配的部分被替换）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>将<span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span>替换成<span class="emphasis"><em><code class="code">/test1/new_hello.htm</code></em></span>。</p></li><li class="listitem"><p>将<code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span>替换成<code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/new_hello.htm</code></em></span>。</p></li><li class="listitem"><p>将<code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span><code class="code">/mypath</code>替换成<code class="code">/mypath</code><code class="code">/test1/new_hello.htm</code><code class="code">/mypath</code>。
                        </p></li></ul></div><p>路径替换时，还支持正则表达式变量。例如：</p><div class="example"><a id="d0e8785"><!--anchor d0e8785--></a><p class="title"><strong>例 7.48. 用正则表达式变量替换路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/(\w+)\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{SERVER_NAME}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"(\w+).blogs.com"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/%1/new_$1\.htm"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>需要注意的是，rule
                pattern中的匹配项，是用“<code class="code">$1</code>”、“<code class="code">$2</code>”、“<code class="code">$3</code>”表示的；而condition
                    pattern中的匹配项，是用“<code class="code">%1</code>”、“<code class="code">%2</code>”、“<code class="code">%3</code>”表示的。只有最后一个被匹配的condition中的匹配项，才被保留用于替换。</p><p>上面的rule将执行下面的替换：将<code class="code">http://</code><span class="emphasis"><em><code class="code">myname</code></em></span><code class="code">.blogs.com</code><span class="emphasis"><em><code class="code">/hello.htm</code></em></span>替换成同服务器上的路径：<span class="emphasis"><em><code class="code">/myname/new_hello.htm</code></em></span>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8827"><!--anchor d0e8827--></a>7.6.6. 替换参数</h3></div></div></div><p><code class="code">&lt;rewrite&gt;</code>不仅可以替换路径，还可以替换参数。</p><div class="example"><a id="d0e8834"><!--anchor d0e8834--></a><p class="title"><strong>例 7.49. 替换参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/hello.(\w+)"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{SERVER_NAME}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"www.(\w+).com"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"ext"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"host"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"%1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"count"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>1<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>2<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>3<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/parameter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/substitution&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>替换参数和替换路径类似，也可以指定rule和condition pattern中的匹配项。参数支持多值，例如上例中的<code class="code">count</code>参数。 上面的例子将执行以下替换行为：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>对于请求：<code class="code">http://www.</code><span class="emphasis"><em><code class="code">myserver</code></em></span><code class="code">.com/hello.</code><span class="emphasis"><em><code class="code">htm</code></em></span>，不改变其路径，只改变其参数：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>创建单值参数：ext=<span class="emphasis"><em><code class="code">htm</code></em></span>（从rule
                                            pattern中取得<code class="code">$1</code>）</p></li><li class="listitem"><p>创建单值参数：host=<span class="emphasis"><em><code class="code">myserver</code></em></span>（从condition
                                            pattern中取得<code class="code">%1</code>）</p></li><li class="listitem"><p>创建多值参数：count=<span class="emphasis"><em><code class="code">[1, 2,
                                        3]</code></em></span></p></li><li class="listitem"><p><span class="emphasis"><em>删除其它所有参数</em></span>。 </p></li></ul></div></li></ul></div><p>如果你想保留原来所有参数，只是修改或添加一些参数，可以指定<code class="code">QSA</code>或<code class="code">qsappend</code>选项。</p><div class="example"><a id="d0e8899"><!--anchor d0e8899--></a><p class="title"><strong>例 7.50. 保留原来的参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"QSA"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/substitution&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8904"><!--anchor d0e8904--></a>7.6.7. 后续操作 </h3></div></div></div><p>当一个rule和其中的conditions被匹配时，<code class="code">&lt;rewrite&gt;</code>就会执行这个rule。执行的结果通常是改变请求的路径或参数。当一个rule执行完毕以后，接下来做什么呢？有几种可能的情况。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8912"><!--anchor d0e8912--></a>7.6.7.1. 继续匹配剩余的rules</h4></div></div></div><div class="example"><a id="d0e8915"><!--anchor d0e8915--></a><p class="title"><strong>例 7.51. 默认后续操作：继续匹配剩余的rules</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>上面第一个rule执行完以后，<code class="code">&lt;rewrite&gt;</code>会用改变过的路径和参数去继续匹配余下的规则。这是默认情况。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8925"><!--anchor d0e8925--></a>7.6.7.2. 停止匹配</h4></div></div></div><div class="example"><a id="d0e8928"><!--anchor d0e8928--></a><p class="title"><strong>例 7.52. 后续操作：停止匹配</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>当在substitution中指定<code class="code">L</code>或者<code class="code">last</code>选项时，rule匹配会到此中止。后续的rules不会再被匹配。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8941"><!--anchor d0e8941--></a>7.6.7.3. 串接rules</h4></div></div></div><div class="example"><a id="d0e8944"><!--anchor d0e8944--></a><p class="title"><strong>例 7.53. 后续操作：串接rules</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/common-prefix"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"C"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"\.jpg"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>当在substitution中指定<code class="code">C</code>或者<code class="code">chain</code>选项时，假如当前rule匹配，则会像默认情况一样继续匹配剩余的rules；否则，就像<code class="code">last</code>选项一样立即中止匹配。</p><p>串接rules在下面的情况下非常有用：即对一个路径进行匹配多个patterns。例如上面的例子中，第一个rule限定了路径前缀必须是“<code class="code">/common-prefix</code>”，接下来的rules在此基础上继续判断：后缀是“<code class="code">jpg</code>”还是“<code class="code">htm</code>”？</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8971"><!--anchor d0e8971--></a>7.6.8. 重定向</h3></div></div></div><div class="example"><a id="d0e8974"><!--anchor d0e8974--></a><p class="title"><strong>例 7.54. 重定向</strong></p><div class="example-contents"><p>永久重定向，status code=<code class="code">301</code></p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello1\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R=301"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>临时重定向，status code=<code class="code">302</code>，不保留参数</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello2\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>临时重定向，status code=<code class="code">302</code>，保留参数</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello3\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R,QSA"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>绝对URL重定向，status code=<code class="code">302</code></p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello4\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"http://www.other-site.com/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>当在substitution中指定<code class="code">R</code>或者<code class="code">redirect</code>的时候，<code class="code">&lt;rewrite&gt;</code>会返回“重定向”的响应。
                    重定向有两种：<code class="code">301</code>永久重定向，和<code class="code">302</code>临时重定向。默认是<code class="code">302</code>临时重定向，但你可以指定<code class="code">301</code>来产生一个永久的重定向。</p><p>通常，<code class="code">R</code>标记会和<code class="code">L</code>标记一起使用，使<code class="code">&lt;rewrite&gt;</code>立即结束。</p><p>重定向和<code class="code">QSA</code>标记一起使用时，可以将当前请求的所有参数附加到重定向请求中。不过这里需要注意的是，假如当前请求是一个post请求，那么将参数附加到新的URL中，可能会导致URL过长而重定向失败的问题。</p><p>重定向可以指向另一个不同域名的网站 ——
                反过来说，<span class="emphasis"><em>假如你希望rewrite到另一个网站，那么你必须指定重定向的选项才行</em></span>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9047"><!--anchor d0e9047--></a>7.6.9. 自定义处理器</h3></div></div></div><div class="example"><a id="d0e9050"><!--anchor d0e9050--></a><p class="title"><strong>例 7.55. 自定义处理器</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;handlers&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/handlers&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>有时候，基于正则表达式替换的substitution不能满足较复杂的需求，好在<code class="code">&lt;rewrite&gt;</code>还提供了另一种机制：自定义处理器。</p><p>当rule和conditions被匹配的时候，所有的handlers将被执行。Webx提供了一个handler参考实现：</p><div class="example"><a id="d0e9062"><!--anchor d0e9062--></a><p class="title"><strong>例 7.56. 自定处理器参考实现：规格化路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;handlers&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong>
            <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.requestcontext.rewrite.support.UrlNormalizer"</span><strong class="hl-tag" style="color: #000096">
        /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/handlers&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e9067"><!--anchor d0e9067--></a>7.7. 本章总结</h2></div></div></div><p>本文详细介绍了Request Contexts的功能。</p><p>Request
            Contexts服务是Webx框架的核心功能之一。它看似简单，但却提供了很多有用功能。相对于其它框架中的解决方案，RequestContexts显得更加优雅，因为其中大部分功能对应用程序是透明的
            —— 应用程序不需要知道它们的存在，就可以享受它们所提供的功能。 </p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.requestcontext.session"><!--anchor webx.requestcontext.session--></a>第 8 章 Request Context之Session指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e9084">8.1. Session概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9087">8.1.1. 什么是Session</a></span></dt><dt><span class="section"><a href="#d0e9106">8.1.2. Session数据存在哪？</a></span></dt><dt><span class="section"><a href="#d0e9174">8.1.3. 创建通用的session框架</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9198">8.2. Session框架</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9201">8.2.1. 最简配置</a></span></dt><dt><span class="section"><a href="#d0e9237">8.2.2. Session ID</a></span></dt><dt><span class="section"><a href="#d0e9520">8.2.3. Session的生命期</a></span></dt><dt><span class="section"><a href="#d0e9681">8.2.4. Session Store</a></span></dt><dt><span class="section"><a href="#d0e9822">8.2.5. Session Model</a></span></dt><dt><span class="section"><a href="#d0e9878">8.2.6. Session Interceptor</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9984">8.3. Cookie Store</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10006">8.3.1. 多值Cookie Store</a></span></dt><dt><span class="section"><a href="#d0e10438">8.3.2. 单值Cookie Store</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10791">8.4. 其它Session Store</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10794">8.4.1. Simple Memory Store</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10815">8.5. 本章总结</a></span></dt></dl></div><p>Webx实现了一套session框架。Session框架建立在request contexts机制之上。建议你先阅读<a class="xref" href="#webx.filter.requestcontexts.pipeline" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>和<a class="xref" href="#webx.requestcontexts" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>，以便了解request contexts是怎么回事。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e9084"><!--anchor d0e9084--></a>8.1. Session概述</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9087"><!--anchor d0e9087--></a>8.1.1. 什么是Session</h3></div></div></div><p>HTTP协议是无状态的，但通过session机制，就能把无状态的变成有状态的。Session的功能就是保存HTTP请求之间的状态数据。有了session的支持，就很容易实现诸如用户登录、购物车等网站功能。在Servlet
                    API中，有一个<code class="code">HttpSession</code>的接口。你可以这样使用它：</p><div class="example"><a id="d0e9095"><!--anchor d0e9095--></a><p class="title"><strong>例 8.1. 在Java代码中访问session</strong></p><div class="example-contents"><p>在一个请求中，保存session的状态</p><pre class="programlisting"><em class="hl-comment" style="color: green">// 取得session对象</em>
HttpSession session = request.getSession();

<em class="hl-comment" style="color: green">// 在session中保存用户状态</em>
session.setAttribute(<strong class="hl-string"><em style="color:navy">"loginId"</em></strong>, <strong class="hl-string"><em style="color:navy">"myName"</em></strong>);</pre><p>在另一个请求中，取出session的状态：</p><pre class="programlisting"><em class="hl-comment" style="color: green">// 得到"myName"</em>
String myName = (String) session.getAttribute(<strong class="hl-string"><em style="color:navy">"loginId"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9106"><!--anchor d0e9106--></a>8.1.2. Session数据存在哪？</h3></div></div></div><p>Session的状态数据是怎样保存的呢？</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9111"><!--anchor d0e9111--></a>8.1.2.1. 保存在应用服务器的内存中</h4></div></div></div><p>一般的做法，是将session对象保存在内存里。同一时间，会有很多session被保存在服务器的内存里。由于内存是有限的，较好的服务器会把session对象的数据交换到文件中，以确保内存中的session数目保持在一个合理的范围内。</p><p>为了提高系统扩展性和可用性，我们会使用集群技术 ——
                    就是一组独立的机器共同运行同一个应用。对用户来讲，集群相当于一台“大型服务器”。而实际上，同一用户的两次请求可能被分配到两台不同的服务器上来处理。这样一来，怎样保证两次请求中存取的session值一致呢？</p><p>一种方法是使用session复制：当session的值被改变时，将它复制到其它机器上。这个方案又有两种具体的实现，一种是广播的方式。这种方式下，任何一台服务器都保存着所有服务器所接受到的session对象。服务器之间随时保持着同步，因而所有服务器都是等同的。可想而知，当访问量增大的时候，这种方式花费在广播session上的带宽有多大，而且随着机器增加，网络负担成指数级上升，不具备高度可扩展性。</p><p>另一种方法是TCP-Ring的方式，也就是把集群中所有的服务器看成一个环，A→B→C→D→A，首尾相接。把A的session复制到B，B的session复制到C，……，以此类推，最后一台服务器的session复制到A。这样，万一A宕机，还有B可以顶上来，用户的session数据不会轻易丢失。但这种方案也有缺点：一是配置复杂；二是每增添/减少一台机器时，ring都需要重新调整，这将成为性能瓶颈；三是要求前端的Load
                    Balancer具有相当强的智能，才能将用户请求分发到正确的机器上。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9122"><!--anchor d0e9122--></a>8.1.2.2. 保存在单一数据源中</h4></div></div></div><p>也可以将session保存在单一的数据源中，这个数据源可被集群中所有的机器所共享。这样一来，就不存在复制的问题了。</p><p>然而单一数据源的性能成了问题。每个用户请求，都需要访问后端的数据源（很可能是数据库）来存取用户的数据。</p><p>这种方案的第二个问题是：缺少应用服务厂商的支持 ——
                    很少有应用服务器直接支持这种方案。更不用说数据源有很多种（MySQL、Oracle、Hsqldb等各种数据库、专用的session
                    server等）了。</p><p>第三个问题是：数据源成了系统的瓶颈，一但这个数据源崩溃，所有的应用都不可能正常运行了。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9133"><!--anchor d0e9133--></a>8.1.2.3. 保存在客户端</h4></div></div></div><p>把session保存在客户端。这样一来，由于不需要在服务器上保存数据，每台服务器就变得独立，能够做到线性可扩展和极高的可用性。</p><p>具体怎么做呢？目前可用的方法，恐怕就是保存在cookie中了。但需要提醒的是，cookie具有有以下限制，因此不可无节制使用该方案：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p></li><li class="listitem"><p>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p></li><li class="listitem"><p>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p></li></ul></div><p>虽然有上述缺点，但是对于其优点（极高的扩展性和可用性）来说，就显得微不足道。我们可以用下面的方法来回避上述的缺点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>通过良好的编程，控制保存在cookie中的session对象的大小。</p></li><li class="listitem"><p>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</p></li><li class="listitem"><p>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</p></li><li class="listitem"><p>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9165"><!--anchor d0e9165--></a>8.1.2.4. 将客户端、服务器端组合的方案</h4></div></div></div><p>任何一种session方案都有其优缺点。最好的方法是把它们结合起来。这样就可以弥补各自的缺点。</p><p>将大部分session数据保存在cookie中，将小部分关键和涉及安全的数据保存在服务器上。由于我们只把少量关键的信息保存在服务端，因而服务器的压力不会非常大。</p><p>在服务器上，单一的数据源比复制session的方案，更简单可靠。我们可以使用数据库来保存这部分session，也可以使用更廉价、更简单的存储，例如Berkeley
                    DB就是一种不错的服务器存储方案。将session数据保存在cookie和Berkeley
                    DB（或其它类似存储技术）中，就可以解决我们的绝大部分问题。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9174"><!--anchor d0e9174--></a>8.1.3. 创建通用的session框架</h3></div></div></div><p>多数应用服务器并没有留出足够的余地，来让你自定义session的存储方案。纵使某个应用服务器提供了对外扩展的接口，可以自定义session的方案，我们也不大可能使用它。为什么呢？因为我们希望保留选择应用服务器软件的自由。</p><p>因此，最好的方案，不是在应用服务器上增加什么新功能，而是在WEB应用框架上做手术。一但我们在WEB应用框架中实现了这种灵活的session框架，那么我们的应用可以跑在任何标准的JavaEE应用服务器上。</p><p>除此之外，一个好的session框架还应该做到对应用程序透明。具体表现在：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>使用标准的<code class="code">HttpSession</code>接口，而不是增加新的API。这样任何WEB应用，都可以轻易在两种不同的session机制之间切换。</p></li><li class="listitem"><p>应用程序不需要知道session中的对象是被保存到了cookie中还是别的什么地方。</p></li><li class="listitem"><p>Session框架可以把同一个session中的不同的对象分别保存到不同的地方去，应用程序同样不需要关心这些。例如，把一般信息放到cookie中，关键信息放到Berkeley
                            DB中。甚至同是cookie，也有持久和临时之分，有生命期长短之分。 </p></li></ul></div><p>Webx实现了这种session框架，把它建立在Request Contexts的基础上。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e9198"><!--anchor d0e9198--></a>8.2. Session框架</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9201"><!--anchor d0e9201--></a>8.2.1. 最简配置</h3></div></div></div><div class="example"><a id="d0e9204"><!--anchor d0e9204--></a><p class="title"><strong>例 8.2. Session框架基本配置（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;stores&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;session-stores:simple-memory-store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"simple"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.store.simple1"><!--anchor co.session.store.simple1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/stores&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;store-mappings&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;match</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"*"</span> <span class="hl-attribute" style="color: #F5844C">store</span>=<span class="hl-value" style="color: #993300">"simple"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.store.simple1.maptoall"><!--anchor co.session.store.simple1.maptoall--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/store-mappings&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div><p>以上的配置，创建了一个最基本的session实现：将所有数据（<a id="co.session.store.simple1.maptoall"><!--anchor co.session.store.simple1.maptoall--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
                <code class="code">name=*</code>）保存在内存里（<a id="co.session.store.simple1"><!--anchor co.session.store.simple1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
                <code class="code">simple-memory-store</code>）。</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"/></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>最简配置只能用于开发，<span class="emphasis"><em>请不要将上述配置用在生产环境</em></span>。因为<code class="code">simple-memory-store</code>只是将数据保存在内存里。在生产环境中，内存有被耗尽的可能。这段配置也不支持服务器集群。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9237"><!--anchor d0e9237--></a>8.2.2. Session ID</h3></div></div></div><p>Session ID唯一标识了一个session对象。把session
                ID保存在cookie里是最方便的。这样，凡是cookie值相同的所有的请求，就被看作是在同一个session中的请求。在servlet中，还可以把session
                ID编码到URL中。Session框架既支持把session ID保存在cookie中，也支持把session ID编码到URL中。</p><p>完整的session ID配置如下： </p><div class="example"><a id="d0e9244"><!--anchor d0e9244--></a><p class="title"><strong>例 8.3. Session ID的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;id</strong> <span class="hl-attribute" style="color: #F5844C">cookieEnabled</span>=<span class="hl-value" style="color: #993300">"true"</span> <span class="hl-attribute" style="color: #F5844C">urlEncodeEnabled</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;cookie</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"JSESSIONID"</span> <span class="hl-attribute" style="color: #F5844C">domain</span>=<span class="hl-value" style="color: #993300">""</span> <span class="hl-attribute" style="color: #F5844C">maxAge</span>=<span class="hl-value" style="color: #993300">"0"</span> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"/"</span> <span class="hl-attribute" style="color: #F5844C">httpOnly</span>=<span class="hl-value" style="color: #993300">"true"</span> <span class="hl-attribute" style="color: #F5844C">secure</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url-encode</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"JSESSIONID"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-idgens:uuid-generator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/id&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong></pre></div></div><p>上面这段配置包含了关于Session ID的所有配置以及默认值。如果不指定上述参数，则系统将使用默认值，其效果等同于上述配置。</p><div class="table"><a id="d0e9251"><!--anchor d0e9251--></a><p class="title"><strong>表 8.1. Session ID的配置说明</strong></p><div class="table-contents"><table summary="Session ID的配置说明" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">配置<code class="code">&lt;session&gt;&lt;id&gt;</code> ——
                                将Session ID保存于何处？</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">cookieEnabled</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>是否把session ID保存在cookie中，如若不是，则只能保存的URL中。</p>
                                <p>默认为开启：<code class="code">true</code>。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">urlEncodeEnabled</code></td><td style="" valign="middle">
                                <p>是否支持把session
                                        ID编码在URL中。如果为<code class="code">true</code>开启，应用必须调用<code class="code">response.encodeURL()</code>或<code class="code">response.encodeRedirectURL()</code>来将<code class="code">JSESSIONID</code>编码到URL中。</p>
                                <p>默认为关闭：<code class="code">false</code>。</p>
                            </td></tr></tbody></table><table summary="Session ID的配置说明" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">配置<code class="code">&lt;session&gt;&lt;id&gt;&lt;cookie&gt;</code> —— 将Session
                                ID存放于cookie的设置</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">name</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>Session ID cookie的名称。</p>
                                <p>默认为<code class="code">JSESSIONID</code>。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">domain</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>Session ID cookie的domain。</p>
                                <p>默认为空，表示根据当前请求自动设置domain。这意味着浏览器认为你的cookie属于当前域名。如果你的应用包含多个子域名，例如：<code class="code">www.alibaba.com</code>、<code class="code">china.alibaba.com</code>，而你又希望它们能共享session的话，请把域名设置成“<code class="code">alibaba.com</code>”。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">maxAge</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>Session ID cookie的最长存活时间（秒）。</p>
                                <p>默认为<code class="code">0</code>，表示临时cookie，随浏览器的关闭而消失。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">path</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>Session ID cookie的path。</p>
                                <p>默认为<code class="code">/</code>，表示根路径。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">httpOnly</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>在session ID cookie上设置<code class="code">HttpOnly</code>标记。</p>
                                <p>在IE6及更新版本中，可以缓解XSS攻击的危险。默认为<code class="code">true</code>。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">secure</code></td><td style="" valign="middle">
                                <p>在session ID cookie上设置<code class="code">Secure</code>标记。</p>
                                <p>这样，只有在https请求中才可访问该cookie。默认为<code class="code">false</code>。</p>
                            </td></tr></tbody></table><table summary="Session ID的配置说明" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">配置<code class="code">&lt;session&gt;&lt;id&gt;&lt;url-encode&gt;</code> —— 将Session
                                ID编码到URL的设置</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">name</code></td><td style="" valign="middle">
                                <p>指定在URL中表示session ID的名字，默认也是<code class="code">JSESSIONID</code>。</p>
                                <p>此时，如果<code class="code">urlEncodeEnabled</code>为<code class="code">true</code>的话，调用：</p>
                                <pre class="programlisting">response.encodeURL(<strong class="hl-string"><em style="color:navy">"http://localhost:8080/test.jsp?id=1"</em></strong>)</pre>
                                <p>将得到类似这样的结果：</p>
                                <p>
                                    </p><pre class="screen">http://localhost:8080/test.jsp;JSESSIONID=xxxyyyzzz?id=1</pre><p>
                                </p>
                            </td></tr></tbody></table><table summary="Session ID的配置说明" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">配置<code class="code">&lt;session&gt;&lt;id&gt;&lt;session-idgens:*&gt;</code> ——
                                如何生成session ID？</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">uuid-generator</code></td><td style="" valign="middle">
                                <p>以UUID作为新session ID的生成算法。</p>
                                <p>这是默认的session ID生成算法。</p>
                            </td></tr></tbody></table></div></div><p>为了达到最大的兼容性，我们分两种情况来处理<code class="code">JSESSIONID</code>：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>当一个新session到达时，假如cookie或URL中已然包含了<code class="code">JSESSIONID</code>，那么我们将直接利用这个值。为什么这样做呢？因为这个<code class="code">JSESSIONID</code>可能是由同一域名下的另一个不相关应用生成的。如果我们不由分说地将这个cookie覆盖掉，那么另一个应用的session就会丢失。</p></li><li class="listitem"><p>多数情况下，对于一个新session，应该是不包含<code class="code">JSESSIONID</code>的。这时，我们需要利用<code class="code">SessionIDGenerator</code>来生成一个唯一的字符串，作为<code class="code">JSESSIONID</code>的值。<code class="code">SessionIDGenerator</code>的默认实现<code class="code">UUIDGenerator</code>。
                        </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9520"><!--anchor d0e9520--></a>8.2.3. Session的生命期</h3></div></div></div><p>所谓生命期，就是session从创建到失效的整个过程。其状态变迁如下图所示：</p><div class="figure"><a id="d0e9525"><!--anchor d0e9525--></a><div class="figure-contents"><div class="mediaobject"><img src="images/session/session-lifecycle.png" alt="Session生命期"/></div></div><p class="title"><strong>图 8.1. Session生命期</strong></p></div><p>总结一下，其实很简单：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>第一次打开浏览器时，<code class="code">JSESSIONID</code>还不存在，或者存在由同一域名下的其它应用所设置的无效的<code class="code">JSESSIONID</code>。这种情况下，<code class="code">session.isNew()</code>返回<code class="code">true</code>。</p></li><li class="listitem"><p>随后，只要在规定的时间间隔内，以及cookie过期之前，每一次访问系统，都会使session得到更新。此时<code class="code">session.isNew()</code>总是返回<code class="code">false</code>。Session中的数据得到保持。</p></li><li class="listitem"><p>如果用户有一段时间不访问系统了，超过指定的时间，那么系统会清除所有的session内容，并将session看作是新的session。</p></li><li class="listitem"><p>用户可以调用<code class="code">session.invalidate()</code>方法，直接清除所有的session内容。此后所有试图<code class="code">session.getAttribute()</code>或<code class="code">session.setAttribute()</code>等操作，都会失败，得到<code class="code">IllegalStateException</code>异常，直到下一个请求到来。</p></li></ol></div><p>在session框架中，有一个重要的特殊对象，用来保存session生命期的状态。这个对象叫作session
                    model。它被当作一个普通的对象存放在session中，但是通过<code class="code">HttpSession</code>接口不能直接看到它。</p><p>关于session生命期的完整配置如下：</p><div class="example"><a id="d0e9583"><!--anchor d0e9583--></a><p class="title"><strong>例 8.4. 关于Session生命期的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session</strong> <span class="hl-attribute" style="color: #F5844C">maxInactiveInterval</span>=<span class="hl-value" style="color: #993300">"0"</span> <span class="hl-attribute" style="color: #F5844C">keepInTouch</span>=<span class="hl-value" style="color: #993300">"false"</span> <span class="hl-attribute" style="color: #F5844C">forceExpirationPeriod</span>=<span class="hl-value" style="color: #993300">"14400"</span>
         <span class="hl-attribute" style="color: #F5844C">modelKey</span>=<span class="hl-value" style="color: #993300">"SESSION_MODEL"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong></pre></div></div><p>参数的意思是：</p><div class="table"><a id="d0e9590"><!--anchor d0e9590--></a><p class="title"><strong>表 8.2. Session生命期的配置参数</strong></p><div class="table-contents"><table summary="Session生命期的配置参数" cellpadding="10" style="border: none;"><colgroup><col width="29%" class="c1"/><col width="71%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">maxInactiveInterval</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>指定session不活动而失效的期限，单位是秒。</p>
                                <p>默认为<code class="code">0</code>，也就是永不失效（除非cookie失效）。例如，设置<code class="code">3600</code>秒，表示用户离开浏览器1小时以后再回来，session将重新开始，老数据将被丢弃。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">keepInTouch</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>是否每次都touch session（即更新最近访问时间）。</p>
                                <p>如果是<code class="code">false</code>，那么只在session值有改变时touch。当将session
                                        model保存在cookie中时，设为<code class="code">false</code>可以减少网络流量。但如果session值长期不改变，由于最近访问时间一直无法更新，将会使session超过<code class="code">maxInactiveInterval</code>所设定的秒数而失效。</p>
                                <p>默认为<code class="code">false</code>。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">forceExpirationPeriod</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>指定session强制作废期限，单位是秒。</p>
                                <p>无论用户活动与否，从session创建之时算起，超过这个期限，session将被强制作废。这是一个安全选项：万一cookie被盗，过了这个期限的话，那么无论如何，被盗的cookie就没有用了。</p>
                                <p>默认为<code class="code">0</code>，表示无期限。 </p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">modelKey</code></td><td style="" valign="middle">
                                <p>指定用于保存session状态的对象的名称。</p>
                                <p>默认为"<code class="code">SESSION_MODEL</code>"。一般没必要修改这个值。 </p>
                            </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9681"><!--anchor d0e9681--></a>8.2.4. Session Store</h3></div></div></div><p>Session Store是session框架中最核心的部分。Session框架最强大的部分就在于此。我们可以定义很多个session
                stores，让不同的session对象分别存放到不同的Session
                Store中。前面提到有一个特殊的对象“<code class="code">SESSION_MODEL</code>”也必须保存在一个session store中。</p><div class="figure"><a id="d0e9689"><!--anchor d0e9689--></a><div class="figure-contents"><div class="mediaobject"><img src="images/session/session-stores.png" alt="Session和Stores"/></div></div><p class="title"><strong>图 8.2. Session和Stores</strong></p></div><p>类似于Servlet的配置，Session store的配置也包含两部分内容：session store的定义，和session
                store的映射（mapping）。</p><div class="example"><a id="d0e9697"><!--anchor d0e9697--></a><p class="title"><strong>例 8.5. Session Store的配置</strong></p><div class="example-contents"><pre class="programlisting">    <strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;stores&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;session-stores:store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"store1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.stores.store1"><!--anchor co.session.stores.store1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;session-stores:store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"store2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.stores.store2"><!--anchor co.session.stores.store2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;session-stores:store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"store3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.stores.store3"><!--anchor co.session.stores.store3--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/stores&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;store-mappings&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;match</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"*"</span> <span class="hl-attribute" style="color: #F5844C">store</span>=<span class="hl-value" style="color: #993300">"store1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.stores.store1.mapping"><!--anchor co.session.stores.store1.mapping--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;match</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"loginName"</span> <span class="hl-attribute" style="color: #F5844C">store</span>=<span class="hl-value" style="color: #993300">"store2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.stores.store2.mapping"><!--anchor co.session.stores.store2.mapping--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;matchRegex</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"key.*"</span> <span class="hl-attribute" style="color: #F5844C">store</span>=<span class="hl-value" style="color: #993300">"store3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.stores.store3.mapping"><!--anchor co.session.stores.store3.mapping--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/store-mappings&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.stores.store1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.session.stores.store2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.session.stores.store3"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义session stores：你可以配置任意多个session
                                store，只要ID不重复。此处，<code class="code">store1</code>、<code class="code">store2</code>和<code class="code">store3</code>分别是三个session
                            store的名称。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.stores.store1.mapping"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> <a href="#co.session.stores.store2.mapping"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>映射session stores：<code class="code">match</code>标签用来精确匹配attribute
                                name。一个特别的值是“<code class="code">*</code>”，它代表默认匹配所有的names。</p><p>本例中， 如果调用<code class="code">session.setAttribute("loginName",
                                user.getId())</code>，那么这个值将被保存到<code class="code">store2</code>里；如果调用<code class="code">session.setAttribute("other",
                                value)</code>将被默认匹配到<code class="code">store1</code>中。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.stores.store3.mapping"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>映射session stores：<code class="code">matchRegexp</code>标签用正则表达式来匹配attribute
                            names。</p><p>本例中，
                            <code class="code">key_a</code>、<code class="code">key_b</code>等值都将被保存到<code class="code">store3</code>里。</p></td></tr></table></div></div></div><p>需要注意以下几点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>在整个session配置中，只能有一个store拥有默认的匹配</em></span>。</p></li><li class="listitem"><p>假如有多个<code class="code">match</code>或<code class="code">matchRegex</code>同时匹配某个attribute name，那么遵循以下匹配顺序：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>精确的匹配</em></span>最优先。</p></li><li class="listitem"><p>正则表达式的匹配遵循最大匹配的原则，假如有两个以上的正则表达式被同时匹配，<span class="emphasis"><em>长度较长的匹配</em></span>胜出。</p></li><li class="listitem"><p><span class="emphasis"><em>默认匹配<code class="code">*</code></em></span>总是在所有的匹配都失败以后才会被激活。
                                    </p></li></ol></div></li><li class="listitem"><p>必须有一个session store能够用来存放session model。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>你可以用<code class="code">&lt;match name="*"&gt;</code>来匹配session
                                        model；</p></li><li class="listitem"><p>也可以用精确匹配：<code class="code">&lt;match name="SESSION_MODEL"
                                        /&gt;</code>。其中session
                                            model的名字是必须和前述modelKey配置的值相同，其默认值为“<code class="code">SESSION_MODEL</code>”。
                                    </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9822"><!--anchor d0e9822--></a>8.2.5. Session Model</h3></div></div></div><p>Session Model是用来记录当前session的生命期数据的，例如：session的创建时间、最近更新时间等。默认情况下，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>当需要保存session数据时，<code class="code">SessionModel</code>对象将被转换成一个JSON字符串（如下所示），然后这个字符串将被保存在某个session
                            store中：</p><pre class="screen">{id:<strong class="hl-string"><em style="color:navy">"SESSION_ID"</em></strong>,ct:创建时间,ac:最近访问时间,mx:最长不活动时间}</pre></li><li class="listitem"><p>需要读取时，先从store中读到上述格式的字符串数据，然后再把它解码成真正的<code class="code">SessionModel</code>对象。</p></li></ul></div><p>以上转换过程是通过一个<code class="code">SessionModelEncoder</code>接口来实现的。为了提供更好的移植性，Session框架可同时支持多个<code class="code">SessionModelEncoder</code>的实现。配置如下：</p><div class="example"><a id="d0e9850"><!--anchor d0e9850--></a><p class="title"><strong>例 8.6. Session Model编码器的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-model-encoders&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;model-encoders:default-session-model-encoder /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;model-encoders:model-encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;model-encoders:model-encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session-model-encoders&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong></pre></div></div><p>在上面的例子中，提供了三个<code class="code">SessionModelEncoder</code>的实现。第一个是默认的实现，第二、第三个是任意实现。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>当从store取得<code class="code">SessionModel</code>对象时，框架将依次尝试所有的encoder，直到解码成功为止。</p></li><li class="listitem"><p>当将<code class="code">SessionModel</code>对象保存到store之前，框架将使用第一个encoder来编码对象。</p></li></ul></div><p>当你从不同的<code class="code">SessionModel</code>编码方案中移植的时候，上述多encoders共存的方案可以实现平滑的过渡。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9878"><!--anchor d0e9878--></a>8.2.6. Session Interceptor</h3></div></div></div><p>Session Interceptor拦截器的作用是拦截特定的事件，甚至干预该事件的执行结果。目前有两种拦截器接口：</p><div class="table"><a id="d0e9883"><!--anchor d0e9883--></a><p class="title"><strong>表 8.3. Session Interceptor拦截器接口</strong></p><div class="table-contents"><table summary="Session Interceptor拦截器接口" cellpadding="10" style="border: none;"><colgroup><col width="35%" class="c1"/><col width="65%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">接口</th><th style="border-bottom: 0.5pt solid #6666cc; ">功能</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">SessionLifecycleListener</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>监听以下session生命期事件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Session被创建</p></li><li class="listitem"><p>Session被访问</p></li><li class="listitem"><p>Session被作废 </p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">SessionAttributeInterceptor</code></td><td style="" valign="middle">
                                <p>拦截以下session读写事件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">onRead</code> –
                                                  拦截<code class="code">session.getAttribute()</code>方法，可以修改所读取的数据。</p></li><li class="listitem"><p><code class="code">onWrite</code> –
                                                  拦截<code class="code">session.setAttribute()</code>方法，可以修改所写到store中的数据。
                                            </p></li></ul></div>
                            </td></tr></tbody></table></div></div><p>Session框架自身已经提供了两个有用的拦截器：</p><div class="table"><a id="d0e9943"><!--anchor d0e9943--></a><p class="title"><strong>表 8.4. Session Interceptor的实现</strong></p><div class="table-contents"><table summary="Session Interceptor的实现" cellpadding="10" style="border: none;"><colgroup><col width="35%" class="c1"/><col width="65%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;lifecycle-logger&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p>监听session生命期事件，并记录日志。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;attribute-whitelist&gt;</code></td><td style="" valign="middle">
                                <p>控制session中的attributes，只允许白名单中所定义的attribute名称和类型被写入到或读出于session
                                    store中。</p>
                                <p>这个功能对于cookie
                                    store是很有用的。因为cookie有长度的限制，所以需要用白名单来限制写入到cookie中的数据数量和类型。 </p>
                            </td></tr></tbody></table></div></div><p>你可以同时配置多种拦截器，如下所示。</p><div class="example"><a id="d0e9979"><!--anchor d0e9979--></a><p class="title"><strong>例 8.7. 配置session interceptors</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;request-contexts:interceptors</strong>
        <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts/session/interceptors"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;lifecycle-logger /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;attribute-whitelist&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;attribute</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"_csrf_token"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;attribute</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"_lang"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;attribute</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"loginUser"</span> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"com.alibaba...MyUser"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;attribute</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"shoppingCart"</span> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"com.alibaba....ShoppingCart"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/attribute-whitelist&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

  <strong class="hl-tag" style="color: #000096">&lt;/request-contexts:interceptors&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong></pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e9984"><!--anchor d0e9984--></a>8.3. Cookie Store</h2></div></div></div><p>Cookie Store的作用，是将session对象保存在客户端cookie中。Cookie
            Store减轻了服务器维护session数据的压力，从而提高了应用的扩展性和可用性。</p><p>另一方面，在现实应用中，很多地方都会直接读写cookie。读写cookie是一件麻烦的事，因为你必须要设置很多参数：<code class="code">domain</code>、<code class="code">path</code>、<code class="code">httpOnly</code>...等很多参数。而操作<code class="code">HttpSession</code>是一件相对简单的事。因此，<span class="emphasis"><em>webx主张把一切对cookie的读写，都转换成对session的读写</em></span>。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10006"><!--anchor d0e10006--></a>8.3.1. 多值Cookie Store</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10009"><!--anchor d0e10009--></a>8.3.1.1. 最简配置</h4></div></div></div><div class="example"><a id="d0e10012"><!--anchor d0e10012--></a><p class="title"><strong>例 8.8. 最基本的cookie配置（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong> <a id="co.session.dep.buffered"><!--anchor co.session.dep.buffered--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong> <a id="co.session.dep.lazycommit"><!--anchor co.session.dep.lazycommit--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;stores&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie-store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"temporaryClientStore"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"tmp"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/session-stores:cookie-store&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/stores&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;store-mappings&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;match</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"*"</span> <span class="hl-attribute" style="color: #F5844C">store</span>=<span class="hl-value" style="color: #993300">"temporaryClientStore"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/store-mappings&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div><p>上面的配置创建了一个“临时”cookie（即随着浏览器关闭而清除），来作为默认的session对象的存储。</p><p><span class="emphasis"><em>Cookie Store依赖其它两个Request Contexts：<a id="co.session.dep.buffered"><!--anchor co.session.dep.buffered--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
                        <code class="code">&lt;buffered&gt;</code> 和 <a id="co.session.dep.lazycommit"><!--anchor co.session.dep.lazycommit--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
                        <code class="code">&lt;lazy-commit&gt;</code></em></span>。没有它们，就不能实现基于cookie的session。为什么呢？这要从HTTP协议谈起。下面是一个标准的HTTP响应的文本。无论你的服务器使用了何种平台（Apache
                    HTTPD Server、Java Servlet/JSP、Microsoft
                    IIS，……），只要你通过浏览器来访问，必须返回类似下面的HTTP响应：</p><pre class="screen">HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=AywiPrQKPEzfF9OZ; Path=/
Content-Type: text/html;charset=GBK
Content-Language: zh-CN
Content-Length: 48
Date: Mon, 06 Nov 2006 07:59:38 GMT


&lt;html&gt;
&lt;body&gt;
……</pre><p>我们注意到，HTTP响应分为Header和Content两部分。从“<code class="code">HTTP/1.1 200
                        OK</code>”开始，到“<code class="code">&lt;html&gt;</code>”之前，都是HTTP
                    <span class="emphasis"><em>Header</em></span>，后面则为HTTP
                    <span class="emphasis"><em>Content</em></span>。而cookie是在header中指定的。一但应用服务器开始向浏览器输出content，那就再也没有机会修改header了。问题就出在这里。作为session的cookie可以在应用程序的任何时间被修改，甚至可能在content开始输出之后被修改。但是此后修改的session将不能被保存到cookie中。</p><p>Java Servlet
                        API的术语称“应用服务器开始输出content”为“response被提交”。你可以通过<code class="code">response.isCommitted()</code>方法来判断这一点。那么，哪些操作会导致response被提交呢？</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>向<code class="code">response.getWriter()</code>或<code class="code">getOutputStream()</code>所返回的流中输出，累计达到服务器所设定的一个chunk的大小，通常为<code class="code">8K</code>。</p></li><li class="listitem"><p>用户程序或系统调用<code class="code">response.flushBuffer()</code>。</p></li><li class="listitem"><p>用户程序或系统调用<code class="code">response.sendError()</code>转到错误页面。</p></li><li class="listitem"><p>用户程序或系统调用<code class="code">response.sendRedirect()</code>重定向。 </p></li></ul></div><p>只要避免上述情形的出现，就可以确保cookie可以被随时写入。前两个Request Contexts ——
                        <code class="code">&lt;buffered&gt;</code>和<code class="code">&lt;lazy-commit&gt;</code>正好解决了上面的问题。第一个<code class="code">&lt;buffered&gt;</code>将所有的输出到<code class="code">response.getWriter()</code>或<code class="code">getOutputStream()</code>的内容缓存在内存里，直到最后一刻才真正输出到浏览器；第二个<code class="code">&lt;lazy-commit&gt;</code>拦截了response对象中引起提交的方法，将它们延迟到最后才执行。这样就保证了在cookie被完整写入之前，response绝不会被任何因素提交。</p><p>此外，<code class="code">&lt;buffered&gt;</code>不是专为session框架而设计的。Webx的页面布局系统也依赖于这个Request
                    Context。 </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10116"><!--anchor d0e10116--></a>8.3.1.2. Cookie的参数</h4></div></div></div><div class="example"><a id="d0e10119"><!--anchor d0e10119--></a><p class="title"><strong>例 8.9. Cookie的参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie-store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"temporaryClientStore"</span>
        <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"3896"</span> <span class="hl-attribute" style="color: #F5844C">maxCount</span>=<span class="hl-value" style="color: #993300">"5"</span> <span class="hl-attribute" style="color: #F5844C">checksum</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"tmp"</span> <span class="hl-attribute" style="color: #F5844C">domain</span>=<span class="hl-value" style="color: #993300">""</span> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"/"</span> <span class="hl-attribute" style="color: #F5844C">maxAge</span>=<span class="hl-value" style="color: #993300">"0"</span> <span class="hl-attribute" style="color: #F5844C">httpOnly</span>=<span class="hl-value" style="color: #993300">"true"</span>
        <span class="hl-attribute" style="color: #F5844C">secure</span>=<span class="hl-value" style="color: #993300">"false"</span> <span class="hl-attribute" style="color: #F5844C">survivesInInvalidating</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/session-stores:cookie-store&gt;</strong></pre></div></div><p>上例中列出了所有关于cookie的参数，解释如下：</p><div class="table"><a id="d0e10126"><!--anchor d0e10126--></a><p class="title"><strong>表 8.5. Cookie的参数</strong></p><div class="table-contents"><table summary="Cookie的参数" cellpadding="10" style="border: none;"><colgroup><col width="29%" class="c1"/><col width="45%" class="c2"/><col width="26%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名称</th><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">name</code></td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">
                                    <p>指定cookie的名称。</p>
                                    <p>假设名称为“<code class="code">tmp</code>”，那么将生成<code class="code">tmp0</code>、<code class="code">tmp1</code>、<code class="code">tmp2</code>等cookie。</p>
                                    <p>多个cookie stores的cookie名称不能重复。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">domain</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>指定cookie的域名。</p>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="5" valign="middle">
                                    <p>这几个参数的默认值，均和Session ID
                                            cookie的设置相同。因此，<span class="emphasis"><em>一般不需要特别设置它们</em></span>。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">path</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>指定cookie的路径。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">maxAge</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>指定cookie的过期时间，单位是秒。</p>
                                    <p>如果值为<code class="code">0</code>，意味着cookie持续到浏览器被关闭（或称临时cookie）。</p>
                                    <p>有效值必须大于<code class="code">0</code>，否则均被认为是临时cookie。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">httpOnly</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>在cookie上设置<code class="code">HttpOnly</code>标记。</p>
                                    <p>在IE6及更新版本中，可以缓解XSS攻击的危险。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">secure</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>在cookie上设置<code class="code">Secure</code>标记。</p>
                                    <p>这样，只有在https请求中才可访问该cookie。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">survivesInInvalidating</code></td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">
                                    <p>这是一个特殊的设置。如果它被设置成<code class="code">true</code>，那么当session被作废（invalidate）时，这个cookie
                                        store中的对象会幸存下来，并带入下一个新的session中。</p>
                                    <p>如果这个值为<code class="code">true</code>，必须同时设置一个大于<code class="code">0</code>的<code class="code">maxAge</code>。</p>
                                    <p>这个设置有什么用呢？比如，我们希望在cookie中记录最近登录的用户名，以方便用户再次登录。可以把这个用户名记录在一个cookie
                                            store中，并设置<code class="code">survivesInInvalidating=true</code>。即使用户退出登录，或当前session过期，新的session仍然可以读到这个store中所保存的对象。
                                    </p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">maxLength</code></td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">
                                    <p>指定每个cookie的最大长度。默认为<code class="code">3896</code>，约<code class="code">3.8K</code>。</p>
                                    <p>Cookie
                                            store会把所有对象序列化到cookie中。但是cookie的长度是不能超过<code class="code">4K</code>的。如果cookie的长度超过这个设定，就把数据分发到新的cookie中去。因此每个cookie
                                        store实际可能产生好几个cookie。</p>
                                    <p>假设cookie
                                            name为<code class="code">tmp</code>，那么所生成的cookie的名称将分别为：<code class="code">tmp0</code>、<code class="code">tmp1</code>、<code class="code">tmp2</code>，以此类推。
                                    </p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">maxCount</code></td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">
                                    <p>指定cookie的最大个数。默认为<code class="code">5</code>。</p>
                                    <p>因此，实际cookie store可生成的cookie总长度为：<code class="code">maxLength *
                                            maxCount</code>。如果超过这个长度，cookie
                                            store将会在日志里面发出警告（<code class="code">WARN</code>级别），并忽略store中的所有对象。
                                    </p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">checksum</code></td><td style="" colspan="2" valign="middle">
                                    <p>是否创建概要cookie。默认为<code class="code">false</code>。</p>
                                    <p>有时由于域名、路径等设置的问题，会导致cookie紊乱。例如：发现同名的cookie、cookie缺失等错误。这些问题很难跟踪。概要cookie就是为检查这类问题提供一个线索。如果把这个开关打开，将会产生一个概要性的cookie。假如cookie
                                            name为<code class="code">tmp</code>，那么概要cookie的名字将是<code class="code">tmpsum</code>。概要cookie会指出当前store共有几个cookie，每个cookie的前缀等内容。当cookie的总数和内容与概要cookie不符时，系统将会在日志中提出详细的警告信息（<code class="code">DEBUG</code>级别）。</p>
                                    <p>请尽量不要在生产系统中使用这个功能。 </p>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10358"><!--anchor d0e10358--></a>8.3.1.3. Session Encoders</h4></div></div></div><p>Session里保存的是Java对象，而cookie中只能保存字符串。如何把Java对象转换成合法的cookie字符串（或者将字符串恢复成对象）呢？这就是Session
                    Encoder所要完成的任务。</p><div class="example"><a id="d0e10363"><!--anchor d0e10363--></a><p class="title"><strong>例 8.10. 配置Session Encoders</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie-store&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-encoders:encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-encoders:encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-encoders:encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:cookie-store&gt;</strong></pre></div></div><p>和<code class="code">SessionModelEncoder</code>类似，session框架也支持多个session encoders同时存在。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>保存session数据时，session框架将使用第一个encoder来将对象转换成cookie可接受的字符串；</p></li><li class="listitem"><p>读取session数据时，session框架将依次尝试所有的encoders，直到解码成功为止。</p></li></ul></div><p>这种编码、解码方案可让使用不同session encoders的系统之间共享cookie数据，也有利于平滑迁移系统。</p><p>Session框架提供了一种encoder的实现，编码的基本过程为：序列化、加密（可选）、压缩、Base64编码、URL
                    encoding编码。</p><div class="example"><a id="d0e10384"><!--anchor d0e10384--></a><p class="title"><strong>例 8.11. 配置Session Encoders的几种方案</strong></p><div class="example-contents"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>基本配置：用hessian算法（默认）来序列化，不加密。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie-store&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-encoders:serialization-encoder /&gt;</strong> <a id="co.session.encoders.default"><!--anchor co.session.encoders.default--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:cookie-store&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.encoders.default"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这是默认实现。</p></td></tr></table></div></li><li class="listitem"><p>用aes算法加密。AES算法可支持<code class="code">128</code>、<code class="code">192</code>、<code class="code">256</code>位的密钥，默认为<code class="code">keySize=128</code>。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie-store&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-encoders:serialization-encoder&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;session-serializers:hessian-serializer /&gt;</strong> <a id="co.session.encoders.hession"><!--anchor co.session.encoders.hession--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;session-encrypters:aes-encrypter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"0123456789abcdef"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.encoders.aes"><!--anchor co.session.encoders.aes--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/session-encoders:serialization-encoder&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:cookie-store&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.encoders.hession"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>也可以明确指定hession序列化。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.encoders.aes"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>添加AES加密算法，并提供密钥。</p></td></tr></table></div></li><li class="listitem"><p>改用java原生的序列化算法。使用hessian算法（默认）可大幅缩短序列化的长度，但使用java原生的序列化算法，具有最好的可移植性。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie-store&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-encoders:serialization-encoder&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;session-serializers:java-serializer /&gt;</strong> <a id="co.session.encoders.java"><!--anchor co.session.encoders.java--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/session-encoders:serialization-encoder&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:cookie-store&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.encoders.java"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定java序列化。</p></td></tr></table></div></li></ul></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10438"><!--anchor d0e10438--></a>8.3.2. 单值Cookie Store</h3></div></div></div><p>前面所描述的cookie store，是在一组cookie（如<code class="code">tmp0</code>, <code class="code">tmp1</code>,
                ...）中保存一组attributes的名称和对象。它所创建的cookie值，只有session框架自己才能解读。</p><p>假如有一些非webx的代码想要共享保存在cookie中的session数据，例如，Java
                Script代码、其它未使用webx框架的应用，希望能读取session数据，应该怎么办呢？Session框架提供了一种相对简单的“单值cookie
                store”可用来解决这个问题。顾名思义，单值cookie store就是在一个cookie中仅保存一个值或对象。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10451"><!--anchor d0e10451--></a>8.3.2.1. 最简配置</h4></div></div></div><div class="example"><a id="d0e10454"><!--anchor d0e10454--></a><p class="title"><strong>例 8.12. 单值cookie store基本配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;stores&gt;</strong>
        ...
        <strong class="hl-tag" style="color: #000096">&lt;stores:single-valued-cookie-store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"loginNameCookie"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.session.singlevalued.cookie.store"><!--anchor co.session.singlevalued.cookie.store--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;stores:cookie</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"login"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie"><!--anchor co.session.singlevalued.cookie--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/stores:single-valued-cookie-store&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/stores&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;store-mappings&gt;</strong>
        ...
        <strong class="hl-tag" style="color: #000096">&lt;match</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"loginName"</span> <span class="hl-attribute" style="color: #F5844C">store</span>=<span class="hl-value" style="color: #993300">"loginNameCookie"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie.store.mapping"><!--anchor co.session.singlevalued.cookie.store.mapping--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/store-mappings&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>单值cookie store的ID是<code class="code">loginNameCookie</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Cookie的名称是<code class="code">login</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.mapping"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Session
                                attribute的名称是<code class="code">loginName</code>，attribute名称和cookie名称不必相同。</p></td></tr></table></div></div></div><p>根据上面的配置，下面程序会生成cookie：<code class="code">login=myname</code>。</p><div class="example"><a id="d0e10489"><!--anchor d0e10489--></a><p class="title"><strong>例 8.13. 访问单值cookie的代码</strong></p><div class="example-contents"><pre class="programlisting">session.setAttribute(<strong class="hl-string"><em style="color:navy">"loginName"</em></strong>, <strong class="hl-string"><em style="color:navy">"myname"</em></strong>);</pre></div></div><p>需要注意的是，上述最简配置，只能用来存取字符串值。如果需要存取其它类型的对象，则需要配置Session Value Encoder。详见<a class="xref" href="#webx.requestcontexts.session.value.encoders" title="8.3.2.3. Session Value Encoders">第 8.3.2.3 节 “Session Value Encoders”</a>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10498"><!--anchor d0e10498--></a>8.3.2.2. Cookie的参数</h4></div></div></div><div class="example"><a id="d0e10501"><!--anchor d0e10501--></a><p class="title"><strong>例 8.14. 单值cookie的参数配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:single-valued-cookie-store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"loginNameCookie"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;session-stores:cookie</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"login"</span> <span class="hl-attribute" style="color: #F5844C">domain</span>=<span class="hl-value" style="color: #993300">""</span> <span class="hl-attribute" style="color: #F5844C">path</span>=<span class="hl-value" style="color: #993300">"/"</span> <span class="hl-attribute" style="color: #F5844C">maxAge</span>=<span class="hl-value" style="color: #993300">"0"</span> <span class="hl-attribute" style="color: #F5844C">httpOnly</span>=<span class="hl-value" style="color: #993300">"true"</span>
        <span class="hl-attribute" style="color: #F5844C">secure</span>=<span class="hl-value" style="color: #993300">"false"</span> <span class="hl-attribute" style="color: #F5844C">survivesInInvalidating</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/session-stores:single-valued-cookie-store&gt;</strong></pre></div></div><p>单值cookie的参数设置完全类似于普通cookie store的设置。唯一的差别是，单值cookie只生成一个cookie，而普通的cookie
                    store则可能生成多个相关的cookies。</p><div class="table"><a id="d0e10508"><!--anchor d0e10508--></a><p class="title"><strong>表 8.6. Cookie的参数</strong></p><div class="table-contents"><table summary="Cookie的参数" cellpadding="10" style="border: none;"><colgroup><col width="29%" class="c1"/><col width="45%" class="c2"/><col width="26%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名称</th><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">name</code></td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">
                                    <p>指定cookie的名称。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">domain</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>指定cookie的域名。</p>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="5" valign="middle">
                                    <p>这几个参数的默认值，均和Session ID
                                            cookie的设置相同。因此，<span class="emphasis"><em>一般不需要特别设置它们</em></span>。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">path</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>指定cookie的路径。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">maxAge</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>指定cookie的过期时间，单位是秒。</p>
                                    <p>如果值为<code class="code">0</code>，意味着cookie持续到浏览器被关闭（或称临时cookie）。</p>
                                    <p>有效值必须大于<code class="code">0</code>，否则均被认为是临时cookie。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">httpOnly</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>在cookie上设置<code class="code">HttpOnly</code>标记。</p>
                                    <p>在IE6及更新版本中，可以缓解XSS攻击的危险。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">secure</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                    <p>在cookie上设置<code class="code">Secure</code>标记。</p>
                                    <p>这样，只有在https请求中才可访问该cookie。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">survivesInInvalidating</code></td><td style="" colspan="2" valign="middle">
                                    <p>这是一个特殊的设置。如果它被设置成<code class="code">true</code>，那么当session被作废（invalidate）时，这个cookie
                                        store中的对象会幸存下来，并带入下一个新的session中。</p>
                                    <p>如果这个值为<code class="code">true</code>，必须同时设置一个大于<code class="code">0</code>的<code class="code">maxAge</code>。</p>
                                    <p>这个设置有什么用呢？比如，我们希望在cookie中记录最近登录的用户名，以方便用户再次登录。可以把这个用户名记录在一个cookie
                                            store中，并设置<code class="code">survivesInInvalidating=true</code>。即使用户退出登录，或当前session过期，新的session仍然可以读到这个store中所保存的对象。
                                    </p>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.requestcontexts.session.value.encoders"><!--anchor webx.requestcontexts.session.value.encoders--></a>8.3.2.3. Session Value Encoders</h4></div></div></div><p>单值cookie
                    store可以保存任意的Java对象，只要这个Java对象能够被转换成字符串，以及从字符串中恢复。将Java对象转换成字符串，以及从字符串中恢复，就是Session
                    Value Encoder的任务。和前面所说的Session Encoder不同，Session Value Encoder只转换session
                    attribute的值，而Session Encoder需要转换一组session attributes的key-values。</p><div class="example"><a id="d0e10643"><!--anchor d0e10643--></a><p class="title"><strong>例 8.15. Session Value Encoders的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:single-valued-cookie-store&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:encoder</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:single-valued-cookie-store&gt;</strong></pre></div></div><p>和<code class="code">SessionModelEncoder</code>以及<code class="code">SessionEncoder</code>类似，session框架也支持多个session
                    value encoders同时存在。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>保存session数据时，session框架将使用第一个encoder来将对象转换成cookie可接受的字符串；</p></li><li class="listitem"><p>读取session数据时，session框架将依次尝试所有的encoders，直到解码成功为止。</p></li></ul></div><p>这种编码、解码方案可让使用不同session value encoders的系统之间共享cookie数据，也有利于平滑迁移系统。</p><p>目前有两种基本的session value
                        encoders实现。<code class="code">&lt;simple-value-encoder&gt;</code>和<code class="code">&lt;mapped-values-encoder&gt;</code>。下面举例说明。 </p><div class="example"><a id="d0e10673"><!--anchor d0e10673--></a><p class="title"><strong>例 8.16. 配置Session Value Encoders的几种方案</strong></p><div class="example-contents"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>编码字符串值，以指定的charset对字符串进行URL encoding。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:simple-value-encoder</strong> <span class="hl-attribute" style="color: #F5844C">charset</span>=<span class="hl-value" style="color: #993300">"GBK"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie.store.encoders.simple"><!--anchor co.session.singlevalued.cookie.store.encoders.simple--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.encoders.simple"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如不指定<code class="code">charset</code>参数，默认charset为“<code class="code">UTF-8</code>”。</p></td></tr></table></div></li><li class="listitem"><p>编码指定类型的值，该值具有默认的<code class="code">PropertyEditor</code>，可以转换成<code class="code">String</code>，或从<code class="code">String</code>中恢复。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:simple-value-encoder</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"com.alibaba...MyEnum"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie.store.encoders.simple.enum"><!--anchor co.session.singlevalued.cookie.store.encoders.simple.enum--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.encoders.simple.enum"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Spring直接支持将<code class="code">Enum</code>类型的值转成<code class="code">String</code>类型，或反之。</p></td></tr></table></div></li><li class="listitem"><p>编码指定类型的值，注册相应的registrar来进行类型转换。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:simple-value-encoder</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"java.util.Date"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:property-editor-registrar</strong>
            <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.configuration.support.CustomDateRegistrar"</span>
            <span class="hl-attribute" style="color: #F5844C">p:timeZone</span>=<span class="hl-value" style="color: #993300">"GMT+8"</span> <span class="hl-attribute" style="color: #F5844C">p:format</span>=<span class="hl-value" style="color: #993300">"yyyy-MM-dd"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie.store.encoders.simple.registrar"><!--anchor co.session.singlevalued.cookie.store.encoders.simple.registrar--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/session-value-encoders:simple-value-encoder&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.encoders.simple.registrar"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>注册registrar，将<code class="code">Date</code>类型按格式<code class="code">yyyy-MM-dd</code>转成字符串，或从该格式的字符串中恢复。</p></td></tr></table></div></li><li class="listitem"><p>在上面例子的基础上，可增加encrypter，对value进行加密。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:simple-value-encoder</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"java.util.Date"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:property-editor-registrar</strong>
            <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.configuration.support.CustomDateRegistrar"</span>
            <span class="hl-attribute" style="color: #F5844C">p:timeZone</span>=<span class="hl-value" style="color: #993300">"GMT+8"</span> <span class="hl-attribute" style="color: #F5844C">p:format</span>=<span class="hl-value" style="color: #993300">"yyyy-MM-dd"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

        <strong class="hl-tag" style="color: #000096">&lt;session-encrypters:aes-encrypter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"0123456789abcdef"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie.store.encoders.simple.aes"><!--anchor co.session.singlevalued.cookie.store.encoders.simple.aes--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;/session-value-encoders:simple-value-encoder&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.encoders.simple.aes"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>用AES和指定密钥进行加密。</p></td></tr></table></div></li><li class="listitem"><p><code class="code">&lt;mapped-values-encoder&gt;</code>和<code class="code">&lt;simple-value-encoder&gt;</code>类似，差别在于，前者只接受<code class="code">java.util.Map</code>数据类型，并将其编码成“<code class="code">key:value&amp;key:value</code>”的格式。下面的例子可接受<code class="code">Map&lt;String,
                                    Date&gt;</code>类型的数据：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;session-stores:encoders&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-value-encoders:mapped-values-encoder</strong> <span class="hl-attribute" style="color: #F5844C">valueType</span>=<span class="hl-value" style="color: #993300">"com.alibaba...MyEnum"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.session.singlevalued.cookie.store.encoders.mapped"><!--anchor co.session.singlevalued.cookie.store.encoders.mapped--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/session-stores:encoders&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.encoders.mapped"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>注意此处所指定的类型为map中的value的类型。</p></td></tr></table></div><p>当你用下面的代码，可设置cookie值“<code class="code">key1:value1&amp;key2:value2</code>”：</p><pre class="programlisting">Map&lt;String, MyEnum&gt; mappedValue = <strong class="hl-keyword" style="color: maroon">new</strong> HashMap&lt;String, MyEnum&gt;();

mappedValue.put(<strong class="hl-string"><em style="color:navy">"key1"</em></strong>, MyEnum.value1);
mappedValue.put(<strong class="hl-string"><em style="color:navy">"key2"</em></strong>, MyEnum.value2);

session.setAttribute(<strong class="hl-string"><em style="color:navy">"cookie"</em></strong>, mappedValue); <a id="co.session.singlevalued.cookie.store.encoders.mapped.code"><!--anchor co.session.singlevalued.cookie.store.encoders.mapped.code--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.session.singlevalued.cookie.store.encoders.mapped.code"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将整个map作为session
                                        attribute的值，其中，map的value类型必须符合配置文件中指定的类型。</p></td></tr></table></div></li><li class="listitem"><p>类似的，你同样可以对<code class="code">&lt;mapped-values-encoder&gt;</code>指定registrar和encrypter，不再赘述。</p></li></ul></div></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e10791"><!--anchor d0e10791--></a>8.4. 其它Session Store</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10794"><!--anchor d0e10794--></a>8.4.1. Simple Memory Store</h3></div></div></div><p><code class="code">SimpleMemoryStore</code>是最简单的session
                store。它将所有的session对象都保存在内存里面。这种store不支持多台机器的session同步，而且也不关心内存是否被用尽。因此这种简单的store一般只应使用于测试环境。</p><div class="example"><a id="d0e10801"><!--anchor d0e10801--></a><p class="title"><strong>例 8.17. 配置simple memory store</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;stores&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session-stores:simple-memory-store</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"simple"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/stores&gt;</strong></pre></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"/></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>鉴于<code class="code">simple-memory-store</code>的实现的简单性，<span class="emphasis"><em>请不要将它应用在生产环境</em></span>。</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e10815"><!--anchor d0e10815--></a>8.5. 本章总结</h2></div></div></div><p>Session是个难题，特别是对于要求高扩展性和高可用性的网站来说。</p><p>我们在标准的Java Servlet
            API的基础之上，实现了一套全新的session框架。在此基础上可以进一步实现多种session的技术，例如：基于cookie的session、基于数据库的session、基于Berkeley
            DB的session、基于内存的session，甚至也可以实现基于TCP-ring的session等等。最重要的是，我们能把这些技术结合起来，使每种技术的优点能够互补，缺点可以被避免。</p><p>所有这一切，对应用程序是完全透明的 —— 应用程序不用知道session是如何实现的、它们的对象被保存到哪个session store中等问题 ——
            session框架可以妥善地处理好这一切。</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="webx.services"><!--anchor webx.services--></a>部分 III. Webx应用支持服务</h1></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="#webx.form">第 9 章 表单验证服务指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10831">9.1. 表单概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10834">9.1.1. 什么是表单验证</a></span></dt><dt><span class="section"><a href="#d0e10883">9.1.2. 表单验证的形式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11104">9.2. 设计</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11107">9.2.1. 验证逻辑与表现逻辑分离</a></span></dt><dt><span class="section"><a href="#d0e11121">9.2.2. 验证逻辑和应用代码分离</a></span></dt><dt><span class="section"><a href="#d0e11138">9.2.3. 表单验证的流程</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11211">9.3. 使用表单验证服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11244">9.3.1. 创建新数据</a></span></dt><dt><span class="section"><a href="#d0e11643">9.3.2. 修改老数据</a></span></dt><dt><span class="section"><a href="#d0e11782">9.3.3. 批量创建或修改数据</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11945">9.4. 表单验证服务详解</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11948">9.4.1. 配置详解</a></span></dt><dt><span class="section"><a href="#d0e12891">9.4.2. Validators</a></span></dt><dt><span class="section"><a href="#d0e14091">9.4.3. Form Tool</a></span></dt><dt><span class="section"><a href="#d0e14313">9.4.4. Field keys的格式</a></span></dt><dt><span class="section"><a href="#d0e14502">9.4.5. 外部验证</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14560">9.5. 本章总结</a></span></dt></dl></dd></dl></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.form"><!--anchor webx.form--></a>第 9 章 表单验证服务指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e10831">9.1. 表单概述</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10834">9.1.1. 什么是表单验证</a></span></dt><dt><span class="section"><a href="#d0e10883">9.1.2. 表单验证的形式</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11104">9.2. 设计</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11107">9.2.1. 验证逻辑与表现逻辑分离</a></span></dt><dt><span class="section"><a href="#d0e11121">9.2.2. 验证逻辑和应用代码分离</a></span></dt><dt><span class="section"><a href="#d0e11138">9.2.3. 表单验证的流程</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11211">9.3. 使用表单验证服务</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11244">9.3.1. 创建新数据</a></span></dt><dt><span class="section"><a href="#d0e11643">9.3.2. 修改老数据</a></span></dt><dt><span class="section"><a href="#d0e11782">9.3.3. 批量创建或修改数据</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11945">9.4. 表单验证服务详解</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11948">9.4.1. 配置详解</a></span></dt><dt><span class="section"><a href="#d0e12891">9.4.2. Validators</a></span></dt><dt><span class="section"><a href="#d0e14091">9.4.3. Form Tool</a></span></dt><dt><span class="section"><a href="#d0e14313">9.4.4. Field keys的格式</a></span></dt><dt><span class="section"><a href="#d0e14502">9.4.5. 外部验证</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14560">9.5. 本章总结</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e10831"><!--anchor d0e10831--></a>9.1. 表单概述</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10834"><!--anchor d0e10834--></a>9.1.1. 什么是表单验证</h3></div></div></div><p>在WEB应用中，表单验证是非常重要的一环。表单验证，顾名思义，就是确保用户所填写的数据符合应用的要求。例如下面这个“注册新帐户”的表单：</p><div class="figure"><a id="d0e10839"><!--anchor d0e10839--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/form-sample.png" alt="一个典型的表单页面"/></div></div><p class="title"><strong>图 9.1. 一个典型的表单页面</strong></p></div><p>在这个表单中，各字段需要符合以下规则：</p><div class="table"><a id="d0e10847"><!--anchor d0e10847--></a><p class="title"><strong>表 9.1. 注册新帐户的规则</strong></p><div class="table-contents"><table summary="注册新帐户的规则" cellpadding="10" style="border: none;"><colgroup><col width="38%" class="c1"/><col width="62%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">字段名</th><th style="border-bottom: 0.5pt solid #6666cc; ">规则</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2">用户名</td><td style="border-bottom: 0.5pt solid #6666cc; ">必须由字母、数字、下划线构成。 · 用户名的</td></tr><tr><td style="border-bottom: 0.5pt solid #6666cc; ">长度必须在某个范围内，例如，4-10个字符。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2">密码</td><td style="border-bottom: 0.5pt solid #6666cc; ">长度必须在某个范围内，例如，4-10个字符。</td></tr><tr><td style="border-bottom: 0.5pt solid #6666cc; ">密码和用户名不能相同，以保证基本的安全性。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">确认密码（再输一遍密码）</td><td style="">必须和密码相同，确保用户没有打字错误。</td></tr></tbody></table></div></div><p>从技术上讲，表单验证完全可以用手工书写代码的方式来实现。但是这样做既无趣，又容易出错，而且难以维护 ——
                特别是当你需要修改验证规则时。因此，几乎所有的WEB框架都提供了表单验证的功能，使你能方便、快速地书写或修改表单验证的规则。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10883"><!--anchor d0e10883--></a>9.1.2. 表单验证的形式</h3></div></div></div><p>验证WEB页面中的表单有如下几种形式：</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10888"><!--anchor d0e10888--></a>9.1.2.1. 服务端批量验证</h4></div></div></div><div class="figure"><a id="d0e10891"><!--anchor d0e10891--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/server-side-validation.png" alt="服务端批量验证"/></div></div><p class="title"><strong>图 9.2. 服务端批量验证</strong></p></div><p>服务端批量验证是最传统验证形式，它将所有表单字段一次性提交给服务器来验证。服务器对所有表单进行批量的验证后，根据验证的结果跳转到不同的结果页面。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10899"><!--anchor d0e10899--></a>9.1.2.2. 客户端验证</h4></div></div></div><div class="figure"><a id="d0e10902"><!--anchor d0e10902--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/client-side-validation.png" alt="客户端验证"/></div></div><p class="title"><strong>图 9.3. 客户端验证</strong></p></div><p>客户端验证是利用Java Script对用户输入的数据进行逐个验证。 </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10910"><!--anchor d0e10910--></a>9.1.2.3. 服务端异步验证</h4></div></div></div><div class="figure"><a id="d0e10913"><!--anchor d0e10913--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/async-validation.png" alt="服务端异步验证"/></div></div><p class="title"><strong>图 9.4. 服务端异步验证</strong></p></div><p>服务器异步验证是利用Java
                    Script发出异步AJAX请求，来要求服务器验证单个或多个字段。如果网络延迟不明显，那么服务器异步验证给用户的体验类似于客户端验证。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10921"><!--anchor d0e10921--></a>9.1.2.4. 混合式验证</h4></div></div></div><p>以上几种验证手段各有优缺点：</p><div class="table"><a id="d0e10926"><!--anchor d0e10926--></a><p class="title"><strong>表 9.2. 各种表单验证的优缺点比较</strong></p><div class="table-contents"><table summary="各种表单验证的优缺点比较" cellpadding="10" style="border: none;"><colgroup><col width="16%" class="c1"/><col width="17%" class="c2"/><col width="17%" class="c3"/><col width="16%" class="c4"/><col width="17%" class="c5"/><col width="17%" class="c6"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">验证形式</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">功能性</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">网络负荷</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">用户体验</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">简单性</th><th style="border-bottom: 0.5pt solid #6666cc; ">可靠性</th></tr></thead><tbody><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务端批量验证</th><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p><span class="emphasis"><em>强</em></span>。</p>
                                    <p>由于验证逻辑存在于服务器上，可访问服务器的一切资源，功能最强。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p>高。</p>
                                    <p>当用户填错任意一个字段时，所有的字段都必须在浏览器和服务器之间来回传输一次。所以它会给网络传输带来较高的负荷。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p>差。</p>
                                    <p>由于网络负荷较高，造成的响应迟缓。此外，验证失败时必须整个页面被刷新。这些会给用户带来不好的体验。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p><span class="emphasis"><em>简单</em></span>。</p>
                                    <p>它的实现比较简单。</p>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <p><span class="emphasis"><em>可靠</em></span>。</p>
                                    <p>相对于其它几种方式，服务端批量验证也是最可靠的方式。因为Java Script可能会失效（因为浏览器不支持、Java
                                        Script被关闭、网站受攻击等原因），但服务器批量验证总不会失效。</p>
                                </td></tr><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">客户端验证</th><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p>弱。</p>
                                    <p>由于验证逻辑存在于用户浏览器上，不能访问服务器资源，因此有一些功能无法实现，例如：检查验证码、确认注册用户ID未被占用等。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p><span class="emphasis"><em>无</em></span>。</p>
                                    <p>在验证时，不需要网络通信，不存在网络负荷。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <p><span class="emphasis"><em>好</em></span>。</p>
                                    <p>响应速度极快，用户体验最好。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; " rowspan="2">
                                    <p>复杂。</p>
                                    <p>因为需要JS编程。</p>
                                </td><td style="" rowspan="2">
                                    <p>不可靠。</p>
                                    <p>由于下列原因，Java Script可能会失效，使得客户端验证被跳过：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>浏览器不支持</p></li><li class="listitem"><p>Java Script被关闭</p></li><li class="listitem"><p>网站受攻击</p></li></ul></div>
                                </td></tr><tr><th style="border-right: 0.5pt solid #6666cc; ">服务端异步验证</th><td style="border-right: 0.5pt solid #6666cc; ">
                                    <p><span class="emphasis"><em>强</em></span>。</p>
                                    <p>由于验证逻辑存在于服务器上，可访问服务器的一切资源，功能也很强。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; ">
                                    <p>低。</p>
                                    <p>每次验证，只需要发送当前被验证字段的数据即可，网络负荷较小。</p>
                                </td><td style="border-right: 0.5pt solid #6666cc; ">
                                    <p>较好。</p>
                                    <p>由于网络负荷小，用户响应远快于服务端批量验证，用户体验好。</p>
                                </td></tr></tbody></table></div></div><p>没有一种验证方法是完美的。但把它们结合起来就可以克服各自的缺点，达到较完美的境地：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>对所有字段做服务器端批量验证，即便Java Script失效，服务器验证可作为最后的防线。</p></li><li class="listitem"><p>只要有可能，就对字段做客户端验证，确保最迅速的响应和较好的用户体验。</p></li><li class="listitem"><p>对于必须访问服务器资源的验证逻辑，例如检查验证码、确认注册帐户ID未被占用等，采用服务器异步验证，提高用户体验。</p></li></ul></div><p>以上混合形式的验证无疑是好的，但是它的实现也比较复杂。</p><p><span class="emphasis"><em>目前Webx所提供的表单验证服务并没有实现客户端验证和服务端异步验证</em></span>。这些功能将在后续版本中实现。在现阶段中，应用开发者必须手工编码Java
                    Script来实现客户端验证和服务端异步验证。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e11104"><!--anchor d0e11104--></a>9.2. 设计</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11107"><!--anchor d0e11107--></a>9.2.1. 验证逻辑与表现逻辑分离</h3></div></div></div><p>很容易想到的一种表单验证的实现，就是将表单验证的逻辑内嵌在页面模板中。例如，某些WEB框架实现了一些用来验证表单的JSP tags。类似下面的样子：</p><div class="example"><a id="d0e11112"><!--anchor d0e11112--></a><p class="title"><strong>例 9.1. 将验证逻辑内嵌在页面模板中</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"loginId"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loginId}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;form:required</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loginId}"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;strong&gt;</strong>Login ID is required.<strong class="hl-tag" style="color: #000096">&lt;/strong&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/form:required&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;form:regexp</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loginId}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^\w+$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;strong&gt;</strong>Login ID is invalid.<strong class="hl-tag" style="color: #000096">&lt;/strong&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/form:regexp&gt;</strong></pre></div></div><p>将验证逻辑内嵌在页面模板中最大的问题是，验证逻辑和页面的表现逻辑完全混合在一起。当你需要修改验证规则时，你必须找出所有的页面，从复杂的HTML代码中，一个不漏地找到并修改它们。这是一件费时费力的工作，而且很容易出错。另一方面，嵌在页面模板中的验证规则是不能被多个页面共享和复用的。</p><p>Webx表单验证服务主张验证逻辑和页面表现逻辑完全分离。所有的验证规则都写在一个单独的配置文件中 ——
                页面模板是不需要关心这些验证规则的。当你需要修改验证规则时，只需要修改独立的配置文件就可以了，并不用修改页面模板。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11121"><!--anchor d0e11121--></a>9.2.2. 验证逻辑和应用代码分离</h3></div></div></div><p>另一种容易想到的方法，是把表单验证的逻辑写在Java代码中。例如，在Java代码中直接调用验证逻辑。更高级一点，也许可以通过annotation机制在Java代码中定义验证逻辑，像下面的样子：</p><div class="example"><a id="d0e11126"><!--anchor d0e11126--></a><p class="title"><strong>例 9.2. 将验证逻辑内嵌在Java代码中</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Required</span></em>
    <em><span class="hl-annotation" style="color: gray">@Regexp("^\\w+$")</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> String loginId;
    …
}</pre></div></div><p>这样做的问题是，当你需要修改验证规则时，你必须一个不漏地找到所有定义annotations的那些代码，并修改它们。另一方面，annotation机制不容易扩展，很难方便地增加新的验证方案。</p><p>Webx表单验证服务主张<span class="emphasis"><em>验证逻辑和应用代码完全分离</em></span>。所有的验证规则都写在一个单独的配置文件中 ——
                应用程序的代码是不需要关心这些验证规则的。当你需要修改验证规则时，只需要修改独立的配置文件就可以了，并不需要修改程序代码。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11138"><!--anchor d0e11138--></a>9.2.3. 表单验证的流程</h3></div></div></div><div class="table"><a id="d0e11141"><!--anchor d0e11141--></a><p class="title"><strong>表 9.3. 一个基本的表单验证流程</strong></p><div class="table-contents"><table summary="一个基本的表单验证流程" cellpadding="10" style="border: none;"><colgroup><col width="11%" class="c1"/><col width="22%" align="right" class="c2"/><col width="22%" class="c3"/><col width="45%" align="center" class="c4"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">步骤</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="right">客户端浏览器</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">WEB服务器</th><th style="border-bottom: 0.5pt solid #6666cc; " align="center">页面效果</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2">1.</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="right">请求表单页面 →</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "> </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="2" align="center" valign="middle">
                                <div class="informalfigure"><div class="mediaobject"><img src="images/form/form-sample-empty.png"/></div></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="right"> </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">← 返回空白表单</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2">2.</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="right">用户填写表单，并提交 →</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "> </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="2" align="center" valign="middle">
                                <div class="informalfigure"><div class="mediaobject"><img src="images/form/form-sample-validation-failed.png"/></div></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="right"> </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">← 验证表单数据，如果验证有错，则返回包含错误信息的表单页面，并提示出错信息。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " rowspan="2">3.</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="right">用户修改表单，并再次提交（重复该步骤直至验证成功） →</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "> </td><td style="" rowspan="2" align="center" valign="middle">
                                <div class="informalfigure"><div class="mediaobject"><img src="images/form/form-sample-validation-succ.png"/></div></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " align="right"> </td><td style="border-right: 0.5pt solid #6666cc; ">← 验证表单数据，如果验证通过，则转至下一个页面。通常是显示成功信息。</td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e11211"><!--anchor d0e11211--></a>9.3. 使用表单验证服务</h2></div></div></div><p>Webx表单验证服务可用来支持以下几种类型的表单需求：</p><div class="table"><a id="d0e11216"><!--anchor d0e11216--></a><p class="title"><strong>表 9.4. 几种表单需求</strong></p><div class="table-contents"><table summary="几种表单需求" cellpadding="10" style="border: none;"><colgroup><col width="27%" class="c1"/><col width="73%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">需求名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">创建新数据</td><td style="border-bottom: 0.5pt solid #6666cc; ">也就是让用户在一个空白的表单上填写数据，并验证之。例如，注册一个新帐户。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">修改老数据</td><td style="border-bottom: 0.5pt solid #6666cc; ">也就是让用户在已填有数据的表单上进行修改，并验证之。例如，修改帐户信息。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">批量创建、修改数据</td><td style="">也就是在一个表单中，一次性创建、修改多个数据对象。例如，管理员批量审核帐户。</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11244"><!--anchor d0e11244--></a>9.3.1. 创建新数据</h3></div></div></div><p>下面的例子实现了“注册一个新帐户”的功能。</p><p>为了实现表单验证的功能，需要由三个部分配合起来工作：</p><div class="table"><a id="d0e11251"><!--anchor d0e11251--></a><p class="title"><strong>表 9.5. 验证表单所需的部件</strong></p><div class="table-contents"><table summary="验证表单所需的部件" cellpadding="10" style="border: none;"><colgroup><col width="27%" class="c1"/><col width="73%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">部件名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">验证规则</td><td style="border-bottom: 0.5pt solid #6666cc; ">也就是form service的配置文件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">页面模板</td><td style="border-bottom: 0.5pt solid #6666cc; ">通过<code class="code">$form</code>工具，生成表单页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Java代码</td><td style="">接收表单数据，并作后续处理。</td></tr></tbody></table></div></div><p>下面逐个介绍。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11284"><!--anchor d0e11284--></a>9.3.1.1. 定义验证规则</h4></div></div></div><p>表单验证服务是一个基于Spring和Spring Ext的服务，可利用Schema来配置。示例如下：</p><div class="example"><a id="d0e11289"><!--anchor d0e11289--></a><p class="title"><strong>例 9.3. 表单验证规则示例</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:fm-conditions</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/conditions"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:fm-validators</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/validators"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
            http://localhost:8080/schema/services.xsd
        http://www.alibaba.com/schema/services/form/conditions
            http://localhost:8080/schema/services-form-conditions.xsd
        http://www.alibaba.com/schema/services/form/validators
            http://localhost:8080/schema/services-form-validators.xsd
        http://www.springframework.org/schema/beans
            http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/validators"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.rules.form"><!--anchor co.form.rules.form--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"register"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.rules.group"><!--anchor co.form.rules.group--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>

            <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"userId"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"登录名"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.rules.field"><!--anchor co.form.rules.field--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
                <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong> <a id="co.form.rules.validator"><!--anchor co.form.rules.validator--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong> <a id="co.form.rules.validator.msg"><!--anchor co.form.rules.validator.msg--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
                <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;regexp-validator</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^[A-Za-z_][A-Za-z_0-9]*$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须由字母、数字、下划线构成<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/regexp-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;string-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 最少必须由${minLength}个字组成，最多不能超过${maxLength}个字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/string-length-validator&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>

            <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"password"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"密码"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;string-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 最少必须由${minLength}个字组成，最多不能超过${maxLength}个字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/string-length-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;string-compare-validator</strong> <span class="hl-attribute" style="color: #F5844C">notEqualTo</span>=<span class="hl-value" style="color: #993300">"userId"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 不能与 ${userId.displayName} 相同<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/string-compare-validator&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>

            <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"passwordConfirm"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"密码验证"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;string-compare-validator</strong> <span class="hl-attribute" style="color: #F5844C">equalTo</span>=<span class="hl-value" style="color: #993300">"password"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须和 ${password.displayName} 相同<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/string-compare-validator&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>

        <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.rules.form"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;form&gt;</code>代表表单验证服务的配置。从这里开始定义表单验证的规则。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.rules.group"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可以定义多个groups，每个group有一个唯一的名称，例如：“<code class="code">register</code>”。每个group代表了一组需要验证的字段（field）。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.rules.field"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>每个field有一个在组中唯一的名称，例如：“<code class="code">userId</code>”、“<code class="code">password</code>”等。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.rules.validator"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>每个field又包含了多个验证规则（validator）。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.rules.validator.msg"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>每个验证规则都包含了一段文字描述（message），如果用户填写的数据没有通过当前的规则的验证，那么用户将会看到这段文字描述，以解释出错的原因。</p></td></tr></table></div></div></div><div class="figure"><a id="d0e11331"><!--anchor d0e11331--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/form-structure.png" alt="表单验证配置文件的结构"/></div></div><p class="title"><strong>图 9.5. 表单验证配置文件的结构</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11337"><!--anchor d0e11337--></a>9.3.1.2. 创建表单页面</h4></div></div></div><p>创建表单页面需要使用一个pull tool工具，配置如下：</p><div class="example"><a id="d0e11342"><!--anchor d0e11342--></a><p class="title"><strong>例 9.4. 表单验证pull tool的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pull</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pull/factories"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;form-tool /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pull&gt;</strong></pre></div></div><p>上面的配置定义了一个$form工具。现在你可以在模板中直接使用它。</p><div class="example"><a id="d0e11349"><!--anchor d0e11349--></a><p class="title"><strong>例 9.5. 表单验证的页面模板示例</strong></p><div class="example-contents"><pre class="programlisting">#macro (registerMessage $field) <a id="co.form.vm.msg.macro"><!--anchor co.form.vm.msg.macro--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    #if (!$field.valid) $field.message #end
#end

<strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">""</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"post"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.vm.form"><!--anchor co.form.vm.form--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
  <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"action"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"UserAccountAction"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.vm.action"><!--anchor co.form.vm.action--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>

  #set ($group = $form.register.defaultInstance) <a id="co.form.vm.default.instance"><!--anchor co.form.vm.default.instance--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
  
  <strong class="hl-tag" style="color: #000096">&lt;p&gt;</strong>用户注册<strong class="hl-tag" style="color: #000096">&lt;/p&gt;</strong>

  <strong class="hl-tag" style="color: #000096">&lt;dl&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dt&gt;</strong>用户名<strong class="hl-tag" style="color: #000096">&lt;/dt&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dd&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;div&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.userId.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.userId.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.vm.field1"><!--anchor co.form.vm.field1--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;div</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"errorMessage"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            #registerMessage ($group.userId) <a id="co.form.vm.msg1"><!--anchor co.form.vm.msg1--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dd&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;dt&gt;</strong>密码<strong class="hl-tag" style="color: #000096">&lt;/dt&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dd&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;div&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"password"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.password.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.password.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.vm.field2"><!--anchor co.form.vm.field2--></a><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;div</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"errorMessage"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            #registerMessage ($group.password) <a id="co.form.vm.msg2"><!--anchor co.form.vm.msg2--></a><span class="calloutno"><img src="images/callouts/8.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dd&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;dt&gt;</strong>再输一遍密码<strong class="hl-tag" style="color: #000096">&lt;/dt&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dd&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;div&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"password"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.passwordConfirm.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.passwordConfirm.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.vm.field3"><!--anchor co.form.vm.field3--></a><span class="calloutno"><img src="images/callouts/9.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;div</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"errorMessage"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            #registerMessage ($group.passwordConfirm) <a id="co.form.vm.msg3"><!--anchor co.form.vm.msg3--></a><span class="calloutno"><img src="images/callouts/10.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dd&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;/dl&gt;</strong>
  
  <strong class="hl-tag" style="color: #000096">&lt;p&gt;</strong>
      <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"submit"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"event_submit_do_register"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"立即注册！"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.vm.submit"><!--anchor co.form.vm.submit--></a><span class="calloutno"><img src="images/callouts/11.png" border="0"/></span>
  <strong class="hl-tag" style="color: #000096">&lt;/p&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.form"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>HTML form的action值为空，意思是把表单提交给当前页面。</p><p>这样，当用户填写表单有错时，应用会停留在当前表单页面，将表单数据连同错误提示一起显示给用户，要求用户修改。如果表单验证通过，应用必须通过重定向操作来转向下一个页面。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.default.instance"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>创建一个<code class="code">register</code> group的实例。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.field1"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> <a href="#co.form.vm.field2"><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span></a> <a href="#co.form.vm.field3"><span class="calloutno"><img src="images/callouts/9.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>利用新创建的group对象来生成表单字段，包括生成字段的名称<code class="code">$group.field.key</code>，以及字段的值为<code class="code">$!group.field.value</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.msg.macro"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义velocity宏：仅当field验证通过时（即<code class="code">$group.field.valid=true</code>），才显示错误信息。</p><p>对于空白表单和通过验证的字段而言，<code class="code">$group.field.valid</code>为<code class="code">true</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.msg1"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> <a href="#co.form.vm.msg2"><span class="calloutno"><img src="images/callouts/8.png" border="0"/></span></a> <a href="#co.form.vm.msg3"><span class="calloutno"><img src="images/callouts/10.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果验证失败的话，显示验证出错消息。这里通过前面所定义的velocity宏来简化代码。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.action"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>根据这参数，表单将会被交给<code class="code">UserAccountAction</code>来处理。Action的职责是调用表单验证过程。假如验证通过，就保存数据，并重定向到下一个页面。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.vm.submit"><span class="calloutno"><img src="images/callouts/11.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>根据这个参数，表单被提交以后，系统会调用当前action（即<code class="code">UserAccountAction</code>）的<code class="code">doRegister()</code>方法。每个action类中，可以包含多个处理数据的动作，例如<code class="code">doCreate</code>、<code class="code">doUpdate</code>、<code class="code">doDelete</code>等。</p></td></tr></table></div></div></div><p>上面的Velocity页面模板演示了怎样利用表单验证服务创建一个帐户注册的HTML表单。关键技术解释如下：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">创建group实例</span></dt><dd><p><code class="code">$form.register.defaultInstance</code>将会对<code class="code">register</code>
                                group创建一个默认的实例。绝大多数情况下，只需要创建唯一的default
                                instance就足够了。但后面我们会讲到创建多实例的例子。</p><p>所创建的group instance（如<code class="code">register</code>）必须先在规则配置文件中被定义。</p><div class="figure"><a id="d0e11457"><!--anchor d0e11457--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/new-group-instance.png" alt="创建一个group实例"/></div></div><p class="title"><strong>图 9.6. 创建一个group实例</strong></p></div></dd><dt><span class="term">生成表单字段</span></dt><dd><p>一个表单字段包含名称和值两个部分。</p><p>字段的名称为<code class="code">$group.field.key</code>。表单验证服务会自动生成一个字段名。这个字段名被设计成仅供系统内部解读的，而不是让外界的系统或人来解读的。它看起来是这个样子的：“<code class="code">_fm.r._0.p</code>”。<span class="emphasis"><em>外界的系统不应该依赖于这个名称</em></span>。</p><p>字段的值为<code class="code">$!group.field.value</code>。它的初始值（即用户填写数据之前）是<code class="code">null</code>。但你也可以在配置文件中为它指定一个默认的初始值，例如：</p><div class="example"><a id="d0e11488"><!--anchor d0e11488--></a><p class="title"><strong>例 9.6. 在表单验证规则中添加默认值</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myfield"</span> <span class="hl-attribute" style="color: #F5844C">defaultValue</span>=<span class="hl-value" style="color: #993300">"mydefault"</span> <span class="hl-attribute" style="color: #F5844C">...&gt;</span></pre></div></div><p>因为值可能是<code class="code">null</code>，因此在velocity中，需要以“<code class="code">$!</code>”来标记它 ——
                                    Velocity认为<code class="code">null</code>是一个错误，除非你以<code class="code">$!</code>来标记它，告诉velocity忽略它。</p><p>需要注意的是，<span class="emphasis"><em>默认值只会影响field的初始值</em></span>。一旦用户填写并提交了表单，那么<code class="code">$group.field.value</code>的值将保持用户所填写的值不变
                                —— 不论验证失败或成功。 </p></dd><dt><span class="term">页面展现</span></dt><dd><p>一般来说，你需要定义CSS风格以便让表单的field和错误信息能以适当的格式来显示给用户。展现效果可能是像这个样子：</p><div class="figure"><a id="d0e11521"><!--anchor d0e11521--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/form-sample-validation-failed.png" alt="在页面中显示表单验证错误信息"/></div></div><p class="title"><strong>图 9.7. 在页面中显示表单验证错误信息</strong></p></div><p>表单系统不应该干预页面的具体展现方法，以下内容均和表单系统无关。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Field展现的方式：textbox、checkbox、hidden field？</p></li><li class="listitem"><p>错误信息的颜色、显示位置。</p></li></ul></div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11536"><!--anchor d0e11536--></a>9.3.1.3. 创建Java代码（action）</h4></div></div></div><p>用户提交表单后，由服务器端的Java代码读取并验证用户的数据。</p><p>在Webx中，这个功能通常由action来完成。前文已经提到，在HTML表单中，设置<code class="code">action</code>字段，以及<code class="code">event_submit_do_register</code>提交按钮，就可以让Webx框架调用<code class="code">UserAccountAction.doRegister()</code>方法。</p><p>下面是<code class="code">UserAccountAction</code>类的实现代码：</p><div class="example"><a id="d0e11557"><!--anchor d0e11557--></a><p class="title"><strong>例 9.7. 创建用于处理提交数据的action代码</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> UserAccountAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> FormService formService; <a id="co.form.action.inject.formservice"><!--anchor co.form.action.inject.formservice--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doRegister(Navigator nav) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        Form form = formService.getForm(); <a id="co.form.action.get.form"><!--anchor co.form.action.get.form--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>

        <strong class="hl-keyword" style="color: maroon">if</strong> (form.isValid()) { <a id="co.form.action.form.isvalid"><!--anchor co.form.action.form.isvalid--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
            Group group = form.getGroup(<strong class="hl-string"><em style="color:navy">"register"</em></strong>); <a id="co.form.action.get.group"><!--anchor co.form.action.get.group--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>

            MyUser user = <strong class="hl-keyword" style="color: maroon">new</strong> MyUser(); <a id="co.form.action.populate.bean1"><!--anchor co.form.action.populate.bean1--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
            group.setProperties(user); <a id="co.form.action.populate.bean2"><!--anchor co.form.action.populate.bean2--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
            save(user);

            <em class="hl-comment" style="color: green">// 跳转到注册成功页面</em>
            nav.redirectTo(<strong class="hl-string"><em style="color:navy">"registerSuccess"</em></strong>); <a id="co.form.action.redirect"><!--anchor co.form.action.redirect--></a><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span>
        }
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.action.inject.formservice"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>注入form服务。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.action.get.form"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>取得form对象，form对象中包含若干groups。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.action.form.isvalid"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>仅当表单验证成功时，才执行下去。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.action.get.group"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>取得group对象。Group对象的名称必须和配置文件以及模板中的group名称相同。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.action.populate.bean1"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> <a href="#co.form.action.populate.bean2"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将group中的数据灌入bean中。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.action.redirect"><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>处理完数据以后，利用Webx navigation接口跳转到“注册成功”页面。</p></td></tr></table></div></div></div><p>例子中的<code class="code">MyUser</code>对象是一个简单的Java Bean：</p><div class="example"><a id="d0e11600"><!--anchor d0e11600--></a><p class="title"><strong>例 9.8. 被灌入group数据的Java Bean</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">static</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyUser {
    <strong class="hl-keyword" style="color: maroon">private</strong> String userId;
    <strong class="hl-keyword" style="color: maroon">private</strong> String password;

    <strong class="hl-keyword" style="color: maroon">public</strong> String getUserId() {
        <strong class="hl-keyword" style="color: maroon">return</strong> userId;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setUserId(String userId) {
        <strong class="hl-keyword" style="color: maroon">this</strong>.userId = userId;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> String getPassword() {
        <strong class="hl-keyword" style="color: maroon">return</strong> password;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setPassword(String password) {
        <strong class="hl-keyword" style="color: maroon">this</strong>.password = password;
    }
}</pre></div></div><p><code class="code">Group.setProperties()</code>方法将fields的值映射到同名的Java Bean
                    properties中。然而这个对应关系是可以改变的，后文会再次讲到该问题。</p><p>是不是有点复杂？事实上，<span class="emphasis"><em>上面的代码可以通过Webx的参数注入机制加以简化</em></span>。下面的代码可以完成完全相同的功能，但是代码却短得多。然而，<span class="emphasis"><em>理解前面的较复杂代码，将有助于你理解下面的简化代码</em></span>。</p><div class="example"><a id="d0e11617"><!--anchor d0e11617--></a><p class="title"><strong>例 9.9. 创建用于处理提交数据的action代码（Annotations简化版）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> UserAccountAction {
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doRegister(<em><span class="hl-annotation" style="color: gray">@FormGroup("register")</span></em> MyUser user, Navigator nav) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        save(user);
        nav.redirectTo(<strong class="hl-string"><em style="color:navy">"registerSuccess"</em></strong>);
    }
}</pre></div></div><p>在这个简化版代码中，@FormGroup注解完成了前面复杂代码中的大部分功能，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>验证表单，如果<span class="emphasis"><em>失败则不执行action</em></span>，否则执行<code class="code">doRegister</code>方法。</p></li><li class="listitem"><p>取得form和<code class="code">register</code>
                                    group对象，并将group中的数据注入到<code class="code">MyUser</code>对象中。 </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11643"><!--anchor d0e11643--></a>9.3.2. 修改老数据</h3></div></div></div><p>在前面的例子中，我们利用表单创建了一个新数据 ——
                注册新帐户。它是从一个空白表单开始的，也就是说，在用户填写表单之前，表单是没有内容的，或只包含默认值的。另一种常见情况是修改老数据。例如“修改帐户资料”。和创建新数据的例子不同，在用户填写表单之前，表单里已经包含了从数据库中取得的老数据。</p><p>在创建新数据的模板和代码中，稍微添加一点东西，就可以实现修改老数据的功能。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11650"><!--anchor d0e11650--></a>9.3.2.1. 用screen来读取数据</h4></div></div></div><p>修改老数据的第一步，是要取得老的数据。例如，取得要修改的帐户信息。在Webx中，这个任务是由screen来完成的：</p><div class="example"><a id="d0e11655"><!--anchor d0e11655--></a><p class="title"><strong>例 9.10. 用screen取得表单验证的初始数据</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> UserAccount {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> UserManager userManager; <a id="co.form.modifydata.screen.bizobj"><!--anchor co.form.modifydata.screen.bizobj--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute(Context context) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        User user = userManager.getUser(getCurrentUser().getId());
        context.put(<strong class="hl-string"><em style="color:navy">"user"</em></strong>, user); <a id="co.form.modifydata.screen.putcontext"><!--anchor co.form.modifydata.screen.putcontext--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.modifydata.screen.bizobj"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">UserManager</code>是一个业务接口。通过它，可以从数据库中取得当前登录帐户的信息。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.modifydata.screen.putcontext"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>随后，screen代码把所取得的user对象放到context中，这样，就可以在模板中用<code class="code">$user</code>来引用它。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11676"><!--anchor d0e11676--></a>9.3.2.2. 表单页面</h4></div></div></div><div class="example"><a id="d0e11679"><!--anchor d0e11679--></a><p class="title"><strong>例 9.11. 用来修改数据的页面模板</strong></p><div class="example-contents"><pre class="programlisting">#set ($group = $form.userAccount.defaultInstance)

$group.mapTo($user) <a id="co.form.modifydata.vm.mapto"><!--anchor co.form.modifydata.vm.mapto--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
...
<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.userId.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.userId.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.modifydata.vm.pk"><!--anchor co.form.modifydata.vm.pk--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
...

<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.lastName.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.lastName.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
...
#userAccountMessage ($group.lastName)
...
<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"submit"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"event_submit_do_update"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"修改"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.modifydata.vm.submit"><!--anchor co.form.modifydata.vm.submit--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></pre><div class="calloutlist"><p>在前面“创建新数据”的页面上，加上和修改一点内容：</p><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.modifydata.vm.mapto"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">mapTo</code>的功能是填充表单。</p><p>这行代码的意思是：用screen中所取得的user对象的值来填充表单，作为表单的初始值。和<code class="code">Group.setProperties()</code>方法相反，<code class="code">mapTo</code>将Java
                                Bean properties的值映射到同名的fields中。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.modifydata.vm.pk"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>保存主键。</p><p>和创建新数据不同，在修改老数据时，一般需要在表单中包含主键。这个主键（user
                                id）在数据库中唯一识别这一数据对象（user）。</p><p>应该避免用户改变主键。最简便的方法，就是用hidden字段来保存主键。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.modifydata.vm.submit"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这个submit按钮将引导webx执行<code class="code">UserAccountAction.doUpdate</code>方法。</p></td></tr></table></div></div></div><p>需要注意的是，调用<code class="code">mapTo</code>在下列情况下是无效的：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>当<code class="code">$user</code>对象不存在（值为<code class="code">null</code>）时，<code class="code">mapTo</code>不做任何事。这样，<span class="emphasis"><em>你就可以让“创建新帐户”和“修改帐户信息”共用同一个模板</em></span>。在新表单中，由于<code class="code">$user</code>不存在，所以<code class="code">mapTo</code>失效；而在更新表单中，就可以从<code class="code">$user</code>中取得初始的数据。</p></li><li class="listitem"><p>当用户提交表单以后，<code class="code">mapTo</code>不做任何事。因为<code class="code">mapTo</code>只会影响表单的初始数据。一旦用户修改并提交数据以后，<code class="code">mapTo</code>就不会改变用户所修改的数据。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11760"><!--anchor d0e11760--></a>9.3.2.3. 用action来处理数据</h4></div></div></div><p>修改老数据的action代码和创建新数据的action代码几乎相同，而且它们可以共享同一个<code class="code">UserAccountAction</code>类：</p><div class="example"><a id="d0e11768"><!--anchor d0e11768--></a><p class="title"><strong>例 9.12. 用来保存提交数据的action</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> UserAccountAction {
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doRegister(...) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        ...
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doUpdate(<em><span class="hl-annotation" style="color: gray">@FormGroup("userAccount")</span></em> MyUser user, <a id="co.form.modifiydata.action.obj"><!--anchor co.form.modifiydata.action.obj--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
                         Navigator nav) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        save(user);
        nav.redirectTo(<strong class="hl-string"><em style="color:navy">"updateSuccess"</em></strong>);
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.modifiydata.action.obj"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>通过annotation取得的<code class="code">MyUser</code>对象中，包含了通过hidden字段传过来的user
                                id，以及其它所有字段的值。</p></td></tr></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11782"><!--anchor d0e11782--></a>9.3.3. 批量创建或修改数据</h3></div></div></div><p>有时，我们需要在一个表单页面中批量创建或修改一批数据。例如，后台管理界面中，管理员可以一次审核10个帐户的信息。每个帐户的信息格式都是相同的：姓名、性别、年龄、地址等。表单验证服务完全支持这样的表单。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11787"><!--anchor d0e11787--></a>9.3.3.1. 用screen来读取批量数据</h4></div></div></div><p>假如你希望做的是批量修改数据，很显然，你需要在screen代码中取得所有需要修改的数据。</p><div class="example"><a id="d0e11792"><!--anchor d0e11792--></a><p class="title"><strong>例 9.13. 批量读取数据的screen</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> BatchUserAccount {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> UserManager userManager;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute(Context context) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        List&lt;User&gt; users = userManager.getUsers(getIds()); <a id="co.form.batch.screen.putcontext"><!--anchor co.form.batch.screen.putcontext--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        context.put(<strong class="hl-string"><em style="color:navy">"users"</em></strong>, users);
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.batch.screen.putcontext"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>和修改单个数据的screen代码不同的是，你需要一次性读取多个数据对象，并置入到context中。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11803"><!--anchor d0e11803--></a>9.3.3.2. 表单页面</h4></div></div></div><div class="example"><a id="d0e11806"><!--anchor d0e11806--></a><p class="title"><strong>例 9.14. 批量创建、修改数据的表单页面模板</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">""</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"post"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
  <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"action"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"UserAccountAction"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>

  #foreach($user in $users) <a id="co.form.batch.vm.forloop"><!--anchor co.form.batch.vm.forloop--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    #set ($group = $form.userAccount.getInstance($user.id)) <a id="co.form.batch.vm.getinstance"><!--anchor co.form.batch.vm.getinstance--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>

    $group.mapTo($user)

    ...
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.userId.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.userId.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>

    ...
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$group.lastName.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!group.lastName.value"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    ...
    #userAccountMessage ($group.lastName)
    ...

  #end
  ...
  <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"submit"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"event_submit_do_batch_edit"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"批量修改"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong> <a id="co.form.batch.vm.submit"><!--anchor co.form.batch.vm.submit--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.batch.vm.forloop"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>为了批量创建、修改数据，需要在表单页面中利用<code class="code">foreach</code>循环来遍历数据对象。其中，<code class="code">$users</code>是由screen放入context中的对象列表。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.batch.vm.getinstance"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>对每个数据对象创建一个group实例。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.batch.vm.submit"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定action事件。这个submit按钮将引导webx执行<code class="code">UserAccountAction.doBatchEdit</code>方法。</p></td></tr></table></div></div></div><p>在前面的例子中，我们一直使用<code class="code">$form.xyz.defaultInstance</code>来创建默认的group实例。而这里，我们改变了用法：<code class="code">$form.userAccount.getInstance($user.id)</code>。每次调用该方法，就对一个group生成了一个实例（instance）。</p><div class="figure"><a id="d0e11844"><!--anchor d0e11844--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/multiple-group-instances.png" alt="创建多个group实例"/></div></div><p class="title"><strong>图 9.8. 创建多个group实例</strong></p></div><p>每个instance必须以不同的id来区分。最简单的方法，就是采用数据对象的唯一id来作为group
                        instance的id。在这个例子中，我们采用<code class="code">$user</code>的唯一id（<code class="code">$user.id</code>）来区分group
                    instances。</p><p>前文讲过，default instance的field
                            key是这个样子的：“<code class="code">_fm.r.</code><span class="emphasis"><em><code class="code">_0</code></em></span><code class="code">.p</code>”。类似的，通过<code class="code">getInstance("</code><span class="emphasis"><em><code class="code">myid</code></em></span><code class="code">")</code>方法所取得的group中的field
                        key是这样的：“<code class="code">_fm.u.</code><span class="emphasis"><em><code class="code">myid</code></em></span><code class="code">.n</code>”。很明显，form
                    service就是依赖于field key中所包含的group instance id来区分同一group的不同instances的。</p><p>因为field key将作为HTML的一部分，所以group
                        instance的id必须为满足下面的条件：<span class="emphasis"><em>只包含英文字母、数字、下划线、短横线的字符串</em></span>。</p><p>页面的其它部分和创建、修改单个数据的代码完全相同。只不过它们被循环生成了多次。 最后的结果是类似下面的样子：</p><div class="figure"><a id="d0e11891"><!--anchor d0e11891--></a><div class="figure-contents"><div class="mediaobject"><img src="images/form/batch-edit-form.png" alt="批量修改数据的页面示例"/></div></div><p class="title"><strong>图 9.9. 批量修改数据的页面示例</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11897"><!--anchor d0e11897--></a>9.3.3.3. 用action来处理数据</h4></div></div></div><p>和前面的例子类似，我们先用传统的方法来写action以便阐明原理，再用annotation来简化action代码。</p><div class="example"><a id="d0e11902"><!--anchor d0e11902--></a><p class="title"><strong>例 9.15. 用来批量处理数据的action</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> UserAccountAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> FormService formService;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doBatchEdit(Navigator nav) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        Form form = formService.getForm();

        <strong class="hl-keyword" style="color: maroon">if</strong> (form.isValid()) {
            Collection&lt;Group&gt; groups = form.getGroups(<strong class="hl-string"><em style="color:navy">"userAccount"</em></strong>); <a id="co.form.batch.action.getgroups"><!--anchor co.form.batch.action.getgroups--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

            <strong class="hl-keyword" style="color: maroon">for</strong> (Group group : groups) {
                MyUser user = <strong class="hl-keyword" style="color: maroon">new</strong> MyUser();

                group.setProperties(user);
                save(user);
            }

            nav.redirectTo(<strong class="hl-string"><em style="color:navy">"success"</em></strong>);
        }
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.batch.action.getgroups"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>通过这个方法，可以取得所有名称为“<code class="code">userAccount</code>”的group
                                    instances，包括：<code class="code">user1</code>、<code class="code">user2</code>、……。</p></td></tr></table></div></div></div><p>取得group实例，除了例子中的<code class="code">form.getGroups(groupName)</code>这种形式以外，还有以下几种变化：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>取得所有的group instances，无论其名称是什么：<code class="code">Collection&lt;Group&gt; groups =
                                    form.getGroups(); </code></p></li><li class="listitem"><p>取得指定group名称和instance key的group instances：<code class="code">Group user1Group =
                                    form.getGroup("userAccount", "user1"); </code></p></li></ul></div><p>下面是一个简化版的action，实现完全相同的功能。</p><div class="example"><a id="d0e11940"><!--anchor d0e11940--></a><p class="title"><strong>例 9.16. 用来批量处理数据的action（Annotation简化版）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> UserAccountAction {
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doBatchEdit(<em><span class="hl-annotation" style="color: gray">@FormGroup("userAccount")</span></em> MyUser[] users,
                            Navigator nav) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        <strong class="hl-keyword" style="color: maroon">for</strong> (MyUser user : users) {
            save(user);
        }

        nav.redirectTo(<strong class="hl-string"><em style="color:navy">"success"</em></strong>);
    }
}</pre></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e11945"><!--anchor d0e11945--></a>9.4. 表单验证服务详解</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11948"><!--anchor d0e11948--></a>9.4.1. 配置详解</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11951"><!--anchor d0e11951--></a>9.4.1.1. 基本配置</h4></div></div></div><div class="example"><a id="d0e11954"><!--anchor d0e11954--></a><p class="title"><strong>例 9.17. 表单验证服务的基本配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/validators"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.basic.service"><!--anchor co.form.basic.service--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.basic.group"><!--anchor co.form.basic.group--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.basic.field"><!--anchor co.form.basic.field--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong> <a id="co.form.basic.validator"><!--anchor co.form.basic.validator--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
            ...
        <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>

        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        ...
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        ...
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.basic.service"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>开始配置表单验证服务。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.basic.group"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>每个表单验证服务可包含多个groups。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.basic.field"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>每个group可包含多个fields。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.basic.validator"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>每个field可包含多个validators。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11980"><!--anchor d0e11980--></a>9.4.1.2. Post Only参数</h4></div></div></div><div class="example"><a id="d0e11983"><!--anchor d0e11983--></a><p class="title"><strong>例 9.18. 配置Post Only参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">postOnlyByDefault</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.postonly.default"><!--anchor co.form.postonly.default--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group1"</span> <span class="hl-attribute" style="color: #F5844C">postOnly</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.postonly.group"><!--anchor co.form.postonly.group--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.postonly.default"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果不指定，<code class="code">postOnlyByDefault</code>的默认值为<code class="code">true</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.postonly.group"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果不指定，那么<code class="code">postOnly</code>的值取决于<code class="code">postOnlyByDefault</code>。这意味着如果什么也不设置，所有<code class="code">postOnly</code>的实际值均为<code class="code">true</code>。</p></td></tr></table></div></div></div><p>如果一个group被设置成<code class="code">postOnly=true</code>，那么，这个group将不接受通过GET方法提交的数据，只允许通过POST方式提交数据。这样可以略略增加系统的安全性，增加CSRF攻击的难度。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12022"><!--anchor d0e12022--></a>9.4.1.3. Trimming参数</h4></div></div></div><div class="example"><a id="d0e12025"><!--anchor d0e12025--></a><p class="title"><strong>例 9.19. 配置Trimming参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group1"</span> <span class="hl-attribute" style="color: #F5844C">trimmingByDefault</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.trimming.default"><!--anchor co.form.trimming.default--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">trimming</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.trimming.field"><!--anchor co.form.trimming.field--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.trimming.default"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果不指定，<code class="code">trimmingByDefault</code>的默认值为<code class="code">true</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.trimming.field"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果不指定，<code class="code">trimming</code>的值取决于<code class="code">trimmingByDefault</code>。这意味着如果什么也不设置，所有<code class="code">trimming</code>的实际值均为<code class="code">true</code>。</p></td></tr></table></div></div></div><p>用户所提交的字符串数据中，两端的空白往往是无意义的。这些空白可能会影响验证规则的准确性。</p><p>如果设置了<code class="code">trimming=true</code>参数，那么表单系统可以自动剪除字段值两端的空白字符，例如把<code class="code">“ my name
                        ”</code>（两端有空白）转变成<code class="code">“my name”</code>（两端无空白）。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12072"><!--anchor d0e12072--></a>9.4.1.4. Display Name参数</h4></div></div></div><div class="example"><a id="d0e12075"><!--anchor d0e12075--></a><p class="title"><strong>例 9.20. 配置Display Name参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.displayname"><!--anchor co.form.displayname--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong> <a id="co.form.displayname.ref"><!--anchor co.form.displayname.ref--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.displayname"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果未指定<code class="code">displayName</code>，那么其默认为field名称。也就是的“<code class="code">field1</code>”。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.displayname.ref"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>在validator
                                message中，可以引用<code class="code">${displayName}</code>。这样做的好处是，validator
                                message可以被复制给其它的field，而不是需要更动其信息内容。</p></td></tr></table></div></div></div><p>Display Name是对当前field的一个描述信息。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12102"><!--anchor d0e12102--></a>9.4.1.5. 类型转换</h4></div></div></div><div class="example"><a id="d0e12105"><!--anchor d0e12105--></a><p class="title"><strong>例 9.21. 类型转换的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">converterQuiet</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.convtype.quiet"><!--anchor co.form.convtype.quiet--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;services:property-editor-registrar</strong>
        <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.configuration.support.CustomDateRegistrar"</span>
        <span class="hl-attribute" style="color: #F5844C">p:format</span>=<span class="hl-value" style="color: #993300">"yyyy-MM-dd"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.convtype.editor"><!--anchor co.form.convtype.editor--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.convtype.quiet"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果<code class="code">converterQuiet=true</code>，那么类型转换失败时，将取得默认值。否则，抛出异常。<code class="code">converterQuiet</code>的默认值为<code class="code">true</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.convtype.editor"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>类型转换采用Spring Property
                                    Editor机制。你可以通过注册新的registrar来增加新的类型转换方法。这段配置增加了一种将日期转成字符串的方式（用<code class="code">yyyy-MM-dd</code>格式）。</p></td></tr></table></div></div></div><p>下面的操作将用到类型转换：</p><div class="table"><a id="d0e12135"><!--anchor d0e12135--></a><p class="title"><strong>表 9.6. 何时用到类型转换？</strong></p><div class="table-contents"><table summary="何时用到类型转换？" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">操作</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">Group.setProperties(bean)</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">将Group中的所有fields值注入bean properties。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">Group.mapTo(bean)</code></td><td style="">用bean properties中的值初始化group fields。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12160"><!--anchor d0e12160--></a>9.4.1.6. 国际化</h4></div></div></div><p>表单验证失败时，将在页面上显示错误信息。有两种方法可以定义错误信息：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>将错误信息直接定义在配置文件中。前文的例子所用的都是这种方案。</p></li><li class="listitem"><p>将错误信息定义在Spring Message Source中，从而支持国际化。</p></li></ul></div><p>为了将使用国际化（多语言）的错误信息，首先需要定义Spring Message Source。</p><div class="example"><a id="d0e12174"><!--anchor d0e12174--></a><p class="title"><strong>例 9.22. 在Spring Message Source中定义错误信息</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"messageSource"</span>
       <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>
       <span class="hl-attribute" style="color: #F5844C">p:defaultEncoding</span>=<span class="hl-value" style="color: #993300">"GB18030"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"basenames"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;list&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>form_msgs<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong> <a id="co.form.i18n.msgsrc"><!--anchor co.form.i18n.msgsrc--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/list&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/property&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.i18n.msgsrc"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>这段配置告诉spring去读取<code class="code">form_msgs</code>开头的resource bundle文件，例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>form_msgs.properties</p></li><li class="listitem"><p>form_msgs_zh_CN.properties</p></li><li class="listitem"><p>form.msgs_zh_TW.properties</p></li></ul></div></td></tr></table></div></div></div><p>请注意，Spring是从<code class="code">ResourceLoader</code>中读取resource
                    bundle文件的。因此，你可能需要配置Resource Loading以帮助spring找到这些消息文件。关于资源装载，请参见<a class="xref" href="#webx.resource" title="第 5 章 Resource Loading服务指南">第 5 章 <em>Resource Loading服务指南</em></a>。</p><p>使用message
                            source以后，你可以省略validator中的<code class="code">message</code>标签，但是<span class="emphasis"><em>每个validator必须指定<code class="code">id</code></em></span>。表单系统将会从message
                        source中查找指定的key：“<code class="code">form.&lt;GroupName&gt;.&lt;FieldName&gt;.&lt;ValidatorID&gt;</code>”。</p><div class="example"><a id="d0e12218"><!--anchor d0e12218--></a><p class="title"><strong>例 9.23. 配置validator ID</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"register"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"userId"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;required-validator</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"required"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.i18n.validator.id"><!--anchor co.form.i18n.validator.id--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.i18n.validator.id"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定了validator
                                    ID为<code class="code">required</code>，根据格式“<code class="code">form.&lt;GroupName&gt;.&lt;FieldName&gt;.&lt;ValidatorID&gt;</code>”，当前validator
                                    message的key为：“<code class="code">form.register.userId.required</code>”。</p></td></tr></table></div></div></div><p>假设message source定义文件及内容如下：</p><div class="table"><a id="d0e12240"><!--anchor d0e12240--></a><p class="title"><strong>表 9.7. Message Source的内容</strong></p><div class="table-contents"><table summary="Message Source的内容" cellpadding="10" style="border: none;"><colgroup><col width="37%" class="c1"/><col width="63%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">文件名</th><th style="border-bottom: 0.5pt solid #6666cc; ">内容</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="filename">form_msgs_zh_CN.properties</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">form.register.userId.required </span>= 必须填写用户名</pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="filename">form_msgs.properties</code></td><td style="">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">form.register.userId.required </span>= User ID is required</pre>
                                </td></tr></tbody></table></div></div><p>对于以上的message
                        source内容，在中文环境中（<code class="code">locale=zh_CN</code>），将显示错误信息“<code class="code">必须填写用户名</code>”；而在英文环境中（<code class="code">locale=en_US</code>），将显示默认的错误信息“<code class="code">User
                        ID is required</code>”。</p><p>系统的当前locale是由<code class="code">SetLocaleRequestContext</code>来决定的。关于<code class="code">SetLocaleRequestContext</code>的设定和使用，请参见<a class="xref" href="#webx.requestcontexts" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>。</p><p>此外，你还可以可以改变message source中key的前缀。</p><div class="example"><a id="d0e12297"><!--anchor d0e12297--></a><p class="title"><strong>例 9.24. 改变message source key的前缀</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">messageCodePrefix</span>=<span class="hl-value" style="color: #993300">"myform"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre></div></div><p>上面的配置将指导表单系统在message
                        source中查找指定的key：“<span class="emphasis"><em><code class="code">myform</code></em></span><code class="code">.GroupName.FieldName.ValidatorID</code>”。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12310"><!--anchor d0e12310--></a>9.4.1.7. 切分表单服务</h4></div></div></div><p>在实际的应用中，有时一个表单规则的配置文件会很长。将一个长文件切分成几个较短的文件，更有利于管理。表单验证服务支持导入多个form表单服务，从而实现分割较长配置文件的功能。</p><div class="example"><a id="d0e12315"><!--anchor d0e12315--></a><p class="title"><strong>例 9.25. 切分表单服务</strong></p><div class="example-contents"><p>主配置文件：<code class="filename">form.xml</code>：</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;beans:import</strong> <span class="hl-attribute" style="color: #F5844C">resource</span>=<span class="hl-value" style="color: #993300">"inc/form_part1.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.importform.import1"><!--anchor co.form.importform.import1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;beans:import</strong> <span class="hl-attribute" style="color: #F5844C">resource</span>=<span class="hl-value" style="color: #993300">"inc/form_part2.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.importform.import2"><!--anchor co.form.importform.import2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>

    <strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/validators"</span> <span class="hl-attribute" style="color: #F5844C">primary</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.importform.form"><!--anchor co.form.importform.form--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;services:import</strong> <span class="hl-attribute" style="color: #F5844C">form</span>=<span class="hl-value" style="color: #993300">"part1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.importform.import.part1"><!--anchor co.form.importform.import.part1--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;services:import</strong> <span class="hl-attribute" style="color: #F5844C">form</span>=<span class="hl-value" style="color: #993300">"part2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.importform.import.part2"><!--anchor co.form.importform.import.part2--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>

        ...
    <strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.importform.import1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.form.importform.import2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>导入包含着子表单服务的spring配置。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.importform.form"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义主表单服务时，<span class="emphasis"><em>必须指定<code class="code">primary="true"</code></em></span>。否则spring将无法区分主从表单服务，从而导致注入<code class="code">FormService</code>时失败。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.importform.import.part1"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> <a href="#co.form.importform.import.part2"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>导入指定ID的子表单服务。</p></td></tr></table></div><p>子表单服务的配置文件：<code class="filename">inc/form_part1.xml</code>和<code class="filename">inc/form_part2.xml</code>：</p><pre class="programlisting"><em class="hl-comment" style="color: green">&lt;!-- inc/form_part1.xml --&gt;</em>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"part1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.importform.part1"><!--anchor co.form.importform.part1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        ...
    <strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong>

<em class="hl-comment" style="color: green">&lt;!-- inc/form_part2.xml --&gt;</em>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"part2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.importform.part2"><!--anchor co.form.importform.part2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        ...
    <strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.importform.part1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.form.importform.part2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><span class="emphasis"><em>子表单服务必须指定ID。</em></span></p></td></tr></table></div></div></div><p>导入子表单服务，意味着将子表单服务中的所有groups导入到主表单的空间。主表单中的groups将会覆盖被导入子表单中的groups。也就是说，假如主表单中存在一个group，它的名字和被导入的子表单中的group同名，那么子表单中的group将被忽略。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12374"><!--anchor d0e12374--></a>9.4.1.8. Group的继承和导入</h4></div></div></div><p>在实际应用中，你会发现有一些groups的定义很相似。继承和导入的目的是让这些相似的groups之间可以共享共同的参数、字段和验证规则，避免重复定义。</p><p>下面是group继承的用法： </p><div class="example"><a id="d0e12381"><!--anchor d0e12381--></a><p class="title"><strong>例 9.26. 继承一个group</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"baseGroup"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span><strong class="hl-tag" style="color: #000096"> &gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator1 /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator2 /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"subGroup"</span> <span class="hl-attribute" style="color: #F5844C">extends</span>=<span class="hl-value" style="color: #993300">"baseGroup"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator3 /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field4"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre></div></div><p>这段配置中，<code class="code">subGroup</code>继承了<code class="code">baseGroup</code>。其效果是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">baseGroup</code>的参数（<code class="code">postOnly</code>、<code class="code">trimmingByDefault</code>）被<code class="code">subGroup</code>继承，除非<code class="code">subGroup</code>明确指定了该参数。</p></li><li class="listitem"><p><code class="code">baseGroup</code>中fields被<code class="code">subGroup</code>继承。具体来说：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">baseGroup</code>中不同名的fields被直接添加到<code class="code">subGroup</code>中。</p></li><li class="listitem"><p><code class="code">baseGroup</code>中同名的fields被<code class="code">subGroup</code>中的继承。具体来说：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p><code class="code">baseGroup</code>
                                                  field的参数（<code class="code">name</code>、<code class="code">displayName</code>、<code class="code">defaultValue</code>、<code class="code">trimming</code>、<code class="code">propertyName</code>）被<code class="code">subGroup</code>
                                                  field继承，除非<code class="code">subGroup</code>
                                                  field明确指定了该参数。</p></li><li class="listitem"><p><code class="code">baseGroup</code>
                                                  field中的validators被全部添加到<code class="code">subGroup</code>
                                                  field中。 </p></li></ul></div></li></ul></div></li></ul></div><p>因此，上面配置所定义的<code class="code">subGroup</code>和下面配置中的完全等效：</p><div class="example"><a id="d0e12477"><!--anchor d0e12477--></a><p class="title"><strong>例 9.27. Group继承的效果</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"subGroup"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator1 /&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 来自baseGroup --&gt;</em>
            <strong class="hl-tag" style="color: #000096">&lt;validator2 /&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 来自baseGroup --&gt;</em>
            <strong class="hl-tag" style="color: #000096">&lt;validator3 /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 来自baseGroup --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 来自baseGroup --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field4"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre></div></div><p>另一种和继承类似的功能是导入：</p><div class="example"><a id="d0e12484"><!--anchor d0e12484--></a><p class="title"><strong>例 9.28. 导入groups和fields</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:import</strong> <span class="hl-attribute" style="color: #F5844C">group</span>=<span class="hl-value" style="color: #993300">"group1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.import.group"><!--anchor co.form.import.group--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field4"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group3"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:import</strong> <span class="hl-attribute" style="color: #F5844C">group</span>=<span class="hl-value" style="color: #993300">"group1"</span> <span class="hl-attribute" style="color: #F5844C">field</span>=<span class="hl-value" style="color: #993300">"field1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.import.field"><!--anchor co.form.import.field--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
       <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field5"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.import.group"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>导入<code class="code">group1</code>中的全部fields。导入以后，<code class="code">group2</code>拥有的fields包括：<code class="code">field1</code>、<code class="code">field2</code>、<code class="code">field3</code>和<code class="code">field4</code>。其中，<code class="code">field1</code>、<code class="code">field2</code>、<code class="code">field3</code>均来自于<code class="code">group1</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.import.field"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>导入<code class="code">group1</code>中的一个field。导入以后，<code class="code">group3</code>拥有的fields包括：<code class="code">field1</code>和<code class="code">field5</code>。其中，<code class="code">field1</code>来自于<code class="code">group1</code>。</p></td></tr></table></div></div></div><p>导入有两种形式，导入全部fields和导入一个field。</p><p>导入和继承都可以使group共享一些内容，但是，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>继承只能有一个base group，而导入可以有多次import；</p></li><li class="listitem"><p>继承会合并同名的fields，而导入时则禁止同名fields的。在上例中，假如<code class="code">group2</code>已经有了<code class="code">field1</code>，那么再次导入<code class="code">group1</code>的<code class="code">field1</code>将会报错。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12571"><!--anchor d0e12571--></a>9.4.1.9. 设置默认值</h4></div></div></div><p>
                    </p><div class="example"><a id="d0e12576"><!--anchor d0e12576--></a><p class="title"><strong>例 9.29. 设置表单字段的默认值</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">defaultValue</span>=<span class="hl-value" style="color: #993300">"defaultValue"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>
                </p><p>当表单被创建时，所有的字段值默认都是空的 ——
                        除非你指定了<code class="code">defaultValue</code>。需要注意的是，<span class="emphasis"><em>默认值只影响初始表单。对于用户已经提交数据的表单不起作用</em></span>。</p><p>假如一个field需要多个值，例如多选的checkbox，那么它可以设置一个具有多值的默认值。方法是：用逗号分隔多值。像下面的样子：</p><div class="example"><a id="d0e12592"><!--anchor d0e12592--></a><p class="title"><strong>例 9.30. 设置多个值作为表单字段的默认值</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">defaultValue</span>=<span class="hl-value" style="color: #993300">"defaultValue1, defaultValue2, defaultValue3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12597"><!--anchor d0e12597--></a>9.4.1.10. Fields和properties</h4></div></div></div><p>Fields和properties是两个重要词汇。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Fields</span></dt><dd><p>Fields是指HTML表单中的form
                                fields，例如一个文本框textbox、复选框checkbox、hidden字段等。</p><p>Fields也是表单验证的基本单元。</p></dd><dt><span class="term">Properties</span></dt><dd><p>Properties是指Java
                                    bean中的数据成员，例如：<code class="code">setName(String)</code>方法定义了一个property：<code class="code">name</code>。</p></dd></dl></div><p>而在表单验证服务中，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">Group.setProperties(bean)</code>方法将fields中的值注入到bean的properties中。</p></li><li class="listitem"><p><code class="code">Group.mapTo(bean)</code>方法将bean
                                properties的值设置成fields的初始值。</p></li></ul></div><p>一般情况下，field的名称就是property的名称。然而有一些情况下，property名称和field名称会有出入。这时可以这样设置：</p><div class="example"><a id="d0e12638"><!--anchor d0e12638--></a><p class="title"><strong>例 9.31. 设置不同的property和field名称</strong></p><div class="example-contents"><pre class="programlisting">&lt;services:field name="homeAddress" propertyName="home.address" /&gt;</pre></div></div><p>其中，“<code class="code">homeAddress</code>”为field名称。如果不指定<code class="code">propertyName</code>的话，表单系统认为property名称也是“<code class="code">homeAddress</code>”。然而在这里，指定了property名称为“<code class="code">home.address</code>”
                    —— spring支持这种多级的property。在上面的配置中，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>当做<code class="code">Group.setProperties()</code>时，会执行<code class="code">bean.getHome().setAddress(value)</code>；</p></li><li class="listitem"><p>而做<code class="code">Group.mapTo()</code>时，会执行<code class="code">bean.getHome().getAddress()</code>。
                            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.form.validator.messages"><!--anchor webx.form.validator.messages--></a>9.4.1.11. Validator messages</h4></div></div></div><p>每一个validator都可以附带一段message文字，这段文字会在validator验证失败时显示给用户看。配置validator
                    message可以有下面两种写法：</p><div class="example"><a id="d0e12681"><!--anchor d0e12681--></a><p class="title"><strong>例 9.32. Validator message的两种写法</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;string-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>登录名最少必须由4个字组成，最多不能超过10个字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/string-length-validator&gt;</strong></pre><p>或者，你可以这样写：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;string-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 最少必须由${minLength}个字组成，最多不能超过${maxLength}个字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/string-length-validator&gt;</strong></pre></div></div><p>第二种形式使用了替换变量，例如：<code class="code">${displayName}</code>等。这种方法有较多好处：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>易复制 ——
                                    假如有多个fields中都包含<code class="code">string-length-validator</code>，由于每个fields的名称（<code class="code">displayName</code>）、validator的参数（<code class="code">minLength</code>、<code class="code">maxLength</code>）都不同，第一种形式是不可复制的，而第二种形式是通用的、可复制的。</p></li><li class="listitem"><p>易维护 ——
                                当validator的参数被修改时，例如<code class="code">minLength</code>被修改，对于第一种形式，你必须同时修改message字符串
                                —— 这很可能被忘记；而第二种形式就不需要修改message字符串。 </p></li></ul></div><p>事实上，validator message是一个JEXL表达式，其格式详见：<a class="link" href="http://commons.apache.org/jexl/reference/syntax.html" target="_top">http://commons.apache.org/jexl/reference/syntax.html</a>。
                    下面列出了在message中可用的变量和工具。</p><div class="table"><a id="d0e12721"><!--anchor d0e12721--></a><p class="title"><strong>表 9.8. Validator message中可用的变量和工具</strong></p><div class="table-contents"><table summary="Validator message中可用的变量和工具" cellpadding="10" style="border: none;"><colgroup><col width="28%" class="c1"/><col width="22%" class="c2"/><col width="50%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">分类</th><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">可用的变量和工具</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">当前Validator中的所有properties</td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2">
                                    <p>不同的validator有不同的properties。</p>
                                    <p>例如，对于<code class="code">&lt;string-length-validator minLength="4"
                                            maxLength="10"&gt;</code>，</p>
                                    <p>可取得的变量包括<code class="code">${minLength}</code>、<code class="code">${maxLength}</code></p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="6">当前Field对象中的所有properties</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${displayName}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">Field显示名</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${defaultValue}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">默认值（<code class="code">String</code>）</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${defaultValues}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">默认值数组（<code class="code">String[]</code>）</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${value}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">当前field的值（<code class="code">Object</code>）</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${values}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">当前field的一组值（<code class="code">Object[]</code>）</td></tr><tr><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2">特定类型的值，例如：<code class="code">${booleanValue}</code>、<code class="code">${intValue}</code>等。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">当前Group中的其它Field对象</td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2">
                                    <p>例如：<code class="code">${userId}</code>，<code class="code">${password}</code>等。</p>
                                    <p>如果想取得其值，必须这样写：<code class="code">${userId.value}</code></p>
                                    <p>也可取得其它Field
                                            properties，例如：<code class="code">${userId.displayName}</code></p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">当前的Group对象</td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2"><code class="code">${group}</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">当前的Form对象</td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2"><code class="code">${form}</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">System properties</td><td style="border-bottom: 0.5pt solid #6666cc; " colspan="2">
                                    <p>所有从<code class="code">System.getProperties()</code>中取得的值，</p>
                                    <p>例如：<code class="code">${user.dir}</code>、<code class="code">${java.home}</code>等</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">小工具</td><td style="" colspan="2">
                                    <p><code class="code">${utils}</code>，其中包含了很多静态方法。</p>
                                    <p>例如：<code class="code">${utils.repeat("a",
                                            10)}</code>将会生成10个“<code class="code">a</code>”。</p>
                                    <p>详见<code class="classname">com.alibaba.citrus.util.Utils</code>类的API文档。</p>
                                </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12891"><!--anchor d0e12891--></a>9.4.2. Validators</h3></div></div></div><p>每个field都可以包含多个validators。Validators是用来验证当前field的正确性的。表单验证系统提供了很多常用的validators。然而，如果不够用，你还可以随时扩展出新的validators。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12896"><!--anchor d0e12896--></a>9.4.2.1. 验证必选项：<code class="code">&lt;required-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e12901"><!--anchor d0e12901--></a><p class="title"><strong>例 9.33. 配置<code class="code">&lt;required-validator&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>这是最常用的一个验证器。它的功能是确保用户填写了字段，即确保字段值非空。</p><p>需要注意的是，必选项验证器会受到<code class="code">trimming</code>参数的影响。假如<code class="code">trimming=true</code>（默认值），而用户输入了一组空白字符，那么仍然被认为“字段值为空”；反之，如果<code class="code">trimming=false</code>，当用户输入空白时，会被认为“字段值非空”。</p><p>除了必选项验证器以外，其它<span class="emphasis"><em>绝大多数的验证器并不会判断字段值是否为空</em></span>。例如：</p><div class="example"><a id="d0e12926"><!--anchor d0e12926--></a><p class="title"><strong>例 9.34. 绝大多数的验证器并不会判断字段值是否为空</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"userId"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"登录名"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;regexp-validator</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^[A-Za-z_][A-Za-z_0-9]*$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须由字母、数字、下划线构成<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/regexp-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>在这个例子中，<span class="emphasis"><em>即便用户什么也没填，<code class="code">&lt;regexp-validator&gt;</code>也会通过验证</em></span>。换言之，<code class="code">&lt;regexp-validator&gt;</code>只负责当字段值非空时，检查其是否符合特写的格式。</p><p>因此通常需要将必选项验证器和其它验证器配合起来验证。如下例：</p><div class="example"><a id="d0e12944"><!--anchor d0e12944--></a><p class="title"><strong>例 9.35. 将必选项验证器和其它验证器配合起来验证</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"userId"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"登录名"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;regexp-validator</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^[A-Za-z_][A-Za-z_0-9]*$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须由字母、数字、下划线构成<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/regexp-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>这样配置以后，就可以确保：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>字段值非空；</p></li><li class="listitem"><p>字段值符合特定格式。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12958"><!--anchor d0e12958--></a>9.4.2.2. 验证字符串长度：<code class="code">&lt;string-length-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e12963"><!--anchor d0e12963--></a><p class="title"><strong>例 9.36. 配置<code class="code">&lt;string-length-validator&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;string-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 最少必须由${minLength}个字组成，最多不能超过${maxLength}个字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/string-length-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器确保用户输入的字段值的字符数在确定的范围内。</p><p>可用的参数：</p><div class="table"><a id="d0e12974"><!--anchor d0e12974--></a><p class="title"><strong>表 9.9. <code class="code">&lt;string-length-validator&gt;</code>的可用参数： </strong></p><div class="table-contents"><table summary="&lt;string-length-validator&gt;的可用参数： " cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">minLength</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表最少字符数，如不设置<code class="code">minLength</code>代表最代表不设下限。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">maxLength</code></td><td style="">代表最多字符数，如果不设置<code class="code">maxLength</code>则代表不设上限，允许任意多个字符。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13007"><!--anchor d0e13007--></a>9.4.2.3. 验证字符串字节长度：<code class="code">&lt;string-byte-length-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13012"><!--anchor d0e13012--></a><p class="title"><strong>例 9.37. <code class="code">&lt;string-byte-length-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;string-byte-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span> <span class="hl-attribute" style="color: #F5844C">charset</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 最少必须由${minLength}个字节组成，最多不能超过${maxLength}个字节<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/string-byte-length-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器也是用来验证字符值的长度的。但是和前面所讲的<code class="code">&lt;string-length-validator&gt;</code>不同的是，<code class="code">&lt;string-byte-length-validator&gt;</code>会将字符串先转换成字节串，然后判断这个字节串的长度。</p><p>为什么需要判定字节的长度呢？因为在数据库中，常用字节长度而不是字符长度来表示一个字段的长度的。例如：<code class="code">varchar(20)</code>代表该数据库字段可接受的字节长度为20字节，超过部分将被截断。20字节可填入：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>20个英文字母、数字，</p></li><li class="listitem"><p>或者6个UTF-8编码的汉字，</p></li><li class="listitem"><p>或者10个GBK编码的汉字。</p></li></ul></div><p>可见20字节所能容纳的字符数是不确定的，取决于字符的类型（中文、英文、数字等），以及字符集编码的类型（<code class="code">ISO-8859-1</code>、<code class="code">UTF-8</code>、<code class="code">GBK</code>等）。</p><p>可用的参数：</p><div class="table"><a id="d0e13055"><!--anchor d0e13055--></a><p class="title"><strong>表 9.10. <code class="code">&lt;string-byte-length-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;string-byte-length-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">minLength</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表最少字节数，如不设置<code class="code">minLength</code>代表最代表不设下限。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">maxLength</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表最多字节数，如果不设置<code class="code">maxLength</code>则代表不设上限，允许任意多个字符。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">charset</code></td><td style="">用来将字符串转换成字节，如不设置，则取当前线程的上下文编码。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13094"><!--anchor d0e13094--></a>9.4.2.4. 比较字符串：<code class="code">&lt;string-compare-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13099"><!--anchor d0e13099--></a><p class="title"><strong>例 9.38. <code class="code">&lt;string-compare-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;string-compare-validator</strong> <span class="hl-attribute" style="color: #F5844C">notEqualTo</span>=<span class="hl-value" style="color: #993300">"field2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 不能与 ${field2.displayName} 相同<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/string-compare-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器将当前字段的值和另一个字段比较。</p><p>可用的参数：</p><div class="table"><a id="d0e13110"><!--anchor d0e13110--></a><p class="title"><strong>表 9.11. <code class="code">&lt;string-compare-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;string-compare-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">equalTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">确保当前字段值和指定的另一字段的值相同。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">notEqualTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">确保当前字段值和指定的另一字段的值不相同。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">ignoreCase</code></td><td style="">如果为<code class="code">true</code>，则比较时忽略大小写。默认为<code class="code">false</code>，即比较大小写。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13149"><!--anchor d0e13149--></a>9.4.2.5. 用正则表达式验证：<code class="code">&lt;regexp-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13154"><!--anchor d0e13154--></a><p class="title"><strong>例 9.39. <code class="code">&lt;regexp-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;regexp-validator</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^[A-Za-z_][A-Za-z_0-9]*$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须由字母、数字、下划线构成<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/regexp-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器用正则表达式来验证字符串的格式。</p><p>可用的参数：</p><div class="table"><a id="d0e13165"><!--anchor d0e13165--></a><p class="title"><strong>表 9.12. <code class="code">&lt;regexp-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;regexp-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">pattern</code></td><td style="">
                                    <p>用来匹配字符串的正则表达式。需要注意的是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>表达式为部分匹配，例如：表达式“<code class="code">abc</code>”可以匹配用户输入“<code class="code">xabcy</code>”。如果期望匹配完整字符串，必须使用“<code class="code">^</code>”和“<code class="code">$</code>”标识符。例如表达式“<code class="code">^abc$</code>”只能匹配“<code class="code">abc</code>”而不能匹配“<code class="code">xabcy</code>”。</p></li><li class="listitem"><p>表达式支持否定匹配，例如：表达式“<code class="code">!abc</code>”可以匹配所有不包含“<code class="code">abc</code>”的字符串。</p></li></ul></div>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13223"><!--anchor d0e13223--></a>9.4.2.6. 验证电子邮件地址：<code class="code">&lt;mail-address-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13228"><!--anchor d0e13228--></a><p class="title"><strong>例 9.40. <code class="code">&lt;mail-address-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;mail-address-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须是合法电子邮件地址<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/mail-address-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器用来确保用户输入了合法的电子邮件地址。</p><p>事实上，该验证器使用了一个比较宽松的正则表达式来验证电子邮件地址：“<code class="code">^\S+@[^\.]\S*$</code>”。假如你觉得这个正则表达式不足以验证你所需要的邮件地址，你可以利用<code class="code">&lt;regexp-validator&gt;</code>和自定义的正则表达式来直接验证。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13245"><!--anchor d0e13245--></a>9.4.2.7. 验证数字：<code class="code">&lt;number-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13250"><!--anchor d0e13250--></a><p class="title"><strong>例 9.41. <code class="code">&lt;number-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;number-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须是数字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/number-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field2"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;number-validator</strong> <span class="hl-attribute" style="color: #F5844C">numberType</span>=<span class="hl-value" style="color: #993300">"int"</span> <span class="hl-attribute" style="color: #F5844C">lessThan</span>=<span class="hl-value" style="color: #993300">"100"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须是小于${lessThan}的整数<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/number-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器用来确保用户输入了合法的数字。数字的合法性包括：格式的合法和范围的合法。</p><p>可用的参数： </p><div class="table"><a id="d0e13261"><!--anchor d0e13261--></a><p class="title"><strong>表 9.13. <code class="code">&lt;number-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;number-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">numberType</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">数字的类型。可用的类型为：<code class="code">int</code>、<code class="code">long</code>、<code class="code">float</code>、<code class="code">double</code>、<code class="code">bigDecimal</code>。如不设置，默认值为<code class="code">int</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">equalTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>等于</em></span>指定值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">notEqualTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>不等于</em></span>指定值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">lessThan</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>小于</em></span>指定值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">lessThanOrEqualTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>小于或等于</em></span>指定值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">greaterThan</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>大于</em></span>指定值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">greaterThanOrEqualTo</code></td><td style="">可选数字范围：要求数字<span class="emphasis"><em>大于或等于</em></span>指定值。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13354"><!--anchor d0e13354--></a>9.4.2.8. 比较数字：<code class="code">&lt;number-compare-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13359"><!--anchor d0e13359--></a><p class="title"><strong>例 9.42. <code class="code">&lt;number-compare-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;number-compare-validator</strong> <span class="hl-attribute" style="color: #F5844C">greaterThanOrEqualTo</span>=<span class="hl-value" style="color: #993300">"field2"</span> <span class="hl-attribute" style="color: #F5844C">lessThan</span>=<span class="hl-value" style="color: #993300">"field3"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须是位于 ${field2.displayName} 和 ${field3.displayName}之间的数字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/number-compare-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器将当前字段的值和另一个字段比较。</p><p>可用的参数： </p><div class="table"><a id="d0e13370"><!--anchor d0e13370--></a><p class="title"><strong>表 9.14. <code class="code">&lt;number-compare-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;number-compare-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">numberType</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">数字的类型。可用的类型为：<code class="code">int</code>、<code class="code">long</code>、<code class="code">float</code>、<code class="code">double</code>、<code class="code">bigDecimal</code>。如不设置，默认值为<code class="code">int</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">equalTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>等于</em></span>指定字段的值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">notEqualTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>不等于</em></span>指定字段的值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">lessThan</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>小于</em></span>指定字段的值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">lessThanOrEqualTo</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>小于或等于</em></span>指定字段的值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">greaterThan</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选数字范围：要求数字<span class="emphasis"><em>大于</em></span>指定字段的值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">greaterThanOrEqualTo</code></td><td style="">可选数字范围：要求数字<span class="emphasis"><em>大于或等于</em></span>指定字段的值。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13463"><!--anchor d0e13463--></a>9.4.2.9. 验证日期：<code class="code">&lt;date-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13468"><!--anchor d0e13468--></a><p class="title"><strong>例 9.43. <code class="code">&lt;date-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;date-validator</strong> <span class="hl-attribute" style="color: #F5844C">format</span>=<span class="hl-value" style="color: #993300">"yyyy-MM-dd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须是日期，格式为 ${format}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/date-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器用来确保用户输入正确的日期格式，也可以限定日期的范围。</p><p>可用的参数： </p><div class="table"><a id="d0e13479"><!--anchor d0e13479--></a><p class="title"><strong>表 9.15. <code class="code">&lt;date-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;date-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">format</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">日期的格式，如不指定，默认为<code class="code">yyyy-MM-dd</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">minDate</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">可选的日期范围：最早的日期。该日期格式也是用<code class="code">format</code>参数来表示的。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">maxDate</code></td><td style="">可选的日期范围：最晚的日期。该日期格式也是用<code class="code">format</code>参数来表示的。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13521"><!--anchor d0e13521--></a>9.4.2.10. 验证上传文件：<code class="code">&lt;uploaded-file-validator&gt;</code></h4></div></div></div><div class="example"><a id="d0e13526"><!--anchor d0e13526--></a><p class="title"><strong>例 9.44. <code class="code">&lt;uploaded-file-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"picture"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"产品图片"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;uploaded-file-validator</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"jpg, gif, png"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName}不是合法的图片文件<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/uploaded-file-validator&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;uploaded-file-validator</strong> <span class="hl-attribute" style="color: #F5844C">maxSize</span>=<span class="hl-value" style="color: #993300">"100K"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName}不能超过${maxSize}字节<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/uploaded-file-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>该验证器用来验证用户上传文件的大小、类型等信息。</p><p>可用的参数： </p><div class="table"><a id="d0e13537"><!--anchor d0e13537--></a><p class="title"><strong>表 9.16. <code class="code">&lt;date-validator&gt;</code>的可用参数：</strong></p><div class="table-contents"><table summary="&lt;date-validator&gt;的可用参数：" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">minSize</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">最小文件尺寸。可使用K/M等单位，例如：<code class="code">10K</code>、<code class="code">1M</code>等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">maxSize</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">最大文件尺寸。可使用K/M等单位，例如：<code class="code">10K</code>、<code class="code">1M</code>等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">extension</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <p>允许的文件名后缀，多个后缀以逗号分隔。例如：<code class="code">gif</code>、<code class="code">jpg</code>、<code class="code">png</code>。</p>
                                    <p>注意，文件名是由浏览器传递给服务器的，因此<span class="emphasis"><em>验证器并不能保证保证文件确实是文件名后缀声明的格式</em></span>。</p>
                                    <p>例如，<code class="code">xxx.jpg</code>有可能是一个<code class="code">exe</code>可执行文件。
                                    </p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">contentType</code></td><td style="">
                                    <p>允许的文件类型，多个类型以逗号分隔。</p>
                                    <p>例如：<code class="code">image/gif</code>, <code class="code">image/jpeg</code>,
                                            <code class="code">image/pjpeg</code>, <code class="code">image/jpg</code>,
                                            <code class="code">image/png</code>。</p>
                                    <p>注意，<code class="code">contentType</code>是由浏览器传递给服务器的，因此<span class="emphasis"><em>验证器并不能保证文件确实是浏览器所声明的格式</em></span>。</p>
                                    <p>其次，有些浏览器不会传送<code class="code">contentType</code>。因此<span class="emphasis"><em>推荐使用<code class="code">extension</code>文件名后缀验证</em></span>，来取代<code class="code">contentType</code>验证。
                                    </p>
                                </td></tr></tbody></table></div></div><p>注意：（请补充阅读<a class="xref" href="#webx.requestcontexts" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>）</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>上传文件验证只能检查浏览器所声称的文件名后缀和类型，并不能保证文件名后缀和类型属实。如果你希望进一步检查文件的内容，可以结合<code class="code">request-contexts/parser/filter</code>的功能。</p></li><li class="listitem"><p>假如设置了<code class="code">request-contexts/parser/uploaded-file-whitelist</code>，那么不符合要求的文件会在进入表单验证之前被删除。因此上传文件验证器的<code class="code">extension</code>参数必须存在于<code class="code">uploaded-file-whitelist.extensions</code>列表当中。</p></li><li class="listitem"><p>Upload服务可限制请求的总尺寸，大于该尺寸的请求会被全部忽略，以保证服务器的安全性 ——
                                这意味着对于这类超大请求，你根本读不到这个请求中的所有参数，当然也不可能执行到表单验证的阶段。</p></li><li class="listitem"><p>Upload服务可以限制每个上传文件的尺寸，大于指定尺寸的文件会被删除。但只要请求的总尺寸还是在许可范围内，那么除了被删文件以外，其它的参数和文件还是可以被取得的。因此，上传文件验证器的maxSize必须小于upload服务中设置的单个文件的最大尺寸才有意义。
                            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13689"><!--anchor d0e13689--></a>9.4.2.11. 验证CSRF token</h4></div></div></div><p>CSRF是跨站请求伪造（Cross-site request
                    forgery）的意思，它是一种常见的WEB网站攻击方法。攻击者通过各种方法伪造一个请求，模仿用户提交表单的行为，从而达到修改用户的数据，或者执行特定任务的目的。为了假冒用户的身份，CSRF攻击常常和XSS攻击配合起来做，但也可以通过其它手段，例如诱使用户点击一个包含攻击的链接。</p><p>通过CSRF token，可以确保该请求确实是用户本人填写表单并提交的，而不是第三者伪造的，从而避免CSRF攻击。CSRF
                    token验证器是用来确保表单中包含了CSRF token。</p><p>CSRF token的验证是每个表单都需要的安全功能，所以通常可利用group的继承功能来定义CSRF token验证器。</p><div class="example"><a id="d0e13698"><!--anchor d0e13698--></a><p class="title"><strong>例 9.45. <code class="code">&lt;csrf-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"csrfTokenCheckGroup"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"csrfToken"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;csrf-validator&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>您提交的表单已过期<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/csrf-validator&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"group1"</span> <span class="hl-attribute" style="color: #F5844C">extends</span>=<span class="hl-value" style="color: #993300">"csrfTokenCheckGroup"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong></pre></div></div><p>除了表单验证以外，实现CSRF验证还需要其它几个步骤：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>定义pull tool。</p><div class="example"><a id="d0e13711"><!--anchor d0e13711--></a><p class="title"><strong>例 9.46. 定义CSRF pull tool</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pull</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pull/factories"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;csrfToken /&gt;</strong> <a id="co.form.csrf.tokentool"><!--anchor co.form.csrf.tokentool--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pull&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.csrf.tokentool"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义了pull tool以后，可以在模板中以<code class="code">$csrfToken</code>来引用它。</p></td></tr></table></div></div></div></li><li class="listitem"><p>在每一个表单中创建一个保存着CSRF token的hidden字段。</p><div class="example"><a id="d0e13728"><!--anchor d0e13728--></a><p class="title"><strong>例 9.47. 在模板中插入包含CSRF token的hidden字段</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">""</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"post"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
  $csrfToken.hiddenField <a id="co.form.csrf.hiddenfield"><!--anchor co.form.csrf.hiddenfield--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
  <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"action"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"LoginAction"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
  ...
<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.csrf.hiddenfield"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>调用<code class="code">$csrfToken.hiddenField</code>以后将创建一个包含CSRF long
                                        live
                                            token的hidden字段，等同于调用<code class="code">$csrfToken.longLiveHiddenField</code>。</p><p>有两种CSRF token，你也可以用下面两种方法来创建它们：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>创建unique
                                                  token：<code class="code">$csrfToken.uniqueHiddenField</code>。这种类型的token不仅能防止CSRF攻击，还能防止重复提交表单。</p></li><li class="listitem"><p>创建long live
                                                  token：<code class="code">$csrfToken.longLiveHiddenField</code>。这种类型的token只能防止CSRF攻击，不能防止重复提交表单。</p></li></ul></div></td></tr></table></div></div></div></li><li class="listitem"><p>在pipeline中验证token。</p><div class="example"><a id="d0e13763"><!--anchor d0e13763--></a><p class="title"><strong>例 9.48. </strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong> <a id="co.form.csrf.valve"><!--anchor co.form.csrf.valve--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.csrf.valve"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>此处可以指定一个<code class="code">tokenKey</code>参数。如果不指定，将使用默认的token
                                            key：<code class="code">_csrf_token</code>。</p></td></tr></table></div></div></div></li><li class="listitem"><p>在表单验证中指定<code class="code">postOnly=true</code>（默认值），有助于提高CSRF攻击的难度。</p><div class="example"><a id="d0e13785"><!--anchor d0e13785--></a><p class="title"><strong>例 9.49. 配置Post Only参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">postOnlyByDefault</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre></div></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13790"><!--anchor d0e13790--></a>9.4.2.12. Custom Error – 由action来验证数据</h4></div></div></div><p>有一些情况下，由validator来验证数据并不方便。例如，当我们注册帐户时，即便用户名的格式完全正确（由字母和数字构成，并在指定的字数范围之内），也有可能注册不成功的。原因是当前用户名已经被其它用户注册使用了。而判断用户名是否可用，最简单的办法是在action中通过访问数据库来确定。</p><p>Custom Error“验证器”就是用来满足这个需求。</p><div class="example"><a id="d0e13797"><!--anchor d0e13797--></a><p class="title"><strong>例 9.50. &lt;custom-error&gt;的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"register"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"userId"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"登录名"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;regexp-validator</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^[A-Za-z_][A-Za-z_0-9]*$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 必须由字母、数字、下划线构成<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/regexp-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;string-length-validator</strong> <span class="hl-attribute" style="color: #F5844C">minLength</span>=<span class="hl-value" style="color: #993300">"4"</span> <span class="hl-attribute" style="color: #F5844C">maxLength</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName} 最少必须由${minLength}个字组成，最多不能超过${maxLength}个字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/string-length-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;custom-error</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"duplicatedUserId"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.customerr"><!--anchor co.form.customerr--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>登录名“${userId}”已经被人注掉了，请尝试另一个名字<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/custom-error&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.customerr"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Custom Error“验证器”不做任何验证 —— 它把验证的责任交给action来做。但是除此以外，它和其它验证器完全相同 ——
                                你可以设置message，甚至可以用message
                                source来实现国际化的错误提示。你不需要把错误提示写在代码中，或者启用另一种错误提示方案。</p></td></tr></table></div></div></div><p>对于custom error，需要在action中有相应的支持，否则不会自动生效：</p><div class="example"><a id="d0e13810"><!--anchor d0e13810--></a><p class="title"><strong>例 9.51. 用来生成custom error的action代码</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> doRegister(<em><span class="hl-annotation" style="color: gray">@FormField(name = "userId", group = "register")</span></em> CustomErrors err, <a id="co.form.customerr.inject"><!--anchor co.form.customerr.inject--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
                           ...) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
    <strong class="hl-keyword" style="color: maroon">try</strong> {
        ...
    } <strong class="hl-keyword" style="color: maroon">catch</strong> (DuplicatedUserException e) {
        Map&lt;String, Object&gt; params = createHashMap();
        params.put(<strong class="hl-string"><em style="color:navy">"userId"</em></strong>, user.getUserId());

        err.setMessage(<strong class="hl-string"><em style="color:navy">"duplicatedUserId"</em></strong>, params); <a id="co.form.customerr.setmsg"><!--anchor co.form.customerr.setmsg--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.customerr.inject"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>注入<code class="code">CustomErrors</code>接口。和注入Field的方法相同，通过<code class="code">@FormField</code>注解指明<code class="code">CustomErrors</code>所在的
                                group名称以及field名称。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.customerr.setmsg"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>调用<code class="code">CustomeErrors.setMessage()</code>方法。其中，“<code class="code">duplicatedUserId</code>”就是配置文件中<code class="code">&lt;custom-error&gt;</code>的<code class="code">id</code>。</p><p>第二个参数<code class="code">params</code>是可选的。它是一个<code class="code">Map</code>，其中的所有值，都可以在<code class="code">&lt;custom-error&gt;</code>的<code class="code">message</code>中访问到。例如，这里指定的<code class="code">userId</code>参数值，就可以被<code class="code">message</code>表达式<code class="code">${userId}</code>所访问。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13870"><!--anchor d0e13870--></a>9.4.2.13. 条件验证</h4></div></div></div><p>条件验证就是让某些validator仅在条件满足时才验证。条件验证有两种，单分支和多分支验证。</p><div class="example"><a id="d0e13875"><!--anchor d0e13875--></a><p class="title"><strong>例 9.52. 单分支条件验证</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"other"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"其它建议"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"commentCode.value == 'other'"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;required-validator&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/required-validator&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><div class="example"><a id="d0e13880"><!--anchor d0e13880--></a><p class="title"><strong>例 9.53. 多分支条件验证</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"field1"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"我的字段"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;when</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"expr1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;when</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"expr2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre></div></div><p>在上面的配置示例中，<code class="code">&lt;if&gt;</code>和<code class="code">&lt;when&gt;</code>都支持的<code class="code">test</code>参数，其内容为JEXL表达式。其格式详见：<a class="link" href="http://commons.apache.org/jexl/reference/syntax.html" target="_top">http://commons.apache.org/jexl/reference/syntax.html</a>。JEXL表达式中可用的变量同Validator messages中可用的变量，请参见：<a class="xref" href="#webx.form.validator.messages" title="9.4.1.11. Validator messages">第 9.4.1.11 节 “Validator messages”</a>。 除此之外，条件分支还支持任意自定义的条件，方法是： </p><div class="example"><a id="d0e13900"><!--anchor d0e13900--></a><p class="title"><strong>例 9.54. 在条件验证中自定义条件</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;if</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:fm-conditions</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/conditions"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fm-conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"xxx"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.conditional.if"><!--anchor co.form.conditional.if--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong>
...
<strong class="hl-tag" style="color: #000096">&lt;when</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:fm-conditions</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/form/conditions"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;fm-conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"xxx"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.form.conditional.when"><!--anchor co.form.conditional.when--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.conditional.if"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.form.conditional.when"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>实现类只需要实现<code class="code">Condition</code>接口就可以了。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13916"><!--anchor d0e13916--></a>9.4.2.14. 多值验证</h4></div></div></div><p>HTML表单字段均支持多值。比如：</p><div class="example"><a id="d0e13921"><!--anchor d0e13921--></a><p class="title"><strong>例 9.55. 具有多值的HTML表单字段</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;p&gt;</strong>你喜欢吃哪些食物？<strong class="hl-tag" style="color: #000096">&lt;/p&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"checkbox"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"poll"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"italian"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> 意大利菜
<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"checkbox"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"poll"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"french"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> 法国菜
<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"checkbox"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"poll"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"chinese"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> 中国菜</pre><p>当用户选择了多个复选框并提交以后，在表单系统中体现为数组：</p><pre class="programlisting">field.getName();   <em class="hl-comment" style="color: green">// "poll"</em>
field.getValues(); <em class="hl-comment" style="color: green">// "italian", "french", "chinese"</em></pre></div></div><p>不仅仅是复选框，任何其它类型的输入框（textbox、hidden field、file
                    upload等）都支持多值。然而前面所说的所有validator只对field中的第一个值进行验证。假如我希望对多个值同时进行验证，该怎么办呢？表单验证服务提供了一组用于多值验证的validators。</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e13932"><!--anchor d0e13932--></a>9.4.2.14.1. 验证值的数量</h5></div></div></div><div class="example"><a id="d0e13935"><!--anchor d0e13935--></a><p class="title"><strong>例 9.56. <code class="code">&lt;multi-values-count-validator&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"poll"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"调查"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;multi-values-count-validator</strong> <span class="hl-attribute" style="color: #F5844C">minCount</span>=<span class="hl-value" style="color: #993300">"1"</span> <span class="hl-attribute" style="color: #F5844C">maxCount</span>=<span class="hl-value" style="color: #993300">"3"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.mvalues.count"><!--anchor co.form.mvalues.count--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>至少选择${minCount}项，最多选择${maxCount}项<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/multi-values-count-validator&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.mvalues.count"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>对用户提交的值的数量进行验证，迫使用户选择1-3项他喜欢的食物。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e13948"><!--anchor d0e13948--></a>9.4.2.14.2. 要求所有值均通过验证</h5></div></div></div><div class="example"><a id="d0e13951"><!--anchor d0e13951--></a><p class="title"><strong>例 9.57. <code class="code">&lt;all-of-values&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;all-of-values&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${allMessages}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/all-of-values&gt;</strong></pre></div></div><p>只有当前字段的所有值都符合要求，<code class="code">&lt;all-of-values&gt;</code>验证才会通过。其<code class="code">message</code>支持<code class="code">${allMessages}</code>，它是一个<code class="code">List</code>列表，可以用来显示所有未通过验证的validators的消息。</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e13972"><!--anchor d0e13972--></a>9.4.2.14.3. 要求任意一个值通过验证</h5></div></div></div><div class="example"><a id="d0e13975"><!--anchor d0e13975--></a><p class="title"><strong>例 9.58. <code class="code">&lt;any-of-values&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;any-of-values&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>至少有一个${displayName}要符合要求<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/any-of-values&gt;</strong></pre></div></div><p>只要当前字段有一个值通过验证，<code class="code">&lt;any-of-values&gt;</code>验证就会通过。其<code class="code">message</code>支持<code class="code">${valueIndex}</code>代表被验证通过的值的序号；支持<code class="code">${allMessages}</code>，它是一个<code class="code">List</code>列表，可以用来显示所有未通过验证的validators的消息。</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e13999"><!--anchor d0e13999--></a>9.4.2.14.4. 要求任意一个值都不通过验证</h5></div></div></div><div class="example"><a id="d0e14002"><!--anchor d0e14002--></a><p class="title"><strong>例 9.59. <code class="code">&lt;none-of-values&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;none-of-values&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>所有${displayName}都不能符合要求<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/none-of-values&gt;</strong></pre></div></div><p>只要当前字段有一个值通过验证，<code class="code">&lt;none-of-values&gt;</code>验证就会失败。</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14014"><!--anchor d0e14014--></a>9.4.2.15. 组合验证</h4></div></div></div><p>组合验证就是将validators组合起来，类似于Java中的and（<code class="code">&amp;&amp;</code>）、or（<code class="code">||</code>）、not（<code class="code">!</code>）等操作符的功能。</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e14028"><!--anchor d0e14028--></a>9.4.2.15.1. 要求所有validators通过验证</h5></div></div></div><div class="example"><a id="d0e14031"><!--anchor d0e14031--></a><p class="title"><strong>例 9.60. <code class="code">&lt;all-of&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;all-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/all-of&gt;</strong></pre></div></div><p>只要有一个validator通不过验证，就失败。<code class="code">&lt;all-of&gt;</code>不需要设置<code class="code">message</code>，它的<code class="code">message</code>就是第一个没有通过验证的validator的<code class="code">message</code>。</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e14052"><!--anchor d0e14052--></a>9.4.2.15.2. 要求任意一个validators通过验证</h5></div></div></div><div class="example"><a id="d0e14055"><!--anchor d0e14055--></a><p class="title"><strong>例 9.61. <code class="code">&lt;any-of&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;any-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${allMessages}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/any-of&gt;</strong></pre></div></div><p>只要有一个validator通过验证，<code class="code">&lt;any-of&gt;</code>验证就会通过。其<code class="code">message</code>支持<code class="code">${allMessages}</code>，它是一个<code class="code">List</code>列表，可以用来可以用来显示所有未通过验证的validators的消息。</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="d0e14076"><!--anchor d0e14076--></a>9.4.2.15.3. 要求任何一个validators都通不过验证</h5></div></div></div><div class="example"><a id="d0e14079"><!--anchor d0e14079--></a><p class="title"><strong>例 9.62. <code class="code">&lt;none-of&gt;</code>的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;none-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>${displayName}不符合要求<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/none-of&gt;</strong></pre></div></div><p>只要有一个validator通过验证，<code class="code">&lt;none-of&gt;</code>验证就会失败。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14091"><!--anchor d0e14091--></a>9.4.3. Form Tool</h3></div></div></div><p>Form Tool是一个pull tool工具，配置如下：</p><div class="example"><a id="d0e14096"><!--anchor d0e14096--></a><p class="title"><strong>例 9.63. Form Tool的配置</strong></p><div class="example-contents"><pre class="programlisting">&lt;services:pull xmlns="http://www.alibaba.com/schema/services/pull/factories"&gt;
    &lt;form-tool /&gt;
    ...
&lt;/services:pull&gt;</pre></div></div><p>上面的配置定义了一个<code class="code">$form</code>工具。可以在模板中直接使用它。下页简单介绍在模板中，<code class="code">$form</code>工具的用法。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14109"><!--anchor d0e14109--></a>9.4.3.1. Form API</h4></div></div></div><div class="table"><a id="d0e14112"><!--anchor d0e14112--></a><p class="title"><strong>表 9.17. 有关Form的API</strong></p><div class="table-contents"><table summary="有关Form的API" cellpadding="10" style="border: none;"><colgroup><col width="58%" class="c1"/><col width="42%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">API用法</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#if ($form.valid) ... #end</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前form是否验证为合法，或者未经过验证。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#set ($group =
                                    $form.group1.defaultInstance)</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">取得<code class="code">group1</code>的默认实例，如果不存在，则创建之。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#set ($group =
                                    $form.group1.getInstance("id"))</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">取得<code class="code">group1</code>的指定<code class="code">id</code>的实例，如果不存在，则创建之。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#set ($group = $form.group1.getInstance("id",
                                        false))</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">取得<code class="code">group1</code>的指定<code class="code">id</code>的实例，如果不存在，则返回<code class="code">null</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#foreach ($group in $form.groups) ...
                                    #end</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">遍历当前form中所有group实例。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">#foreach ($group in $form.getGroups("group1")) …
                                        #end</code></td><td style="">遍历当前form中所有名为<code class="code">group1</code>的实例。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14182"><!--anchor d0e14182--></a>9.4.3.2. Group API</h4></div></div></div><div class="table"><a id="d0e14185"><!--anchor d0e14185--></a><p class="title"><strong>表 9.18. 有关Group的API</strong></p><div class="table-contents"><table summary="有关Group的API" cellpadding="10" style="border: none;"><colgroup><col width="58%" class="c1"/><col width="42%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">API用法</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#if ($group.valid) … #end</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前group是否验证为合法，或者未经过验证（即初始表单）</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#if ($group.validated) ... #end</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前group是否经过验证（初始表单为未经过验证的表单） </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">$group.field1</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">取得field1</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">#foreach ($field in $group.fields) ...
                                    #end</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">遍历当前group中所有的fields</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">$group.mapTo($bean)</code></td><td style="">将bean中的properties设置成group的初始值。
                                    该操作只对初始表单有效。如果bean为null则忽略该操作。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14228"><!--anchor d0e14228--></a>9.4.3.3. Field API</h4></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">创建一个HTML表单字段</span></dt><dd><div class="example"><a id="d0e14236"><!--anchor d0e14236--></a><p class="title"><strong>例 9.64. 创建一个HTML表单字段</strong></p><div class="example-contents"><pre class="programlisting">$field.displayName
<strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"text"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$field.key"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$!field.value"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>其中，<code class="code">displayName</code>来自于配置文件。将<code class="code">displayName</code>显示在页面中的好处是，确保页面与出错信息的措辞一致。</p></dd><dt><span class="term">判断验证合法性，并显示错误消息</span></dt><dd><div class="example"><a id="d0e14253"><!--anchor d0e14253--></a><p class="title"><strong>例 9.65. 判断验证合法性，并显示错误消息</strong></p><div class="example-contents"><pre class="programlisting">#if (!$field.valid)
  <strong class="hl-tag" style="color: #000096">&lt;div</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"error"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>$field.message<strong class="hl-tag" style="color: #000096">&lt;/div&gt;</strong>
#end</pre></div></div></dd><dt><span class="term">取得多值</span></dt><dd><div class="example"><a id="d0e14262"><!--anchor d0e14262--></a><p class="title"><strong>例 9.66. 取得多值</strong></p><div class="example-contents"><pre class="programlisting">#foreach ($value in $field.values) ... #end</pre></div></div></dd><dt><span class="term">创建checkbox和radiobox的默认值</span></dt><dd><div class="example"><a id="d0e14271"><!--anchor d0e14271--></a><p class="title"><strong>例 9.67. 创建checkbox和radiobox的默认值</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"$field.absentKey"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$value"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre><p>或者简化为：</p><pre class="programlisting">$field.getAbsentHiddenField($value)</pre></div></div><p>Checkbox和radiobox有一个特性，当用户没有选中它们时，它们是没有值的（就像不存在一样）。这点对于表单验证会带来不便。</p><p>表单服务支持一种特殊的<code class="code">absentKey</code>。通过它，可以为checkbox/radiobox设置默认值。这样，当用户没有选中任何checkbox或radiobox时，这个值就成为field的值。</p></dd><dt><span class="term">创建附件</span></dt><dd><p>Field可以带一个附件。附件是一个对象，被序列化保存在hidden字段中。在下一次请求的时候，附件可以被恢复成对象。通过附件，可以让应用程序在表单中携带一些附加信息。
                                    下页的代码会生成一个hidden字段，将<code class="code">$obj</code>序列化保存在其中： </p><div class="example"><a id="d0e14296"><!--anchor d0e14296--></a><p class="title"><strong>例 9.68. 创建附件</strong></p><div class="example-contents"><pre class="programlisting">$field.setAttachment($obj)
$field.attachmentHiddenField</pre><p>当你要取得它时，只要这样：</p><pre class="programlisting">#set ($obj = $field.attachment)</pre><p>判断是否有附件：</p><pre class="programlisting">#if ($field.hasAttachment()) … #end</pre><p>清除附件：</p><pre class="programlisting">$field.cleanAttachment()</pre></div></div></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14313"><!--anchor d0e14313--></a>9.4.4. Field keys的格式</h3></div></div></div><p>表单验证服务所生成的field key是这样的：“<code class="code">_fm.r._0.p</code>”。它是由几部分组成： </p><div class="table"><a id="d0e14321"><!--anchor d0e14321--></a><p class="title"><strong>表 9.19. 压缩格式的field key（以<code class="code">_fm.r._0.p</code>为例）的组成</strong></p><div class="table-contents"><table summary="压缩格式的field key（以_fm.r._0.p为例）的组成" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p><code class="code">_fm</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>固定的前缀。它是单词“form”的缩写。表单系统依此来识别该字段为需要验证的表单字段。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p><code class="code">r</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">被压缩的group名称。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p><code class="code">_0</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>代表group instance的唯一ID。<code class="code">_0</code>是默认的ID。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <p><code class="code">p</code></p>
                            </td><td style="">被压缩的field名称。</td></tr></tbody></table></div></div><p>在以上例子中，field keys被压缩了。压缩以后的field keys更短，但同时也比较难以阅读。由于在多数情况下，我们并不需要去理解field
                    keys的含义，所以这样做并没有问题。但有一种情况，我们需要对表单进行单元测试或者集成测试。这种压缩的格式会为测试带来一定困难。为此，表单服务提供了另一种非压缩的格式可供使用。非压缩的格式和压缩格式类似，只不过其group和field的名称是完整的。例如，非压缩版的“<code class="code">_fm.register._0.password</code>”和压缩版的<code class="code">_fm.r._0.p</code>是等效的。</p><div class="table"><a id="d0e14390"><!--anchor d0e14390--></a><p class="title"><strong>表 9.20. 非压缩格式的field key（以<code class="code">_fm.register._0.password</code>为例）的组成</strong></p><div class="table-contents"><table summary="非压缩格式的field key（以_fm.register._0.password为例）的组成" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p><code class="code">_fm</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>固定的前缀，是单词“form”的缩写。表单系统依此来识别该字段为需要验证的表单字段。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p><code class="code">register</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">完整的group名称。大小写不敏感，以下写法完全等效：<code class="code">register</code>、<code class="code">Register</code>、<code class="code">rEgiSter</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p><code class="code">_0</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>代表group instance的唯一ID。<code class="code">_0</code>是默认的ID。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <p><code class="code">password</code></p>
                            </td><td style="">完整的field名称。大小写不敏感，以下写法完全等效：<code class="code">password</code>、<code class="code">Password</code>、<code class="code">paSswoRd</code>。</td></tr></tbody></table></div></div><p>浏览器或单元测试的代码在提交表单数据时，可以混合使用压缩和非压缩的格式。但是在默认情况下，表单系统只会生成压缩格式的field
                keys。如果你希望表单系统生成非压缩的格式，你可以在配置文件中这样写：</p><div class="example"><a id="d0e14471"><!--anchor d0e14471--></a><p class="title"><strong>例 9.69. 让表单系统生成非压缩的格式的field keys</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form</strong> <span class="hl-attribute" style="color: #F5844C">fieldKeyFormat</span>=<span class="hl-value" style="color: #993300">"uncompressed"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.form.fieldKeyFormat"><!--anchor co.form.fieldKeyFormat--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.fieldKeyFormat"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>如果不指定，其默认值为<code class="code">compressed</code>。</p></td></tr></table></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>当表单系统被配置成<code class="code">fieldKeyFormat="uncompressed"</code>时，系统就<span class="emphasis"><em>不支持</em></span>压缩格式的field
                    keys了。</p><p>当表单系统被配置成<code class="code">fieldKeyFormat="compressed"</code>时，系统就<span class="emphasis"><em>同时支持</em></span>压缩格式和非压缩格式的field
                    keys。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14502"><!--anchor d0e14502--></a>9.4.5. 外部验证</h3></div></div></div><p>表单验证服务是被设计成供一个<span class="emphasis"><em>应用的内部</em></span>使用的服务。它所生成的压缩格式的field
                    key，例如“<code class="code">_fm.r._0.p</code>”，是不稳定的。它和配置文件中的group、field的名称、排列顺序有关，可能随着配置的变化而变化。即便是非压缩的格式，例如“<code class="code">_fm.register._0.password</code>”，也会因配置文件中group、field命名的改变而改变。如果需要让外界系统来提交并验证表单，最好提供一个相对稳定的接口。所以外界系统最好不要依赖于这些内部的field
                keys。</p><p>如果真的需要让外界系统来提交并验证表单，可以做一个screen来转发这个请求。Screen的代码像这个样子：</p><div class="example"><a id="d0e14518"><!--anchor d0e14518--></a><p class="title"><strong>例 9.70. 转发外部表单请求</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> RemoteRegister {
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute(ParameterParser params, Form form, Navigator nav) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        Group group = form.getGroup(<strong class="hl-string"><em style="color:navy">"register"</em></strong>); <a id="co.form.external.newgroup"><!--anchor co.form.external.newgroup--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

        group.init(); <a id="co.form.external.transfer"><!--anchor co.form.external.transfer--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        group.getField(<strong class="hl-string"><em style="color:navy">"userId"</em></strong>).setValue(params.getString(<strong class="hl-string"><em style="color:navy">"userId"</em></strong>)); <a id="co.form.external.transfer1"><!--anchor co.form.external.transfer1--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        group.getField(<strong class="hl-string"><em style="color:navy">"password"</em></strong>).setValue(params.getString(<strong class="hl-string"><em style="color:navy">"password"</em></strong>)); <a id="co.form.external.transfer2"><!--anchor co.form.external.transfer2--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        group.getField(<strong class="hl-string"><em style="color:navy">"passwordConfirm"</em></strong>).setValue(params.getString(<strong class="hl-string"><em style="color:navy">"password"</em></strong>)); <a id="co.form.external.transfer3"><!--anchor co.form.external.transfer3--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
        group.validate(); <a id="co.form.external.validate"><!--anchor co.form.external.validate--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>

        nav.forwardTo(<strong class="hl-string"><em style="color:navy">"register"</em></strong>, <strong class="hl-string"><em style="color:navy">"registerAction"</em></strong>, <strong class="hl-string"><em style="color:navy">"register"</em></strong>); <a id="co.form.external.forward"><!--anchor co.form.external.forward--></a><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span>
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.external.newgroup"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>创建register group的实例。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.external.transfer"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.form.external.transfer1"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> <a href="#co.form.external.transfer2"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> <a href="#co.form.external.transfer3"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将request parameters中的参数设置到form
                            group中。需要注意的是，request参数名和field名称不必相同。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.external.validate"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>验证表单。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.form.external.forward"><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>内部重定向到register页面，并指明action参数和actionEvent参数（分别是“<code class="code">registerAction</code>”和“<code class="code">register</code>”）。</p></td></tr></table></div><p>只需要访问下面的URL就可以实现从系统外部注册帐户的功能：</p><pre class="screen">http://localhost:8081/myapp/remote_register.do?userId=xxx&amp;password=yyy</pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14560"><!--anchor d0e14560--></a>9.5. 本章总结</h2></div></div></div><p>表单服务是一个比较复杂但也相当强大的服务。虽然目前它还不支持客户端验证和服务端异步验证功能，但下一步会加上这些功能。</p><p>表单服务最重要的设计思想是：将验证规则与页面以及业务逻辑完全分离，使验证规则的扩展和维护变得非常容易。</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="webx.practicing"><!--anchor webx.practicing--></a>部分 IV. Webx应用实作</h1></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="#webx.tutorial.simple">第 10 章 创建第一个Webx应用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14576">10.1. 准备工作</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14581">10.1.1. 安装JDK</a></span></dt><dt><span class="section"><a href="#d0e14588">10.1.2. 安装和配置maven</a></span></dt><dt><span class="section"><a href="#d0e14602">10.1.3. 安装集成开发环境</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14629">10.2. 创建应用</a></span></dt><dt><span class="section"><a href="#d0e14717">10.3. 运行应用</a></span></dt><dt><span class="section"><a href="#d0e14765">10.4. 提问和解答</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14768">10.4.1. 在生产环境的应用上，也会出现前述的“开发者首页”吗？</a></span></dt><dt><span class="section"><a href="#d0e14814">10.4.2. “开发模式”是什么意思？</a></span></dt><dt><span class="section"><a href="#d0e14821">10.4.3. 所生成的应用中包含了什么？</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#webx.logging">第 11 章 Webx日志系统的配置</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14851">11.1. 名词解释</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14854">11.1.1. 日志系统（Logging System）</a></span></dt><dt><span class="section"><a href="#d0e14918">11.1.2. 日志框架（Logging Framework）</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14968">11.2. 在Maven中组装日志系统</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15052">11.2.1. 在Maven中配置logback作为日志系统</a></span></dt><dt><span class="section"><a href="#d0e15139">11.2.2. 在Maven中配置log4j作为日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15173">11.3. 在WEB应用中配置日志系统</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15176">11.3.1. 设置WEB应用</a></span></dt><dt><span class="section"><a href="#d0e15419">11.3.2. 定制<code class="filename">/WEB-INF/logback.xml</code>（或<code class="filename">/WEB-INF/log4j.xml</code>）</a></span></dt><dt><span class="section"><a href="#d0e15674">11.3.3. 同时初始化多个日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15736">11.4. 常见错误及解决</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15739">11.4.1. 查错技巧</a></span></dt><dt><span class="section"><a href="#d0e15806">11.4.2. 异常信息：No log system exists</a></span></dt><dt><span class="section"><a href="#d0e15832">11.4.3. 异常信息：<code class="code">NoSuchMethodError</code>:
                    <code class="code">org.slf4j.MDC.getCopyOfContextMap()</code></a></span></dt><dt><span class="section"><a href="#d0e15858">11.4.4. <code class="code">STDERR</code>输出：Class path contains multiple SLF4J bindings</a></span></dt><dt><span class="section"><a href="#d0e15885">11.4.5. 看不到日志输出</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15985">11.5. 本章总结</a></span></dt></dl></dd></dl></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.tutorial.simple"><!--anchor webx.tutorial.simple--></a>第 10 章 创建第一个Webx应用</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e14576">10.1. 准备工作</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14581">10.1.1. 安装JDK</a></span></dt><dt><span class="section"><a href="#d0e14588">10.1.2. 安装和配置maven</a></span></dt><dt><span class="section"><a href="#d0e14602">10.1.3. 安装集成开发环境</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14629">10.2. 创建应用</a></span></dt><dt><span class="section"><a href="#d0e14717">10.3. 运行应用</a></span></dt><dt><span class="section"><a href="#d0e14765">10.4. 提问和解答</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14768">10.4.1. 在生产环境的应用上，也会出现前述的“开发者首页”吗？</a></span></dt><dt><span class="section"><a href="#d0e14814">10.4.2. “开发模式”是什么意思？</a></span></dt><dt><span class="section"><a href="#d0e14821">10.4.3. 所生成的应用中包含了什么？</a></span></dt></dl></dd></dl></div><p>本章将帮助你快速创建一个可运行的Webx应用。你可以把它作为你的Webx新项目的开端。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14576"><!--anchor d0e14576--></a>10.1. 准备工作</h2></div></div></div><p>请耐心，准备工作会花掉你少许时间。但是磨刀不误砍柴工，做好准备工作将为你将来的开发节省大量时间。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14581"><!--anchor d0e14581--></a>10.1.1. 安装JDK</h3></div></div></div><p>Webx需要JDK 5.0以上的版本。请从这里下载并安装它：<a class="link" href="http://www.oracle.com/technetwork/java/javase/" target="_top">http://www.oracle.com/technetwork/java/javase/</a>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14588"><!--anchor d0e14588--></a>10.1.2. 安装和配置maven</h3></div></div></div><p>Webx需要maven 2或更高版本。请从这里下载并安装它：<a class="link" href="http://maven.apache.org/" target="_top">http://maven.apache.org/</a>。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>你不需要对maven进行特殊的配置，因为运行Webx应用所需要的所有包都存放在全世界共享的中心Maven仓库（Central Maven
                    Repository）中。Maven将从那里自动获取所有的jar包、源代码和javadoc。</p><p>你可以从这里查询到所有和Webx有关的发布包：<a class="link" href="http://search.maven.org/#search%7Cga%7C1%7Ccom.alibaba.citrus" target="_top">http://search.maven.org/#search%7Cga%7C1%7Ccom.alibaba.citrus</a>。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14602"><!--anchor d0e14602--></a>10.1.3. 安装集成开发环境</h3></div></div></div><p>很难想像不用集成开发环境（IDE）来帮助开发Java应用会变成怎样。</p><p>如果你使用Eclipse（从这里下载：<a class="link" href="http://www.eclipse.org/" target="_top">http://www.eclipse.org/</a>），建议安装如下插件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Maven eclipse插件：<a class="link" href="http://eclipse.org/m2e/" target="_top">http://eclipse.org/m2e/</a></p></li><li class="listitem"><p>Git eclipse插件：<a class="link" href="http://eclipse.org/egit/" target="_top">http://eclipse.org/egit/</a></p></li><li class="listitem"><p>SpringExt eclipse插件：<a class="link" href="http://openwebx.org/updatesite/" target="_top">http://openwebx.org/updatesite/</a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>关于SpringExt eclipse插件，请参阅更详细的说明：<a class="xref" href="#tool.plugin.springext.eclipse" title="12.3. Eclipse插件">第 12.3 节 “Eclipse插件”</a>。</p></td></tr></table></div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14629"><!--anchor d0e14629--></a>10.2. 创建应用</h2></div></div></div><p>请打开命令行工具（Windows <span class="command"><strong>cmd</strong></span>或Unix/Linux
            <span class="command"><strong>bash</strong></span>），输入如下命令：</p><div class="example"><a id="d0e14640"><!--anchor d0e14640--></a><p class="title"><strong>例 10.1. 从archetype创建Webx应用</strong></p><div class="example-contents"><pre class="programlisting">mvn archetype:generate \
 -DgroupId=com.alibaba.webx \<a id="co.firstapp.archetype.groupId"><!--anchor co.firstapp.archetype.groupId--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
 -DartifactId=tutorial1 \<a id="co.firstapp.archetype.artifactId"><!--anchor co.firstapp.archetype.artifactId--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
 -Dversion=1.0-SNAPSHOT \<a id="co.firstapp.archetype.version"><!--anchor co.firstapp.archetype.version--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
 -Dpackage=com.alibaba.webx.tutorial1 \<a id="co.firstapp.archetype.package"><!--anchor co.firstapp.archetype.package--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
 -DarchetypeArtifactId=archetype-webx-quickstart \
 -DarchetypeGroupId=com.alibaba.citrus.sample \
 -DarchetypeVersion=1.8 \
 -DinteractiveMode=false</pre><p>由于Windows下不支持命令换行，请改用<span class="emphasis"><em>非换行版</em></span>：</p><pre class="programlisting">mvn archetype:generate -DgroupId=com.alibaba.webx -DartifactId=tutorial1 -Dversion=1.0-SNAPSHOT -Dpackage=com.alibaba.webx.tutorial1 -DarchetypeArtifactId=archetype-webx-quickstart -DarchetypeGroupId=com.alibaba.citrus.sample -DarchetypeVersion=1.8 -DinteractiveMode=false</pre><p>命令执行完后，你会看见一个新目录：<code class="code">tutorial1</code>。它就是我们刚刚创建的新项目。项目的各项参数如下所示：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.firstapp.archetype.groupId"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>项目组（<code class="code">groupId</code>）：<code class="code">com.alibaba.webx</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.firstapp.archetype.artifactId"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>项目名称（<code class="code">artifactId</code>）：<code class="code">tutorial1</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.firstapp.archetype.version"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>项目版本（<code class="code">version</code>）：<code class="code">1.0-SNAPSHOT</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.firstapp.archetype.package"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>项目中Java类的包名（<code class="code">package</code>）：<code class="code">com.alibaba.webx.tutorial1</code>。</p></td></tr></table></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>你完全可以根据你的需要来调整上述命令中的参数，改用其它的<code class="code">groupId</code>、<code class="code">artifactId</code>、<code class="code">version</code>以及<code class="code">package</code>。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14717"><!--anchor d0e14717--></a>10.3. 运行应用</h2></div></div></div><p>进入刚创建的<code class="code">tutorial1</code>目录，在此目录下执行maven命令：</p><div class="example"><a id="d0e14725"><!--anchor d0e14725--></a><p class="title"><strong>例 10.2. 启动Jetty服务器</strong></p><div class="example-contents"><pre class="programlisting">mvn jetty:run</pre></div></div><p>这条命令会启动Jetty Server，默认的端口是<code class="code">8081</code>。请在浏览器地址栏输入地址，或直接点击这个链接：<a class="link" href="http://localhost:8081/" target="_top">http://localhost:8081/</a>。你应该可以看到类似下面的结果：</p><div class="figure"><a id="d0e14737"><!--anchor d0e14737--></a><div class="figure-contents"><div class="mediaobject"><img src="images/tut/firstapp-home.png" alt="Webx开发者首页"/></div></div><p class="title"><strong>图 10.1. Webx开发者首页</strong></p></div><p>这是一个“开发者首页”。它不是真正的应用程序首页，而是一个<span class="emphasis"><em>专为开发者准备的</em></span>首页。这个页面显示了一些诸如Webx版本、Java版本、OS类型、IP地址、内存等信息。</p><p>请点击页面顶部的菜单中的Application Home，</p><div class="informalfigure"><div class="mediaobject"><img src="images/tut/firstapp-apphome-link.png"/></div></div><p>这样就可以进入<span class="emphasis"><em>真正的应用程序首页</em></span>：</p><div class="figure"><a id="d0e14759"><!--anchor d0e14759--></a><div class="figure-contents"><div class="mediaobject"><img src="images/tut/firstapp-apphome.png" alt="Webx应用首页"/></div></div><p class="title"><strong>图 10.2. Webx应用首页</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14765"><!--anchor d0e14765--></a>10.4. 提问和解答</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14768"><!--anchor d0e14768--></a>10.4.1. 在生产环境的应用上，也会出现前述的“开发者首页”吗？</h3></div></div></div><p>不会的。</p><p>事实上，之所以刚才的运行会产生“开发者首页”，是因为在jetty启动时，定义了一个启动参数。请打开<code class="filename">pom.xml</code>看一下：</p><div class="example"><a id="d0e14778"><!--anchor d0e14778--></a><p class="title"><strong>例 10.3. 定义“开发者模式”的启动参数</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0"</span> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
            ...
            <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.mortbay.jetty<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jetty-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;webApp&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;contextPath&gt;</strong>/<strong class="hl-tag" style="color: #000096">&lt;/contextPath&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/webApp&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;stopKey&gt;</strong>webx<strong class="hl-tag" style="color: #000096">&lt;/stopKey&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;stopKey&gt;</strong>9999<strong class="hl-tag" style="color: #000096">&lt;/stopKey&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;connectors&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;connector</strong> <span class="hl-attribute" style="color: #F5844C">implementation</span>=<span class="hl-value" style="color: #993300">"org.eclipse.jetty.server.nio.SelectChannelConnector"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;port&gt;</strong>8081<strong class="hl-tag" style="color: #000096">&lt;/port&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;maxIdleTime&gt;</strong>60000<strong class="hl-tag" style="color: #000096">&lt;/maxIdleTime&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;/connector&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/connectors&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;requestLog</strong> <span class="hl-attribute" style="color: #F5844C">implementation</span>=<span class="hl-value" style="color: #993300">"org.eclipse.jetty.server.NCSARequestLog"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;filename&gt;</strong>target/access.log<strong class="hl-tag" style="color: #000096">&lt;/filename&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;retainDays&gt;</strong>90<strong class="hl-tag" style="color: #000096">&lt;/retainDays&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;append&gt;</strong>false<strong class="hl-tag" style="color: #000096">&lt;/append&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;extended&gt;</strong>false<strong class="hl-tag" style="color: #000096">&lt;/extended&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;logTimeZone&gt;</strong>GMT+8:00<strong class="hl-tag" style="color: #000096">&lt;/logTimeZone&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/requestLog&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;systemProperties&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;systemProperty&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;name&gt;</strong>productionMode<strong class="hl-tag" style="color: #000096">&lt;/name&gt;</strong> <a id="co.firstapp.pom.productionMode"><!--anchor co.firstapp.pom.productionMode--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
                            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>false<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;/systemProperty&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/systemProperties&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
            ...
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.firstapp.pom.productionMode"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>设定JVM启动参数：<code class="code">productionMode=false</code>。</p></td></tr></table></div></div></div><p>如果不加特别设置，系统的默认状态是“生产模式”，即<code class="code">productionMode</code>默认为<code class="code">true</code>。因此，生产环境的服务器总是运行在“生产模式”而不是“开发模式”下的。而“开发者首页”只会出现在“开发模式”下面。</p><p>你可以用下面的命令来覆盖<code class="filename">pom.xml</code>的设置：</p><div class="example"><a id="d0e14805"><!--anchor d0e14805--></a><p class="title"><strong>例 10.4. 在命令行上指定JVM参数</strong></p><div class="example-contents"><pre class="programlisting">mvn jetty:run -DproductionMode=true</pre></div></div><p>然后在浏览器地址栏输入地址，或直接点击这个链接：<a class="link" href="http://localhost:8081/" target="_top">http://localhost:8081/</a>，你将直接被带入应用首页，而不是“开发者首页”。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14814"><!--anchor d0e14814--></a>10.4.2. “开发模式”是什么意思？</h3></div></div></div><p>开发模式是为了方便应用开发，Webx所提供的额外功能。具体请见：<a class="xref" href="#webx.overview.framework.devmode" title="3.2.4. 开发模式工具">第 3.2.4 节 “开发模式工具”</a>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14821"><!--anchor d0e14821--></a>10.4.3. 所生成的应用中包含了什么？</h3></div></div></div><p>这个应用程序包含了几个Webx应用的常见元素：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>一个欢迎页面（index screen）</p></li><li class="listitem"><p>一个页面布局（layout）</p></li><li class="listitem"><p>一个表单验证（form）</p></li><li class="listitem"><p>一个action，用来处理用户提交的数据</p></li><li class="listitem"><p>Logback日志被打印在屏幕上</p></li></ul></div><p>
            </p></div></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.logging"><!--anchor webx.logging--></a>第 11 章 Webx日志系统的配置</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e14851">11.1. 名词解释</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14854">11.1.1. 日志系统（Logging System）</a></span></dt><dt><span class="section"><a href="#d0e14918">11.1.2. 日志框架（Logging Framework）</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14968">11.2. 在Maven中组装日志系统</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15052">11.2.1. 在Maven中配置logback作为日志系统</a></span></dt><dt><span class="section"><a href="#d0e15139">11.2.2. 在Maven中配置log4j作为日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15173">11.3. 在WEB应用中配置日志系统</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15176">11.3.1. 设置WEB应用</a></span></dt><dt><span class="section"><a href="#d0e15419">11.3.2. 定制<code class="filename">/WEB-INF/logback.xml</code>（或<code class="filename">/WEB-INF/log4j.xml</code>）</a></span></dt><dt><span class="section"><a href="#d0e15674">11.3.3. 同时初始化多个日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15736">11.4. 常见错误及解决</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15739">11.4.1. 查错技巧</a></span></dt><dt><span class="section"><a href="#d0e15806">11.4.2. 异常信息：No log system exists</a></span></dt><dt><span class="section"><a href="#d0e15832">11.4.3. 异常信息：<code class="code">NoSuchMethodError</code>:
                    <code class="code">org.slf4j.MDC.getCopyOfContextMap()</code></a></span></dt><dt><span class="section"><a href="#d0e15858">11.4.4. <code class="code">STDERR</code>输出：Class path contains multiple SLF4J bindings</a></span></dt><dt><span class="section"><a href="#d0e15885">11.4.5. 看不到日志输出</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15985">11.5. 本章总结</a></span></dt></dl></div><p>日志系统是一个应用中必备的部分，提供了查看错误信息、了解系统状态的最直接手段。</p><p>本章介绍了基于Webx框架的应用如何配置、使用日志系统的方法。 </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14851"><!--anchor d0e14851--></a>11.1. 名词解释</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14854"><!--anchor d0e14854--></a>11.1.1. 日志系统（Logging System）</h3></div></div></div><div class="table"><a id="d0e14857"><!--anchor d0e14857--></a><p class="title"><strong>表 11.1. 日志系统</strong></p><div class="table-contents"><table summary="日志系统" cellpadding="10" style="border: none;"><colgroup><col width="28%" class="c1"/><col width="72%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Log4j</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p><a class="link" href="http://logging.apache.org/log4j/" target="_top">http://logging.apache.org/log4j/</a></p>
                                <p>较早出现的比较成功的日志系统是Log4j。</p>
                                <p>Log4j开创的日志系统模型（Logger/Appender/Level）行之有效，并一直延用至今。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">JUL（<code class="code">java.util.logging.*</code>）</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p><a class="link" href="http://download.oracle.com/javase/6/docs/technotes/guides/logging/overview.html" target="_top">http://download.oracle.com/javase/6/docs/technotes/guides/logging/overview.html</a></p>
                                <p>JDK1.4是第一个自带日志系统的JDK，简称（JUL）。</p>
                                <p>JUL并没有明显的优势来战胜Log4j，反而造成了标准的混乱 —— 采用不同日志系统的应用程序无法和谐共存。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Logback</td><td style="">
                                <p><a class="link" href="http://logback.qos.ch/" target="_top">http://logback.qos.ch/</a></p>
                                <p>是较新的日志系统。</p>
                                <p>它是Log4j的作者吸取多年的经验教训以后重新做出的一套系统。它的使用更方便，功能更强，而且性能也更高。</p>
                                <p>Logback不能单独使用，必须配合日志框架SLF4J来使用。</p>
                            </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14918"><!--anchor d0e14918--></a>11.1.2. 日志框架（Logging Framework）</h3></div></div></div><p>JUL诞生以后，为了克服多种日志系统并存所带来的混乱，就出现了“日志框架”。日志框架本身不提供记录日志的功能，它只提供了日志调用的接口。日志框架依赖于实际的日志系统如Log4j或JUL来产生真实的日志。</p><p>使用日志框架的好处是：应用的部署者可以决定使用哪一种日志系统（Log4j还是JUL），或者在多种日志系统之间切换，而不需要更改应用的代码。</p><div class="table"><a id="d0e14925"><!--anchor d0e14925--></a><p class="title"><strong>表 11.2. 日志框架</strong></p><div class="table-contents"><table summary="日志框架" cellpadding="10" style="border: none;"><colgroup><col width="28%" class="c1"/><col width="72%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">JCL（Jakarta Commons Logging）</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p><a class="link" href="http://commons.apache.org/logging/" target="_top">http://commons.apache.org/logging/</a></p>
                                <p>这是目前最流行的一个日志框架，由Apache Jakarta社区提供。</p>
                                <p>Spring框架、许多老应用都依赖于JCL。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">SLF4J</td><td style="">
                                <p><a class="link" href="http://www.slf4j.org/" target="_top">http://www.slf4j.org/</a></p>
                                <p>这是一个最新的日志框架，由Log4j的作者推出。</p>
                                <p>SLF4J提供了新的API，特别用来配合Logback的新功能。但SLF4J同样兼容Log4j。</p>
                            </td></tr></tbody></table></div></div><p>由于Log4j原作者的感召力，SLF4J和Logback很快就流行起来。Webx的新版本也决定使用SLF4J作为其日志框架；并推荐Logback作为日志系统，但同时支持Log4J。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e14968"><!--anchor d0e14968--></a>11.2. 在Maven中组装日志系统</h2></div></div></div><p>要在应用中使用日志系统，必须把正确的jar包组装起来。本章假设你的应用是用maven构建的。</p><div class="figure"><a id="d0e14973"><!--anchor d0e14973--></a><div class="figure-contents"><div class="mediaobject"><img src="images/log/log-components.png" alt="日志系统的组成"/></div></div><p class="title"><strong>图 11.1. 日志系统的组成</strong></p></div><p>如图所示，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>由于JCL-over-SLF4J和原来的JCL具有完全相同的API，因此两者是不能共存的。</p></li><li class="listitem"><p>Logback和slf4j-log4j12也不能并存，否则SLF4J会迷惑并产生不确定的结果。</p></li></ul></div><p>
        </p><p>组装完整的日志系统将涉及如下部件：</p><div class="table"><a id="d0e14991"><!--anchor d0e14991--></a><p class="title"><strong>表 11.3. 日志系统的组成</strong></p><div class="table-contents"><table summary="日志系统的组成" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c1"/><col width="20%" class="c2"/><col width="60%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">类别</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">组件名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2">日志框架</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">SLF4J</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>Webx框架以及所有新应用，直接依赖于SLF4J。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">JCL</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>Spring框架、许多以前的老应用，都使用JCL来输出日志。</p>
                            <p>好在SLF4J提供了一个“桥接”包：JCL-over-SLF4J，它重写了JCL的API，并将所有日志输出转向SLF4J。这样就避免了两套日志框架并存的问题。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " rowspan="2">日志系统</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Logback</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>Webx推荐使用logback来取代log4j。</p>
                            <p>Logback可直接被SLF4J识别并使用。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Log4j</td><td style="">
                            <p>由于客观原因，有些系统暂时不能升级到Logback。</p>
                            <p>好在SLF4J仍然支持Log4j。Log4j需要一个适配器slf4j-log4j12才能被SLF4J识别并使用。</p>
                        </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15052"><!--anchor d0e15052--></a>11.2.1. 在Maven中配置logback作为日志系统</h3></div></div></div><div class="figure"><a id="d0e15055"><!--anchor d0e15055--></a><div class="figure-contents"><div class="mediaobject"><img src="images/log/logback.png" alt="以logback作为日志系统"/></div></div><p class="title"><strong>图 11.2. 以logback作为日志系统</strong></p></div><div class="example"><a id="webx.logging.logback.example.pom"><!--anchor webx.logging.logback.example.pom--></a><p class="title"><strong>例 11.1. 配置<code class="filename">pom.xml</code>以使用logback</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jcl-over-slf4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>ch.qos.logback<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>logback-classic<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependencyManagement&gt;</strong> <a id="co.log.logback.dep.man"><!--anchor co.log.logback.dep.man--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jcl-over-slf4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>ch.qos.logback<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>logback-classic<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.0.13<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>runtime<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong> <a id="co.log.logback.scope"><!--anchor co.log.logback.scope--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong> <a id="co.log.jcl.scope"><!--anchor co.log.jcl.scope--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencyManagement&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.logback.dep.man"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>把所依赖jar包的版本定义在<code class="code">&lt;dependencyManagement&gt;</code>中，而不是<code class="code">&lt;dependencies&gt;</code>中。因为前者可影响间接依赖，后者只能影响直接依赖。</p><p>如果你的项目指定了parent
                                    pom，那么<span class="emphasis"><em>建议把<code class="code">&lt;dependencyManagement&gt;</code>放在parent
                                pom中</em></span>，以便多个子项目共享配置。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.logback.scope"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将logback日志系统的依赖设定为<code class="code">&lt;scope&gt;runtime&lt;/scope&gt;</code>，因为应用程序永远不需要直接调用日志系统，而是通过SLF4J或JCL这样的日志框架来调用它们。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.jcl.scope"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>由于和jcl-over-slf4j存在冲突，因此JCL（commons-logging）是必须被排除的。由于maven目前缺少这样一个功能：它不能全局地排除一个jar包依赖，所以建议将commons-logging设置成<code class="code">&lt;scope&gt;provided&lt;/scope&gt;</code>，这样在最终的依赖关系中，将不会包含commons-logging包。</p></td></tr></table></div></div></div><p>将commons-logging设置成<code class="code">&lt;scope&gt;provided&lt;/scope&gt;</code>可以用来排除commons-logging，然而这样做有一个缺点
                —— 你无法从单元测试中将commons-logging排除。假如这个影响了你的单元测试的话，请使用另一种方案：</p><div class="example"><a id="d0e15110"><!--anchor d0e15110--></a><p class="title"><strong>例 11.2. 另一种排除commons-logging的方法</strong></p><div class="example-contents"><pre class="programlisting">        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>99.0-does-not-exist<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong> <a id="co.log.jcl.exclude"><!--anchor co.log.jcl.exclude--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.jcl.exclude"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>“<code class="code">&lt;version&gt;99.0-does-not-exist&lt;/version&gt;</code>”是一个特殊的版本，这个版本的jar包里空无一物。这样就可以“欺骗”maven使用这个空的jar包来取代commons-logging，达到排除它的目的。</p></td></tr></table></div></div></div><p>最后，你需要在项目文件夹下面，执行一下命令：“<code class="code">mvn
                dependency:tree</code>”，确保没有jar包直接或间接依赖了slf4j-log4j12。如果有的话，你可以用下面的配置来排除掉：</p><div class="example"><a id="d0e15129"><!--anchor d0e15129--></a><p class="title"><strong>例 11.3. 排除间接依赖的slf4j-log4j12</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependencyManagement&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>yourGroupId<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>yourArtifactId<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>yourVersion<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;exclusions&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;exclusion&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-log4j12<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/exclusion&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/exclusions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencyManagement&gt;</strong></pre></div></div><p>事实上，如果有其它的jar包依赖slf4j-log4j12，这本身就是有错误的。因为应用不应该直接依赖于这些包中的API ——
                    它们只应该依赖于日志框架API。任何应用都应该把下列和日志系统相关的依赖（如：slf4j-log4j12、logback-classic）设置成<code class="code">&lt;scope&gt;runtime&lt;/scope&gt;</code>的。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15139"><!--anchor d0e15139--></a>11.2.2. 在Maven中配置log4j作为日志系统</h3></div></div></div><div class="figure"><a id="d0e15142"><!--anchor d0e15142--></a><div class="figure-contents"><div class="mediaobject"><img src="images/log/log4j.png" alt="以log4j作为日志系统"/></div></div><p class="title"><strong>图 11.3. 以log4j作为日志系统</strong></p></div><div class="example"><a id="webx.logging.log4j.example.pom"><!--anchor webx.logging.log4j.example.pom--></a><p class="title"><strong>例 11.4. 配置<code class="filename">pom.xml</code>以使用log4j</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jcl-over-slf4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-log4j12<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependencyManagement&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jcl-over-slf4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-log4j12<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>runtime<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>log4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>log4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.2.17<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>runtime<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencyManagement&gt;</strong></pre></div></div><p>配置log4j的方法和关注要点和logback相似，请参见<a class="xref" href="#webx.logging.logback.example.pom" title="例 11.1. 配置pom.xml以使用logback">例 11.1 “配置<code class="filename">pom.xml</code>以使用logback”</a>。除此以外，你需要在项目文件夹下面，执行一下命令：“<code class="code">mvn
                dependency:tree</code>”，确保没有jar包间接依赖了logback-classic。如果有的话，你可以用下面的配置来排除掉：</p><div class="example"><a id="d0e15163"><!--anchor d0e15163--></a><p class="title"><strong>例 11.5. 排除间接依赖的logback-classic</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependencyManagement&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>yourGroupId<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>yourArtifactId<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>yourVersion<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;exclusions&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;exclusion&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>ch.qos.logback<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>logback-classic<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/exclusion&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/exclusions&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencyManagement&gt;</strong></pre></div></div><p>事实上，如果有其它的jar包依赖logback-classic，这本身就是有错误的。因为应用不应该直接依赖于这些包中的API ——
                    它们只应该依赖于日志框架API。任何应用都应该把下列和日志系统相关的依赖（如：slf4j-log4j12、logback-classic）设置成<code class="code">&lt;scope&gt;runtime&lt;/scope&gt;</code>的。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e15173"><!--anchor d0e15173--></a>11.3. 在WEB应用中配置日志系统</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15176"><!--anchor d0e15176--></a>11.3.1. 设置WEB应用</h3></div></div></div><div class="example"><a id="webx.logging.webxml"><!--anchor webx.logging.webxml--></a><p class="title"><strong>例 11.6. 设置<code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingRoot<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong> <a id="co.log.webxml.param.loggingRoot"><!--anchor co.log.webxml.param.loggingRoot--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>/tmp/logs<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingLevel<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong> <a id="co.log.webxml.param.loggingLevel"><!--anchor co.log.webxml.param.loggingLevel--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>INFO<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingCharset<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong> <a id="co.log.webxml.param.loggingCharset"><!--anchor co.log.webxml.param.loggingCharset--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>UTF-8<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>log...<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong> <a id="co.log.webxml.param.any"><!--anchor co.log.webxml.param.any--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>...<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong>com.alibaba.citrus.logconfig.LogConfiguratorListener<strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong> <a id="co.log.webxml.listener.conf"><!--anchor co.log.webxml.listener.conf--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>mdc<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-class&gt;</strong>com.alibaba.citrus.webx.servlet.SetLoggingContextFilter<strong class="hl-tag" style="color: #000096">&lt;/filter-class&gt;</strong> <a id="co.log.webxml.filter.mdc"><!--anchor co.log.webxml.filter.mdc--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;filter-mapping&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>mdc<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url-pattern&gt;</strong>/*<strong class="hl-tag" style="color: #000096">&lt;/url-pattern&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter-mapping&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.webxml.param.loggingRoot"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.log.webxml.param.loggingLevel"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.log.webxml.param.loggingCharset"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> <a href="#co.log.webxml.param.any"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定日志系统的参数。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.webxml.listener.conf"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>在WEB应用启动的时候，这个listener会被激活，并初始化日志系统。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.webxml.filter.mdc"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>将当前请求的信息放到日志系统的MDC中（Mapped Diagnostic Context）。</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15208"><!--anchor d0e15208--></a>11.3.1.1. 日志系统的参数</h4></div></div></div><p>可以在<code class="filename">/WEB-INF/web.xml</code>配置文件中集中定义日志系统的参数。</p><div class="table"><a id="d0e15216"><!--anchor d0e15216--></a><p class="title"><strong>表 11.4. 可配置的日志参数</strong></p><div class="table-contents"><table summary="可配置的日志参数" cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">loggingRoot</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">指定保存日志文件的根目录。如不指定，默认为：“<code class="code">${user.home}/logs</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">loggingLevel</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">指定日志级别，低于指定级别的日志将不被输出。如不指定，默认为“<code class="code">INFO</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">loggingCharset</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">指定用来生成日志文件的字符集编码。如不指定，默认为当前操作系统的默认字符集编码。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">log*</code></td><td style="">名称以“<code class="code">log</code>”开头的任意<code class="code">&lt;context-param&gt;</code>参数，都将被用作日志系统的参数。</td></tr></tbody></table></div></div><p>日志系统的参数可被替换到log4j或logback的配置中去，例如，在logback的配置文件中，你可以指定<code class="code">${loggingRoot}</code>来取得存放日志文件的根目录。</p><p>将日志参数配置在<code class="filename">/WEB-INF/web.xml</code>中，有如下优点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>使一套配置参数可同时应用于任意日志系统，包括logback和log4j。</p></li><li class="listitem"><p>便于管理。通常，我们可以利用maven的filtering机制，或者autoconfig插件来生成<code class="filename">/WEB-INF/web.xml</code>文件，以便定制上述参数。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15285"><!--anchor d0e15285--></a>11.3.1.2. 自动识别并初始化日志系统</h4></div></div></div><p><code class="code">LogConfiguratorListener</code>负责在系统启动的时候初始化日志系统。<code class="code">LogConfiguratorListener</code>会根据下面所列的条件，来自动识别出当前的日志系统，并正确地配置它：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>假如你在maven的<code class="filename">pom.xml</code>中指定log4j为日志系统，那么该listener就会试图用<code class="filename">/WEB-INF/log4j.xml</code>来初始化日志系统。</p></li><li class="listitem"><p>假如你在maven的<code class="filename">pom.xml</code>中指定logback为日志系统，那么该listener就会试图用<code class="filename">/WEB-INF/logback.xml</code>来初始化日志系统。</p></li><li class="listitem"><p>假如你在maven的<code class="filename">pom.xml</code>中未指定任何日志系统（不存在logback-classic或slf4j-log4j12），那么listener会报错并失败，整个WEB应用会退出，服务器报告应用启动失败。</p></li><li class="listitem"><p>假如<code class="filename">/WEB-INF/logback.xml</code>（或<code class="filename">/WEB-INF/log4j.xml</code>）不存在，那么listener会用默认的配置文件来初始化日志。默认的配置会：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>把<code class="code">WARN</code>级别以上的日志打印在<code class="code">STDERR</code>中，</p></li><li class="listitem"><p>把<code class="code">WARN</code>级别以下的日志打印在<code class="code">STDOUT</code>中。</p></li></ul></div><p>
                            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15349"><!--anchor d0e15349--></a>11.3.1.3. 初始化MDC</h4></div></div></div><p><code class="code">SetLoggingContextFilter</code>将当前请求的信息放到日志系统的MDC中（Mapped Diagnostic
                    Context）。这样，日志系统就可以打印出诸如下面所示的日志信息：</p><div class="example"><a id="d0e15356"><!--anchor d0e15356--></a><p class="title"><strong>例 11.7. 利用MDC输出的日志</strong></p><div class="example-contents"><pre class="screen">30377 [2010-06-02 15:24:29] - GET<a id="co.log.mdc.method"><!--anchor co.log.mdc.method--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> /wrongpage.htm<a id="co.log.mdc.uri"><!--anchor co.log.mdc.uri--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> [ip=127.0.0.1<a id="co.log.mdc.ip"><!--anchor co.log.mdc.ip--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>, ref=http://localhost:8081/index<a id="co.log.mdc.ref"><!--anchor co.log.mdc.ref--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>, ua=Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; zh-CN; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3<a id="co.log.mdc.agent"><!--anchor co.log.mdc.agent--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>, sid=scnd32ei11a7<a id="co.log.mdc.sid"><!--anchor co.log.mdc.sid--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>] ……</pre><div class="calloutlist"><p>这段日志信息中包含了如下信息：</p><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.mdc.method"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>用户请求的类型：<code class="code">GET</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.mdc.uri"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>请求的URI：<code class="code">/wrongpage.htm</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.mdc.ip"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>用户IP：<code class="code">127.0.0.1</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.mdc.ref"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>上一个页面的链接referrer：<code class="code">http://localhost:8081/index</code></p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.mdc.agent"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>用户的浏览器：Mac版的mozilla浏览器。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.mdc.sid"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Session ID：<code class="code">scnd32ei11a7</code>。</p></td></tr></table></div></div></div><p>用户客户端的详细信息，对于发现和追踪错误非常有帮助。</p><p><span class="emphasis"><em><code class="code">SetLoggingContextFilter</code>是一个可选的filter</em></span> ——
                        即使没有它，Webx的<code class="code">&lt;setLoggingContext /&gt;</code>
                    valve也会做同样的事情。但是把这些信息放在filter中，有利于及早记录用户的信息。 </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15419"><!--anchor d0e15419--></a>11.3.2. 定制<code class="filename">/WEB-INF/logback.xml</code>（或<code class="filename">/WEB-INF/log4j.xml</code>）</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15428"><!--anchor d0e15428--></a>11.3.2.1. 可用的参数</h4></div></div></div><p>在日志配置文件中，你可以使用以下参数：</p><div class="table"><a id="d0e15433"><!--anchor d0e15433--></a><p class="title"><strong>表 11.5. 日志配置文件中可用的参数</strong></p><div class="table-contents"><table summary="日志配置文件中可用的参数" cellpadding="10" style="border: none;"><colgroup><col width="40%" class="c1"/><col width="60%" class="c2"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">在<code class="filename">/WEB-INF/web.xml</code>中定义的所有日志参数</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${loggingRoot}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表保存日志文件的根目录。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${loggingCharset}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表用来生成日志文件的字符集编码。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${loggingLevel}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表日志级别，低于指定级别的日志将不被输出。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">${log*}</code></td><td style="">自定义参数，其中“<code class="code">*</code>”代表任意名称。</td></tr></tbody></table><table summary="日志配置文件中可用的参数" cellpadding="10" style="border: none;"><colgroup><col width="40%" class="c1"/><col width="60%" class="c2"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2">由系统自动取得的参数</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">${loggingHost}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">代表当前的服务器名称</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">${loggingAddress}</code></td><td style="">代表当前的服务器IP地址</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15494"><!--anchor d0e15494--></a>11.3.2.2. 可用的MDC参数</h4></div></div></div><p>在appender pattern中，你可以使用以下MDC参数：</p><div class="table"><a id="d0e15499"><!--anchor d0e15499--></a><p class="title"><strong>表 11.6. 日志配置文件中可用的MDC参数</strong></p><div class="table-contents"><table summary="日志配置文件中可用的MDC参数" cellpadding="10" style="border: none;"><colgroup><col width="38%" class="c1"/><col width="62%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{productionMode}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">系统运行的模式。如果系统以开发模式运行，将会显示<code class="code">Development Mode</code>；否则将会显示<code class="code">Production Mode</code>。在生产环境中启动开发模式会引起严重的性能和安全问题。将系统运行的模式打印在日志中，可以作为一种提醒。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{method}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">请求类型，如：<code class="code">GET</code>或<code class="code">POST</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{requestURL}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">完整的URL，如：<code class="code">http://localhost/test</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{requestURLWithQueryString}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">完整的URL，以及query
                                        string，如：<code class="code">http://localhost/test?id=1</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{requestURI}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">不包括host信息的URI，如：<code class="code">/test</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{requestURIWithQueryString}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">不包括host信息的URI，以及query
                                    string，如：<code class="code">/test?id=1</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{queryString}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">URL参数，如：<code class="code">id=1</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{remoteAddr}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">客户端地址</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{remoteHost}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">客户端域名</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{userAgent}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">客户端浏览器信息</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{referrer}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">上一个页面的URL</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{cookies}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">所有cookies的名称，如：<code class="code">[cookie1, cookie2]</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">%X{cookie.*}</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">特定cookie的值，如：<code class="code">%X{cookie.JSESSIONID}</code>，将显示当前session的ID</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">%X{*}</code></td><td style="">其它由应用程序或框架置入MDC的参数</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15622"><!--anchor d0e15622--></a>11.3.2.3. Logback配置示例</h4></div></div></div><div class="example"><a id="d0e15625"><!--anchor d0e15625--></a><p class="title"><strong>例 11.8. Logback配置示例（<code class="filename">/WEB-INF/logback.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;configuration</strong> <span class="hl-attribute" style="color: #F5844C">debug</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"STDOUT"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"ch.qos.logback.core.ConsoleAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;target&gt;</strong>System.out<strong class="hl-tag" style="color: #000096">&lt;/target&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;encoding&gt;</strong>${loggingCharset}<strong class="hl-tag" style="color: #000096">&lt;/encoding&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"ch.qos.logback.classic.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;pattern&gt;</strong><strong class="hl-tag" style="color: #000096">&lt;![CDATA[</strong>
%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n
            <strong class="hl-tag" style="color: #000096">]]&gt;</strong><strong class="hl-tag" style="color: #000096">&lt;/pattern&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.logconfig.logback.LevelRangeFilter"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;levelMax&gt;</strong>INFO<strong class="hl-tag" style="color: #000096">&lt;/levelMax&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"STDERR"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"ch.qos.logback.core.ConsoleAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;target&gt;</strong>System.err<strong class="hl-tag" style="color: #000096">&lt;/target&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;encoding&gt;</strong>${loggingCharset}<strong class="hl-tag" style="color: #000096">&lt;/encoding&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"ch.qos.logback.classic.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;pattern&gt;</strong><strong class="hl-tag" style="color: #000096">&lt;![CDATA[</strong>
%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n
            <strong class="hl-tag" style="color: #000096">]]&gt;</strong><strong class="hl-tag" style="color: #000096">&lt;/pattern&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.logconfig.logback.LevelRangeFilter"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;levelMin&gt;</strong>WARN<strong class="hl-tag" style="color: #000096">&lt;/levelMin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"PROJECT"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"ch.qos.logback.core.FileAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;file&gt;</strong>${loggingRoot}/${localHost}/petstore.log<strong class="hl-tag" style="color: #000096">&lt;/file&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;encoding&gt;</strong>${loggingCharset}<strong class="hl-tag" style="color: #000096">&lt;/encoding&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;append&gt;</strong>false<strong class="hl-tag" style="color: #000096">&lt;/append&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"ch.qos.logback.classic.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;pattern&gt;</strong><strong class="hl-tag" style="color: #000096">&lt;![CDATA[</strong>
%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n
            <strong class="hl-tag" style="color: #000096">]]&gt;</strong><strong class="hl-tag" style="color: #000096">&lt;/pattern&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;root&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;level</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingLevel}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"STDERR"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"STDOUT"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"PROJECT"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/root&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong></pre></div></div><p>更详细配置方法请参考logback官方文档：<a class="link" href="http://logback.qos.ch/manual/configuration.html" target="_top">http://logback.qos.ch/manual/configuration.html</a>。</p><p>请特别留意示例中参数的写法，如“<code class="code">${loggingRoot}</code>”；以及appender
                        pattern中MDC参数的的写法，如：“<code class="code">%X{method}</code>”、“<code class="code">%X{requestURIWithQueryString}</code>”等。
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e15648"><!--anchor d0e15648--></a>11.3.2.4. Log4j配置示例</h4></div></div></div><div class="example"><a id="d0e15651"><!--anchor d0e15651--></a><p class="title"><strong>例 11.9. Log4j配置示例（<code class="filename">/WEB-INF/log4j.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: blue">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;log4j:configuration</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:log4j</span>=<span class="hl-value" style="color: #993300">"http://jakarta.apache.org/log4j/"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"STDOUT"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.ConsoleAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"target"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"System.out"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"encoding"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingCharset}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"ConversionPattern"</span>
                <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n"</span><strong class="hl-tag" style="color: #000096">
             /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.varia.LevelRangeFilter"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"levelMax"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"INFO"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"STDERR"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.ConsoleAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"target"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"System.err"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"encoding"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingCharset}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"ConversionPattern"</span>
                <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n"</span><strong class="hl-tag" style="color: #000096">
             /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.varia.LevelRangeFilter"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"levelMin"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"WARN"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"PROJECT"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.FileAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"file"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingRoot}/${localHost}/myapp.log"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"encoding"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingCharset}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"append"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"ConversionPattern"</span>
                <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n"</span><strong class="hl-tag" style="color: #000096">
             /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;root&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;level</strong> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingLevel}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"STDOUT"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"STDERR"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"PROJECT"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/root&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/log4j:configuration&gt;</strong></pre></div></div><p>更详细配置方法请参考log4j官方文档：<a class="link" href="http://logging.apache.org/log4j/1.2/manual.html" target="_top">http://logging.apache.org/log4j/1.2/manual.html</a>。</p><p>请特别留意示例中参数的写法，如“<code class="code">${loggingRoot}</code>”；以及appender
                        pattern中MDC参数的的写法，如：“<code class="code">%X{method}</code>”、“<code class="code">%X{requestURIWithQueryString}</code>”等。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15674"><!--anchor d0e15674--></a>11.3.3. 同时初始化多个日志系统</h3></div></div></div><p>在某些遗留系统中，有些代码直接用到了Log4j API（例如Log4j
                Appender）。假如，我们仍然希望SLF4J以logback作为日志系统，但是保持这些老代码继续不变地使用log4j来记录日志。这样我们就需要同时初始化logback和log4j。</p><div class="example"><a id="d0e15679"><!--anchor d0e15679--></a><p class="title"><strong>例 11.10. 同时初始化Logback和Log4j</strong></p><div class="example-contents"><p>首先，你需要确保在<code class="filename">pom.xml</code>中，同时包含log4j和logback-classic这两个依赖，但是请<span class="emphasis"><em>一定不要包含slf4j-log4j12</em></span>这个包，因为它会和logback-classic起冲突。</p><p>下面的配置在<a class="xref" href="#webx.logging.logback.example.pom" title="例 11.1. 配置pom.xml以使用logback">例 11.1 “配置<code class="filename">pom.xml</code>以使用logback”</a>基础上，添加了log4j的依赖：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jcl-over-slf4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>ch.qos.logback<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>logback-classic<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong><span class="emphasis"><em>
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;/dependency&gt;</em></span>
<strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;dependencyManagement&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;dependencies&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>slf4j-api<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.slf4j<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>jcl-over-slf4j<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.7.5<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>commons-logging<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.1.3<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>provided<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>ch.qos.logback<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>logback-classic<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.0.13<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;scope&gt;</strong>runtime<strong class="hl-tag" style="color: #000096">&lt;/scope&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong><span class="emphasis"><em>
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.17&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;</em></span>
    <strong class="hl-tag" style="color: #000096">&lt;/dependencies&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependencyManagement&gt;</strong></pre><p>然后，你需要在<code class="filename">/WEB-INF/web.xml</code>中增加<code class="code">logSystem</code>参数。</p><p>下面的配置在<a class="xref" href="#webx.logging.webxml" title="例 11.6. 设置/WEB-INF/web.xml">例 11.6 “设置<code class="filename">/WEB-INF/web.xml</code>”</a>基础上，添加了所需的参数：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;web-app&gt;</strong>
<span class="emphasis"><em>
    &lt;context-param&gt;
        &lt;param-name&gt;logSystem&lt;/param-name&gt;
        &lt;param-value&gt;log4j, logback&lt;/param-value&gt;
    &lt;/context-param&gt;</em></span>
    ...

<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><p>以上这段<code class="filename">/WEB-INF/web.xml</code>的配置，告诉<code class="code">LogConfiguratorListener</code>同时初始化两个日志系统：log4j和logback。它们的配置文件分别是：<code class="filename">/WEB-INF/log4j.xml</code>和<code class="filename">/WEB-INF/logback.xml</code>。假如文件不存在也没关系，<code class="code">LogConfiguratorListener</code>会用系统默认的配置文件来初始化它们。</p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e15736"><!--anchor d0e15736--></a>11.4. 常见错误及解决</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15739"><!--anchor d0e15739--></a>11.4.1. 查错技巧</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.logging.init.info"><!--anchor webx.logging.init.info--></a>11.4.1.1. 检查提示信息</h4></div></div></div><p>分析错误前，<span class="emphasis"><em>先检查一下日志系统输出的提示信息，往往可以节省很多时间</em></span>。当<code class="code">LogConfiguratorListener</code>启动时，将会在<code class="code">STDERR</code>中打印信息，像下面这个样子：</p><div class="example"><a id="d0e15756"><!--anchor d0e15756--></a><p class="title"><strong>例 11.11. 日志初始化时的提示信息（<code class="code">STDERR</code>）</strong></p><div class="example-contents"><pre class="screen">2010-06-02 16:57:28.021:INFO:/:Initializing log4j system <a id="co.log.init.info.logsys"><!--anchor co.log.init.info.logsys--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
INFO: configuring "log4j" using file:/Users/…/WEB-INF/log4j.xml <a id="co.log.init.info.logconf"><!--anchor co.log.init.info.logconf--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
 - with property localAddress = 10.16.58.5 <a id="co.log.init.info.param1"><!--anchor co.log.init.info.param1--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
 - with property localHost = baobao-macbook-pro.local <a id="co.log.init.info.param2"><!--anchor co.log.init.info.param2--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
 - with property loggingCharset = UTF-8 <a id="co.log.init.info.param3"><!--anchor co.log.init.info.param3--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
 - with property loggingLevel = warn <a id="co.log.init.info.param4"><!--anchor co.log.init.info.param4--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
 - with property loggingRoot = /tmp/logs <a id="co.log.init.info.param5"><!--anchor co.log.init.info.param5--></a><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span></pre><div class="calloutlist"><p>通过这些信息，你可以检查如下内容：</p><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.init.info.logsys"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>是否选择了正确的日志系统，如：log4j或logback，抑或两样都有。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.init.info.logconf"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>是否选择了正确的日志配置文件，如：<code class="filename">/WEB-INF/log4j.xml</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.log.init.info.param1"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> <a href="#co.log.init.info.param2"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> <a href="#co.log.init.info.param3"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> <a href="#co.log.init.info.param4"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> <a href="#co.log.init.info.param5"><span class="calloutno"><img src="images/callouts/7.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>日志文件的参数，如根目录、字符集编码、日志级别等信息。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="webx.logging.jwhich"><!--anchor webx.logging.jwhich--></a>11.4.1.2. 查看class真实归属的jar包位置</h4></div></div></div><p>有时，因为各种原因导致应用找到了错误的jar包，从而产生神秘的错误。例如，你以为你使用了SLF4J的最新版，然而在服务器上存在一个SLF4J的老版本，并且其class
                    loader优先级比新版本更高。在这种情况下，应用会引用高优先级class loader中的老版本的class。这可能导致错误。</p><p>发现这类错误的有效的方法，是在应用程序的任意点设置断点（利用eclipse远程调试功能），当系统停留在断点处时，执行如下的java代码，查看其值：</p><div class="example"><a id="d0e15799"><!--anchor d0e15799--></a><p class="title"><strong>例 11.12. 查看class真实归属的jar包位置</strong></p><div class="example-contents"><pre class="programlisting">getClass().getClassLoader().getResource(getClass().getName().replace(<strong class="hl-string"><em style="color:navy">'.'</em></strong>, <strong class="hl-string"><em style="color:navy">'/'</em></strong>) + <strong class="hl-string"><em style="color:navy">".class"</em></strong>)</pre></div></div><p>另外，Webx开发模式所提供的详细出错页面中，也会列出stacktrace中每一个class的真实jar包位置。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15806"><!--anchor d0e15806--></a>11.4.2. 异常信息：No log system exists</h3></div></div></div><p>报这个错的原因可能是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>不存在slf4j-log4j12、logback-classic等任何一个日志系统的实现。</p></li><li class="listitem"><p>Slf4j的版本和日志系统的版本不匹配，例如，slf4j为1.4.3版，而slf4j-log4j12为1.7.5版。</p></li></ul></div><p>解决方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>用<code class="code">mvn dependency:tree</code>命令查看所有的依赖包，排除以上错误。</p></li><li class="listitem"><p>查看服务器环境（如jboss），查看是不是存在不正确版本的jar包，被优先于应用jar包而加载了。参见<a class="xref" href="#webx.logging.jwhich" title="11.4.1.2. 查看class真实归属的jar包位置">第 11.4.1.2 节 “查看class真实归属的jar包位置”</a>。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15832"><!--anchor d0e15832--></a>11.4.3. 异常信息：<code class="code">NoSuchMethodError</code>:
                    <code class="code">org.slf4j.MDC.getCopyOfContextMap()</code></h3></div></div></div><p>报这个错的原因是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>SLF4J的版本过老。MDC.getCopyOfContextMap()方法是从SLF4J
                            1.5.1时加入的，假如你的SLF4J是之前的版本，就会报错。</p></li></ul></div><p>解决方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>用<code class="code">mvn dependency:tree</code>查看所有的依赖包，排除以上错误。</p></li><li class="listitem"><p>查看服务器环境（如jboss），查看是不是存在不正确版本的jar包，被优先于应用jar包而加载了。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15858"><!--anchor d0e15858--></a>11.4.4. <code class="code">STDERR</code>输出：Class path contains multiple SLF4J bindings</h3></div></div></div><p>SLF4J在<code class="code">STDERR</code>报如下错误：</p><div class="example"><a id="d0e15868"><!--anchor d0e15868--></a><p class="title"><strong>例 11.13. Class path contains multiple SLF4J bindings</strong></p><div class="example-contents"><pre class="screen">SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/…/WEB-INF/lib/logback-classic-0.9.18.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/…/WEB-INF/lib/slf4j-log4j12-1.5.11.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</pre></div></div><p>报这个错的原因是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>classpath中存在多个日志系统，使SLF4J无所适从。</p></li></ul></div><p>解决方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>SLF4J已经列出了classpath中所有的日志系统的位置。根据这些信息，你可以调整应用的依赖，或者整理服务器的环境，使之只剩下一个日志系统。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e15885"><!--anchor d0e15885--></a>11.4.5. 看不到日志输出</h3></div></div></div><p>原因可能是日志的配置文件可能有错。</p><p>解决方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>首先，查看<code class="code">LogConfiguratorListener</code>输出到<code class="code">STDERR</code>中的信息（参见<a class="xref" href="#webx.logging.init.info" title="11.4.1.1. 检查提示信息">第 11.4.1.1 节 “检查提示信息”</a>），确定系统：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>选择了正确的日志系统；</p></li><li class="listitem"><p>选择了正确的配置文件；</p></li><li class="listitem"><p>设置了正确的参数（<code class="code">loggingRoot</code>、<code class="code">loggingLevel</code>等）。</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在JBOSS环境中，<code class="code">STDOUT</code>和<code class="code">STDERR</code>会被重定向到Log4j中，然后被输出到一个文件中，通常是<code class="filename">log/server.log</code>。你必须从这个日志文件中查看<code class="code">LogConfiguratorListener</code>的输出。</p></td></tr></table></div></li><li class="listitem"><p>假如以上信息均正确，查看日志配置文件<code class="filename">/WEB-INF/log4j.xml</code>或<code class="filename">/WEB-INF/logback.xml</code>，是否引用了正确的参数，例如：<code class="code">${loggingRoot}</code>、<code class="code">${loggingLevel}</code>等。</p></li><li class="listitem"><p>检查文件系统权限，确保应用有权限创建和修改日志文件。</p></li><li class="listitem"><p>假设你使用log4j作为日志系统，以jboss作为应用服务器。在JBOSS环境中，当log4j被初始化后，<code class="code">STDOUT</code>和<code class="code">STDERR</code>可能会被重新配置到不同的appender中。原先用来记录STDOUT和STDERR的日志文件<code class="filename">log/server.log</code>将不会再被使用。建议你设置<code class="filename">/WEB-INF/log4j.xml</code>，增加如下内容：</p><div class="example"><a id="d0e15968"><!--anchor d0e15968--></a><p class="title"><strong>例 11.14. 在log4j中配置jboss服务器日志</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;appender</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"JBOSS_APPENDER"</span> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.FileAppender"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"file"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingRootJboss}/server.log"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"encoding"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"${loggingCharset}"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"append"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;layout</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.apache.log4j.PatternLayout"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"ConversionPattern"</span>
            <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"%n%-4r [%d{yyyy-MM-dd HH:mm:ss}] %X{productionMode} - %X{method} %X{requestURIWithQueryString} [ip=%X{remoteAddr}, ref=%X{referrer}, ua=%X{userAgent}, sid=%X{cookie.JSESSIONID}]%n  %-5level %logger{35} - %m%n"</span><strong class="hl-tag" style="color: #000096">
         /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/layout&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/appender&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;logger</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"STDOUT"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"JBOSS_APPENDER"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/logger&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;logger</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"STDERR"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;appender-ref</strong> <span class="hl-attribute" style="color: #F5844C">ref</span>=<span class="hl-value" style="color: #993300">"JBOSS_APPENDER"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/logger&gt;</strong></pre><p>这里用到了一个新的变量：<code class="code">${loggingRootJboss}</code>，你需要把它定义在<code class="filename">/WEB-INF/web.xml</code>中。</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingRootJboss<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong>${jboss}/log<strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre></div></div><p>如果你使用logback作为日志系统，则不需要作如上配置。</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e15985"><!--anchor d0e15985--></a>11.5. 本章总结</h2></div></div></div><p><code class="code">LogConfiguratorListener</code>目前只提供了logback和log4j的支持，尽管支持一种新的日志系统是非常容易的，但现在看来，这两种日志系统已经足够我们使用了。</p><p><code class="code">LogConfiguratorListener</code>以SLF4J为基础。SLF4J还提供了更多的功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>除了log4j和logback以外，SLF4J还支持几种其它的日志系统；</p></li><li class="listitem"><p>除了jcl-over-slf4j以外，SLF4J还提供了几种对其它legacy日志系统的桥接功能。</p></li></ul></div><p>详情请见SLF4J的文档：<a class="link" href="http://www.slf4j.org/docs.html" target="_top">http://www.slf4j.org/docs.html</a>。</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="webx.tools"><!--anchor webx.tools--></a>部分 V. 辅助工具</h1></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="#tool.plugin.springext">第 12 章 安装和使用SpringExt插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16013">12.1. SpringExt插件有什么用？</a></span></dt><dt><span class="section"><a href="#tool.plugin.springext.maven">12.2. Maven插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16100">12.2.1. 在<code class="code">pom.xml</code>中定义插件</a></span></dt><dt><span class="section"><a href="#d0e16130">12.2.2. 启动schema服务器</a></span></dt><dt><span class="section"><a href="#d0e16157">12.2.3. 导出所有的schemas</a></span></dt><dt><span class="section"><a href="#d0e16170">12.2.4. Maven插件的可选参数</a></span></dt></dl></dd><dt><span class="section"><a href="#tool.plugin.springext.eclipse">12.3. Eclipse插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16378">12.3.1. 安装插件</a></span></dt><dt><span class="section"><a href="#d0e16435">12.3.2. 利用插件编辑Webx/SpringExt配置文件</a></span></dt><dt><span class="section"><a href="#d0e16756">12.3.3. 利用插件编辑SpringExt组件</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e16789">12.4. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tool.autoconfig">第 13 章 AutoConfig工具使用指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16798">13.1. 需求分析</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16845">13.1.1. 解决方案</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17089">13.2. AutoConfig的设计</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17094">13.2.1. 角色与职责</a></span></dt><dt><span class="section"><a href="#d0e17190">13.2.2. 分享二进制目标文件</a></span></dt><dt><span class="section"><a href="#d0e17218">13.2.3. 部署二进制目标文件</a></span></dt><dt><span class="section"><a href="#d0e17234">13.2.4. AutoConfig特性列表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17303">13.3. AutoConfig的使用 —— 开发者指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17306">13.3.1. 建立AutoConfig目录结构</a></span></dt><dt><span class="section"><a href="#d0e17446">13.3.2. 建立auto-config.xml描述文件</a></span></dt><dt><span class="section"><a href="#d0e17757">13.3.3. 建立模板文件</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17901">13.4. AutoConfig的使用 —— 部署者指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17913">13.4.1. 在命令行中使用AutoConfig</a></span></dt><dt><span class="section"><a href="#d0e18021">13.4.2. 在maven中使用AutoConfig</a></span></dt><dt><span class="section"><a href="#d0e18061">13.4.3. 运行并观察AutoConfig的结果</a></span></dt><dt><span class="section"><a href="#d0e18132">13.4.4. 共享properties文件</a></span></dt><dt><span class="section"><a href="#d0e18370">13.4.5. AutoConfig常用命令</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18622">13.5. 本章总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tool.autoexpand">第 14 章 AutoExpand工具使用指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18641">14.1. AutoExpand工具简介</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18646">14.1.1. Java、JavaEE打包的格式</a></span></dt><dt><span class="section"><a href="#d0e18704">14.1.2. 应用部署的方式</a></span></dt><dt><span class="section"><a href="#d0e18741">14.1.3. AutoExpand的用武之地</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18791">14.2. AutoExpand的使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18794">14.2.1. 取得AutoExpand</a></span></dt><dt><span class="section"><a href="#d0e18801">14.2.2. 执行AutoExpand</a></span></dt><dt><span class="section"><a href="#d0e18870">14.2.3. AutoExpand和AutoConfig的合作</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18884">14.3. AutoExpand的参数</a></span></dt><dt><span class="section"><a href="#d0e19001">14.4. 本章总结</a></span></dt></dl></dd></dl></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="tool.plugin.springext"><!--anchor tool.plugin.springext--></a>第 12 章 安装和使用SpringExt插件</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e16013">12.1. SpringExt插件有什么用？</a></span></dt><dt><span class="section"><a href="#tool.plugin.springext.maven">12.2. Maven插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16100">12.2.1. 在<code class="code">pom.xml</code>中定义插件</a></span></dt><dt><span class="section"><a href="#d0e16130">12.2.2. 启动schema服务器</a></span></dt><dt><span class="section"><a href="#d0e16157">12.2.3. 导出所有的schemas</a></span></dt><dt><span class="section"><a href="#d0e16170">12.2.4. Maven插件的可选参数</a></span></dt></dl></dd><dt><span class="section"><a href="#tool.plugin.springext.eclipse">12.3. Eclipse插件</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16378">12.3.1. 安装插件</a></span></dt><dt><span class="section"><a href="#d0e16435">12.3.2. 利用插件编辑Webx/SpringExt配置文件</a></span></dt><dt><span class="section"><a href="#d0e16756">12.3.3. 利用插件编辑SpringExt组件</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e16789">12.4. 本章总结</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e16013"><!--anchor d0e16013--></a>12.1. SpringExt插件有什么用？</h2></div></div></div><p>SpringExt扩展了Spring的schema机制，使得开发者可以借助schema来扩展框架的功能。然而使用schema来编写配置文件时，我们面临一个问题：XML编辑器到哪里去找到schema？</p><p>例如，我们在Eclipse中打开一个典型的Webx配置文件：</p><div class="example"><a id="example.schema.locations1"><!--anchor example.schema.locations1--></a><p class="title"><strong>例 12.1. 在XML中指定Schema Location</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:loaders</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/resource-loading/loaders"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
            </span><span class="emphasis"><em>http://localhost:8080/schema/services.xsd</em></span> <a id="co.schema.location.services1"><!--anchor co.schema.location.services1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        http://www.alibaba.com/schema/services/resource-loading/loaders
            <span class="emphasis"><em>http://localhost:8080/schema/services-resource-loading-loaders.xsd</em></span> <a id="co.schema.location.loaders1"><!--anchor co.schema.location.loaders1--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        http://www.springframework.org/schema/beans
            <span class="emphasis"><em>http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd</em></span> <a id="co.schema.location.beans1"><!--anchor co.schema.location.beans1--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    "&gt;
    ...
<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.schema.location.services1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.schema.location.loaders1"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.schema.location.beans1"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定schema的位置。</p></td></tr></table></div></div></div><p>一般Eclispe会用一个XML编辑器来打开这类文件，然后试着从<code class="code">schemaLocation</code>中取得所需要的schemas，并用它们来验证文件。然而，Webx/SpringExt的schema并不存在于网络上的任何一个地方，而是存在于jar包中，或是在内存中自动生成的。显然XML编辑器不能从这样的<code class="code">schemaLocation</code>中得到什么。</p><p>因此，当我们试图验证（validate）XML文件的时候，编辑器会警告：无法取得schema或DTD。当我们试图让Eclipse自动提示语法信息时，Eclipse会无所适从。如图所示。</p><div class="figure"><a id="d0e16054"><!--anchor d0e16054--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/no-plugin.png" alt="无法验证的XML配置文件"/></div></div><p class="title"><strong>图 12.1. 无法验证的XML配置文件</strong></p></div><p>SpringExt提供了两种插件，可用来解决这个问题：Maven插件，和Eclipse插件。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Maven插件</em></span> ——
                        你可以使用它，在<code class="code">localhost</code>本机上启动一个监听<code class="code">8080</code>端口的Schema
                    Server，通过它就可以访问到所有的schemas。</p><p>这也是为什么<a class="xref" href="#example.schema.locations1" title="例 12.1. 在XML中指定Schema Location">例 12.1 “在XML中指定Schema Location”</a>中，要把<code class="code">schemaLocation</code>指向<code class="code">localhost:8080</code>的原因。只有这样，才能让任何普通的XML编辑器不需要任何特殊的设置，就可以通过这个插件来读到正确的schemas。</p></li><li class="listitem"><p><span class="emphasis"><em>Eclipse插件</em></span> ——
                    通过它，XML编辑器可以直接取得所有schemas的内容。除此之外，Eclipse插件也提供了更多的便利功能，例如：自动引入或清除某个namespace/schema定义。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tool.plugin.springext.maven"><!--anchor tool.plugin.springext.maven--></a>12.2. Maven插件</h2></div></div></div><p>通过SpringExt Maven插件，你可以在<code class="code">localhost</code>本机上启动一个监听<code class="code">8080</code>端口的Schema
            Server，通过它就可以访问到所有的schemas。这种机制适合于任何一种支持schema验证的XML编辑器。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16100"><!--anchor d0e16100--></a>12.2.1. 在<code class="code">pom.xml</code>中定义插件</h3></div></div></div><p>在使用Maven插件之前，必须在要使用插件功能的项目的<code class="code">pom.xml</code>文件中作出定义。如果是多模块的项目（multi-modules），下面的内容必须定义在根项目（即pom项目）中。</p><div class="example"><a id="d0e16111"><!--anchor d0e16111--></a><p class="title"><strong>例 12.2. 在<code class="code">pom.xml</code>这定义SpringExt Maven插件</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;properties&gt;</strong>
        ...
        <strong class="hl-tag" style="color: #000096">&lt;springext-plugin-version&gt;</strong>1.2<strong class="hl-tag" style="color: #000096">&lt;/springext-plugin-version&gt;</strong> <a id="co.springext-maven-version.property"><!--anchor co.springext-maven-version.property--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/properties&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
            ...
            <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.alibaba.citrus.tool<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong> <a id="co.springext-maven-plugin"><!--anchor co.springext-maven-plugin--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>springext-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;pluginManagement&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
                ...
                <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.alibaba.citrus.tool<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>springext-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${springext-plugin-version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/pluginManagement&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.springext-maven-version.property"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>在maven properties中指定插件的版本号，方便以后升级。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.springext-maven-plugin"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>在项目中配置插件。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16130"><!--anchor d0e16130--></a>12.2.2. 启动schema服务器</h3></div></div></div><p>在项目的根目录下，执行以下命令：</p><pre class="screen"><span class="command"><strong>mvn springext:run</strong></span></pre><p>上述命令执行以后，打开浏览器，输入网址<code class="code">http://localhost:8080/schema</code>就可以看到类似下面的内容：</p><div class="figure"><a id="d0e16143"><!--anchor d0e16143--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/maven/schema-exporter.png" alt="用SpringExt maven插件罗列schemas"/></div></div><p class="title"><strong>图 12.2. 用SpringExt maven插件罗列schemas</strong></p></div><p>如果这时你重新打开刚才的XML配置文件（最好重启eclipse以清除缓存），就可以看到Eclipse已经能够弹出语法提示了。</p><div class="figure"><a id="d0e16151"><!--anchor d0e16151--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/maven/schema-gramma-assist.png" alt="启动schema服务器以后，可以看到语法提示"/></div></div><p class="title"><strong>图 12.3. 启动schema服务器以后，可以看到语法提示</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16157"><!--anchor d0e16157--></a>12.2.3. 导出所有的schemas</h3></div></div></div><p>在项目的根目录下，执行以下命令：</p><pre class="screen"><span class="command"><strong>mvn springext:export</strong></span></pre><p>上述命令执行以后，将生成一个<code class="code">target/schemas</code>文件夹，里面包含了所有的可用的schemas。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16170"><!--anchor d0e16170--></a>12.2.4. Maven插件的可选参数</h3></div></div></div><p>SpringExt Maven插件还包含了一系列可选的参数。</p><div class="table"><a id="d0e16175"><!--anchor d0e16175--></a><p class="title"><strong>表 12.1. SpringExt Maven插件的可选参数</strong></p><div class="table-contents"><table summary="SpringExt Maven插件的可选参数" cellpadding="10" style="border: none;"><colgroup><col width="16%" class="c1"/><col width="17%" class="c2"/><col width="16%" class="c3"/><col width="51%" class="c4"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">适用于命令</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">默认值</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">contextPath</code>
                            </th><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">mvn springext:run</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">/schema</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>指定Schema URL的路径：</p>
                                <p>
                                    <code class="code">http://localhost:8080</code>
                                    <span class="emphasis"><em>
                                        <code class="code">/contextPath</code>
                                    </em></span>
                                    <code class="code">/myschema.xsd</code>
                                </p>
                            </td></tr><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">port</code>
                            </th><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">mvn springext:run</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">8080</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>指定Schema URL的端口：</p>
                                <p>
                                    <code class="code">http://localhost</code>
                                    <span class="emphasis"><em>
                                        <code class="code">:8080</code>
                                    </em></span>
                                    <code class="code">/contextPath/myschema.xsd</code>
                                </p>
                            </td></tr><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">noTestClasspath</code>
                            </th><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <p>
                                    <code class="code">mvn springext:run</code>
                                </p>
                                <p>
                                    <code class="code">mvn springext:export</code>
                                </p>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">false</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>是否在单元测试的classpath中寻找schemas？</p>
                            </td></tr><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">destdir</code>
                            </th><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">mvn springext:export</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">target/schemas</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>导出schemas到指定的文件夹。</p>
                            </td></tr><tr><th style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">uriPrefix</code>
                            </th><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">mvn springext:export</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">导出schemas的目标文件夹的绝对路径</td><td style="">
                                <p>在导入的schemas中，如果有引用其它的schema的地方，使用指定的URL前缀。</p>
                                <p>
                                    <span class="emphasis"><em>
                                        <code class="code">http://localhost:8080/schema</code>
                                    </em></span>
                                    <code class="code">/myschema.xsd</code>
                                </p>
                            </td></tr></tbody></table></div></div><p>这些参数可以通过两种方法来设定。以参数<code class="code">port</code>为例：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>通过<code class="code">pom.xml</code>来设定</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
            ...
            <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.alibaba.citrus.tool<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>springext-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
                    <span class="emphasis"><em>&lt;port&gt;9090&lt;/port&gt;</em></span>
                <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
        ...
    <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre></li><li class="listitem"><p>或者，通过命令行来设定</p><pre class="screen"><span class="command"><strong>mvn springext:run </strong></span><span class="emphasis"><em><code class="code">-Dport=9090</code></em></span></pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tool.plugin.springext.eclipse"><!--anchor tool.plugin.springext.eclipse--></a>12.3. Eclipse插件</h2></div></div></div><p>如果你用Eclipse来作为你的应用开发的工具，那么SpringExt Eclipse插件能够为你提供最方便、更强大的功能。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16378"><!--anchor d0e16378--></a>12.3.1. 安装插件</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>下载并安装Eclipse，建议安装最新版的Eclipse：<a class="link" href="http://www.eclipse.org/" target="_top">http://www.eclipse.org/</a>。</p></li><li class="listitem"><p>运行Eclipse，从Help菜单中，打开Eclipse Marketplace。 </p><div class="figure"><a id="d0e16390"><!--anchor d0e16390--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/install-1-menu.png" alt="打开Eclipse Marketplace"/></div></div><p class="title"><strong>图 12.4. 打开Eclipse Marketplace</strong></p></div></li><li class="listitem"><p>搜索关键词<code class="code">webx</code>，找到Webx/SpringExt Plugin，点击Install按钮。</p><div class="figure"><a id="d0e16402"><!--anchor d0e16402--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/install-2-search.png" alt="搜索并找到Webx/SpringExt Plugin"/></div></div><p class="title"><strong>图 12.5. 搜索并找到Webx/SpringExt Plugin</strong></p></div></li><li class="listitem"><p>开始安装插件。</p><div class="figure"><a id="d0e16411"><!--anchor d0e16411--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/install-3-install.png" alt="勾选要安装的features"/></div></div><p class="title"><strong>图 12.6. 勾选要安装的features</strong></p></div><div class="figure"><a id="d0e16417"><!--anchor d0e16417--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/install-4-license.png" alt="确认License授权"/></div></div><p class="title"><strong>图 12.7. 确认License授权</strong></p></div><div class="figure"><a id="d0e16423"><!--anchor d0e16423--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/install-5-sign.png" alt="忽略关于签名的安全警告，选择OK继续安装"/></div></div><p class="title"><strong>图 12.8. 忽略关于签名的安全警告，选择OK继续安装</strong></p></div><div class="figure"><a id="d0e16429"><!--anchor d0e16429--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/install-6-restart.png" alt="重启Eclipse"/></div></div><p class="title"><strong>图 12.9. 重启Eclipse</strong></p></div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16435"><!--anchor d0e16435--></a>12.3.2. 利用插件编辑Webx/SpringExt配置文件</h3></div></div></div><p>安装完成Eclipse插件以后，然后打开任何一个Webx/SpringExt的配置文件。你会发现，打开的是一个稍微有点不同的XML编辑器。</p><div class="figure"><a id="d0e16440"><!--anchor d0e16440--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/editor-ui.png" alt="SpringExt配置文件编辑器的界面"/></div></div><p class="title"><strong>图 12.10. SpringExt配置文件编辑器的界面</strong></p></div><p>假如你看到的并不是类似这样的编辑器界面，那么很有可能是因为你的Eclipse中还安装了其它的插件（例如：你安装了Spring
                IDE、或者OxygenXML编辑器等），导致该文件被其它的编辑器打开了。如果是这样，请尝试用鼠标右键点击文件，然后选择Open With &gt; SpringExt
                Configuration File Editor。如图所示。</p><div class="figure"><a id="d0e16448"><!--anchor d0e16448--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/open-with.png" alt="用Open With菜单打开文件"/></div></div><p class="title"><strong>图 12.11. 用Open With菜单打开文件</strong></p></div><p>在这个编辑器中，你可以做如下的事情：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>验证配置文件是否合乎schema语法 —— 按鼠标右键，选择validate。</p></li><li class="listitem"><p>自动语法提示 ——
                        在键入时，eclipse会自动弹出语法提示；或者，你也可以通过eclipse的快捷键来激活语法提示（完全类似于编辑Java代码）。</p></li><li class="listitem"><p>引入Namespaces —— 在键入时，eclipse会提示你引入可用的namespaces。每个namespace代表一个SpringExt
                        Configuration
                            Point或Spring的一个可扩展功能。引入一个namespace，就会创建一个<code class="code">xmlns</code>条目，以及相应的<code class="code">schemaLocation</code>。</p><div class="figure"><a id="d0e16472"><!--anchor d0e16472--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/import-services-ns.png" alt="在&lt;beans:beans&gt;中引入services namespace"/></div></div><p class="title"><strong>图 12.12. 在&lt;beans:beans&gt;中引入services namespace</strong></p></div><div class="figure"><a id="d0e16478"><!--anchor d0e16478--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/import-valves-ns.png" alt="在&lt;services:pipeline&gt;中引入valves namespace"/></div></div><p class="title"><strong>图 12.13. 在&lt;services:pipeline&gt;中引入valves namespace</strong></p></div></li><li class="listitem"><p>按住CTRL键（Mac下为CMD键），将鼠标移到任何一个链接上，或者namespace前缀及对应的标签上，都是可以点击查看的。</p><div class="table"><a id="d0e16487"><!--anchor d0e16487--></a><p class="title"><strong>表 12.2. 可作为超链接打开的内容</strong></p><div class="table-contents"><table summary="可作为超链接打开的内容" cellpadding="10" style="border: none;"><colgroup><col width="14%" class="c1"/><col width="28%" class="c2"/><col width="58%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">分类</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">可点击的内容</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="3">SpringExt Configuration Point</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <code class="code">http://www.alibaba.com/schema/services</code>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个Namespace URI，它代表一个SpringExt的扩展点（Configuration
                                            Point）。</p>
                                        <p>点击它就可以打开相应Configuration Point的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <code class="code">http://localhost:8080/schema/services.xsd</code>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个Schema
                                            Location的链接，它代表一个SpringExt的扩展点（Configuration
                                            Point）的schema。</p>
                                        <p>点击它就可以打开相应Configuration Point的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <span class="emphasis"><em>
                                            <code class="code">services</code>
                                        </em></span>
                                        <code class="code">:resource-loading</code>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个Namespace前缀，它代表一个SpringExt的扩展点（Configuration
                                            Point）。</p>
                                        <p>点击它就可以打开相应Configuration Point的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2">SpringExt Contribution</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <code class="code">http://localhost:8080/schema/services/resource-loading.xsd"</code>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个Schema
                                            Location的链接，它代表一个SpringExt的捐献（Contribution）的schema。</p>
                                        <p>点击它就可以打开相应Contribution的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <code class="code">services</code>
                                        <span class="emphasis"><em>
                                            <code class="code">:resource-loading</code>
                                        </em></span>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个XML标签，它代表一个SpringExt的捐献（Contribution）。</p>
                                        <p>点击它就可以打开相应Contribution的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " rowspan="3">Spring Pluggable Schema</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <code class="code">http://www.springframework.org/schema/beans</code>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个Namespace URI，它代表一个Spring所定义的schema。</p>
                                        <p>点击它就可以打开相应的Spring Pluggable Schema的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                        <p>
                                            <code class="code">http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd</code>
                                        </p>
                                        <p>或者：<code class="code">http://www.springframework.org/schema/beans/spring-beans.xsd</code></p>
                                    </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>这是一个Schema Location的链接，它代表一个Spring所定义的schema。</p>
                                        <p>点击它就可以打开相应的Spring Pluggable Schema的编辑器。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                        <span class="emphasis"><em>
                                            <code class="code">beans</code>
                                        </em></span>
                                        <code class="code">:bean</code>
                                    </td><td style="">
                                        <p>这是一个Namespace前缀，它代表一个Spring所定义的schema。</p>
                                        <p>点击它就可以打开相应的Spring Pluggable Schema的编辑器。</p>
                                    </td></tr></tbody></table></div></div></li><li class="listitem"><p>点击Namespaces标签，即可管理配置文件中所引入的namespaces。</p><div class="figure"><a id="d0e16650"><!--anchor d0e16650--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/ns-tab-ui.png" alt="Namespaces编辑界面"/></div></div><p class="title"><strong>图 12.14. Namespaces编辑界面</strong></p></div><p>在这里，你可以：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>浏览所有可用的namespaces。</p><p>你可以用层次状，或是扁平状两种视图来查看。点击namespaces列表顶上的<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/list.png"/></span>或<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/tree.png"/></span>按钮即可切换视图。</p><p>对于层次状列表，点击namespaces列表顶上的<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/expand.png"/></span>按钮即可实现全部展开，或点击<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/collapse.png"/></span>按钮可全部收拢。</p><p>你也可以在过滤框里输入任何字符，来过滤列表，使之只显示你感兴趣的条目。</p></li><li class="listitem"><p>选中某行namespace（注意不是打勾），可查看这个namespace的详细信息。</p><p>例如：namespace的类型、定义在何处、有哪些schema版本等等。</p></li><li class="listitem"><p>点击详细信息中的超链接可打开相应的内容的编辑器。</p></li><li class="listitem"><p>勾选或清除namespace，可在配置文件中插入或清除相应的xmlns和schemaLocation条目。</p></li></ul></div></li><li class="listitem"><p>清除未使用的namespaces —— 选择SpringExt菜单中的“<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/clear-ns.png"/></span> Cleanup Unused Namespaces”、或者点击工具栏上的<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/clear-ns.png"/></span>、或者按快捷键<code class="code">CTRL-SHIFT-O</code>（Mac上为<code class="code">CMD-SHIFT-O</code>）。</p></li><li class="listitem"><p>升级到Webx 3.2.x的配置风格 —— 从Webx 3.2.x开始，改进了配置文件的格式 —— 对于非contribution
                            element采用unqualifed风格，也就是无namespace前缀，使配置文件更易读。</p><div class="table"><a id="d0e16715"><!--anchor d0e16715--></a><p class="title"><strong>表 12.3. 新老风格对比</strong></p><div class="table-contents"><table summary="新老风格对比" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">老风格</th><th style="border-bottom: 0.5pt solid #6666cc; ">Webx 3.2.x 新风格</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                            <pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"register"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;services:field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"name"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"你的名字"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;fm-validators:required-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;fm-validators:message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/fm-validators:message&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/fm-validators:required-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/services:field&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/services:group&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre>
                                        </td><td style="">
                                            <pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:form&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;group</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"register"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;field</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"name"</span> <span class="hl-attribute" style="color: #F5844C">displayName</span>=<span class="hl-value" style="color: #993300">"你的名字"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;fm-validators:required-validator&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;message&gt;</strong>必须填写 ${displayName}<strong class="hl-tag" style="color: #000096">&lt;/message&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/fm-validators:required-validator&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/field&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/group&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:form&gt;</strong></pre>
                                        </td></tr></tbody></table></div></div><p>但是这样配置文件会和以前的版本有所不兼容。如果你决定要升级Webx到3.2.0，只需要选择SpringExt菜单中的“<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/upgrade32.png"/></span> Upgrade to Webx 3.2.x Format”，或者点击工具栏上的<span class="inlinemediaobject"><img src="images/plugin/eclipse/icons/upgrade32.png"/></span>按钮，即可立即转换格式。</p><p>如果你要升级的配置文件不止一个，最简单的方法是在项目的根目录下执行下面的命令：</p><pre class="screen"><span class="command"><strong>mvn springext:convert</strong></span></pre><p>这样所有的Webx/SpringExt配置文件都会被转换成新的格式。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16756"><!--anchor d0e16756--></a>12.3.3. 利用插件编辑SpringExt组件</h3></div></div></div><p>当你在配置文件中，点击任何一个超链接时，就会打开并转到另一个编辑器。在那里，你可以浏览或修改（如果可写的话）SpringExt的组件的内容。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>编辑Configuration Point</p><div class="figure"><a id="d0e16765"><!--anchor d0e16765--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/editor-cp.png" alt="编辑Configuration Point"/></div></div><p class="title"><strong>图 12.15. 编辑Configuration Point</strong></p></div></li><li class="listitem"><p>编辑Contribution</p><div class="figure"><a id="d0e16774"><!--anchor d0e16774--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/editor-contrib.png" alt="编辑Contribution"/></div></div><p class="title"><strong>图 12.16. 编辑Contribution</strong></p></div></li><li class="listitem"><p>编辑Spring Pluggable Schema</p><div class="figure"><a id="d0e16783"><!--anchor d0e16783--></a><div class="figure-contents"><div class="mediaobject"><img src="images/plugin/eclipse/editor-spring.png" alt="编辑Spring Pluggable Schema"/></div></div><p class="title"><strong>图 12.17. 编辑Spring Pluggable Schema</strong></p></div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e16789"><!--anchor d0e16789--></a>12.4. 本章总结</h2></div></div></div><p>SpringExt提供了可扩展的schema机制，虽然很强大，但是如果没有插件的帮助，使用起来很不便。用好插件，可帮助你成倍地提高工作效率。</p></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="tool.autoconfig"><!--anchor tool.autoconfig--></a>第 13 章 AutoConfig工具使用指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e16798">13.1. 需求分析</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16845">13.1.1. 解决方案</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17089">13.2. AutoConfig的设计</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17094">13.2.1. 角色与职责</a></span></dt><dt><span class="section"><a href="#d0e17190">13.2.2. 分享二进制目标文件</a></span></dt><dt><span class="section"><a href="#d0e17218">13.2.3. 部署二进制目标文件</a></span></dt><dt><span class="section"><a href="#d0e17234">13.2.4. AutoConfig特性列表</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17303">13.3. AutoConfig的使用 —— 开发者指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17306">13.3.1. 建立AutoConfig目录结构</a></span></dt><dt><span class="section"><a href="#d0e17446">13.3.2. 建立auto-config.xml描述文件</a></span></dt><dt><span class="section"><a href="#d0e17757">13.3.3. 建立模板文件</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e17901">13.4. AutoConfig的使用 —— 部署者指南</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17913">13.4.1. 在命令行中使用AutoConfig</a></span></dt><dt><span class="section"><a href="#d0e18021">13.4.2. 在maven中使用AutoConfig</a></span></dt><dt><span class="section"><a href="#d0e18061">13.4.3. 运行并观察AutoConfig的结果</a></span></dt><dt><span class="section"><a href="#d0e18132">13.4.4. 共享properties文件</a></span></dt><dt><span class="section"><a href="#d0e18370">13.4.5. AutoConfig常用命令</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18622">13.5. 本章总结</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e16798"><!--anchor d0e16798--></a>13.1. 需求分析</h2></div></div></div><p>在一个应用中，我们总是会遇到一些参数，例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>数据库服务器IP地址、端口、用户名；</p></li><li class="listitem"><p>用来保存上传资料的目录。</p></li><li class="listitem"><p>一些参数，诸如是否打开cache、加密所用的密钥名称等等。</p></li></ul></div><p>这些参数有一个共性，那就是：<span class="emphasis"><em>它们和应用的逻辑无关，只和当前环境、当前系统用户相关</em></span>。以下场景很常见：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>在开发、测试、发布阶段，使用不同的数据库服务器；</p></li><li class="listitem"><p>在开发阶段，使用Windows的A开发者将用户上传的文件存放在<code class="filename">d:\my_upload</code>目录中，而使用Linux的B开发者将同样的文件存放在<code class="filename">/home/myname/my_upload</code>目录中。</p></li><li class="listitem"><p>在开发阶段设置<code class="code">cache=off</code>，在生产环境中设置<code class="code">cache=on</code>。 </p></li></ul></div><p>很明显，<span class="emphasis"><em>这些参数不适合被“硬编码”在配置文件或代码中</em></span>。因为每一个从源码库中取得它们的人，都有可能需要修改它们，使之与自己的环境相匹配。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e16845"><!--anchor d0e16845--></a>13.1.1. 解决方案</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16848"><!--anchor d0e16848--></a>13.1.1.1. 运行时替换的placeholders</h4></div></div></div><p>很多框架支持在运行时刻替换配置文件中的placeholder占位符。例如， Webx/Spring就有这个功能。</p><div class="example"><a id="d0e16853"><!--anchor d0e16853--></a><p class="title"><strong>例 13.1. 在Webx中定义placeholders</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:property-placeholder /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;services:webx-configuration&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:productionMode&gt;</strong>${productionMode:true}<strong class="hl-tag" style="color: #000096">&lt;/services:productionMode&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:webx-configuration&gt;</strong></pre></div></div><p>在上面这个例子中，你可以在启动应用时，加上JVM参数：“<code class="code">-DproductionMode=false|true</code>”来告诉系统用哪一种模式来工作。如果不指定，则取默认值“<code class="code">true</code>”。</p><p>运行时替换placeholder是一种非常实用的技术，它有如下优缺点：</p><div class="table"><a id="d0e16868"><!--anchor d0e16868--></a><p class="title"><strong>表 13.1. 运行时替换placeholders的优缺点</strong></p><div class="table-contents"><table summary="运行时替换placeholders的优缺点" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">优点</th><th style="border-bottom: 0.5pt solid #6666cc; ">缺点</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>配置文件是静态的、不变的。即使采用不同的参数值，你也不需要更改配置文件本身。</p></li><li class="listitem"><p>你可以随时改变参数的值，只需要启动时指定不同的JVM参数、或指定不同的properties文件即可。</p></li><li class="listitem"><p>这种配置对于应用程序各组件是透明的 ——
                                                应用程序不需要做特别的编程，即可使用placeholders。</p></li></ul></div>
                                </td><td style="">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>并非所有框架都支持这种技术。</p></li><li class="listitem"><p>支持该技术的框架各有不同的用法。例如：Spring和Log4j都支持placeholder替换，然则它们的做法是完全不同的。Spring通过<code class="code">PropertyPlaceholderConfigurer</code>类来配置，而Log4j则需要在<code class="code">DomConfigurator</code>中把参数传进去。</p></li></ul></div>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16911"><!--anchor d0e16911--></a>13.1.1.2. 中心配置服务器（Config Server）</h4></div></div></div><p>这也是一种运行时技术。它可以在运行时刻，将应用所需的参数推送到应用中。</p><p>它有如下优缺点：</p><div class="table"><a id="d0e16918"><!--anchor d0e16918--></a><p class="title"><strong>表 13.2. 中心配置服务器的优缺点</strong></p><div class="table-contents"><table summary="中心配置服务器的优缺点" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">优点</th><th style="border-bottom: 0.5pt solid #6666cc; ">缺点</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>它可以集中管理所有应用的配置，避免可能的错误；</p></li><li class="listitem"><p>它可以在运行时改变参数的值，并推送到所有应用中。参数的更改可立即生效。</p></li></ul></div>
                                </td><td style="">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>需要一套独立的服务器系统。性能、可用性（availability）都是必须考虑的问题。</p></li><li class="listitem"><p>对应用不是透明的，有一定的侵入性。应用程序必须主动来配合该技术。因此，该技术不可能适用于所有情况，特别对于第三方提供的代码，很难使用该技术。</p></li><li class="listitem"><p>为了连接到中心配置服务器，你仍然需要配置适当的IP、端口等参数。你需要用其它技术来处理这些参数（例如placeholders）。</p></li></ul></div>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e16955"><!--anchor d0e16955--></a>13.1.1.3. Maven Filtering机制</h4></div></div></div><p>Maven提供了一种过滤机制，可以在资源文件被复制到目标目录的同时，替换其中的placeholders。</p><div class="example"><a id="d0e16960"><!--anchor d0e16960--></a><p class="title"><strong>例 13.2. 配置Maven Filtering机制</strong></p><div class="example-contents"><p>假设你的项目目录结构如下：</p><pre class="screen">web-project
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         ├─resources
         └─webapp
             └─WEB-INF
                     web.xml</pre><p>在<code class="filename">pom.xml</code>中这样写：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filters&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>${user.home}/antx.properties<strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong> <a id="co.autoconfig.mavenfilters.props"><!--anchor co.autoconfig.mavenfilters.props--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/filters&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;resources&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;resource&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;directory&gt;</strong>src/main/resources<strong class="hl-tag" style="color: #000096">&lt;/directory&gt;</strong> <a id="co.autoconfig.mavenfilters.resources"><!--anchor co.autoconfig.mavenfilters.resources--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;includes&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;include&gt;</strong>**.xml<strong class="hl-tag" style="color: #000096">&lt;/include&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/includes&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;filtering&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/filtering&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;resource&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;directory&gt;</strong>src/main/resources<strong class="hl-tag" style="color: #000096">&lt;/directory&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;excludes&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;exclude&gt;</strong>**.xml<strong class="hl-tag" style="color: #000096">&lt;/exclude&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/excludes&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/resources&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>maven-war-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;webResources&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;resource&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;directory&gt;</strong>src/main/webapp<strong class="hl-tag" style="color: #000096">&lt;/directory&gt;</strong> <a id="co.autoconfig.mavenfilters.resources.web"><!--anchor co.autoconfig.mavenfilters.resources.web--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
                        <strong class="hl-tag" style="color: #000096">&lt;includes&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;include&gt;</strong>WEB-INF/**.xml<strong class="hl-tag" style="color: #000096">&lt;/include&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;/includes&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;filtering&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/filtering&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;resource&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;directory&gt;</strong>src/main/webapp<strong class="hl-tag" style="color: #000096">&lt;/directory&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;excludes&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;include&gt;</strong>WEB-INF/**.xml<strong class="hl-tag" style="color: #000096">&lt;/include&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;/excludes&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/resource&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/webResources&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong></pre><p>这段pom定义告诉maven：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.mavenfilters.props"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>用指定的properties文件（<code class="filename">${user.home}/antx.properties</code>）中的值，替换文件中的placeholders。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.mavenfilters.resources"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>过滤<code class="filename">src/main/resources/</code>目录中的所有xml文件，替换其中的placeholders。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.mavenfilters.resources.web"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>过滤<code class="filename">src/webapp/WEB-INF/</code>目录中的所有xml文件，替换其中的placeholders。</p></td></tr></table></div></div></div><p>如果上述xml文件中，包含“<code class="code">${xxx.yyy.zzz}</code>”这样的placeholders，将被替换成properties文件中的相应值。</p><p>和运行时替换placeholders方案相比，Maven Filtering是一个build时进行的过程。它的优缺点是： </p><div class="table"><a id="d0e17008"><!--anchor d0e17008--></a><p class="title"><strong>表 13.3. Maven Filtering机制的优缺点</strong></p><div class="table-contents"><table summary="Maven Filtering机制的优缺点" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">优点</th><th style="border-bottom: 0.5pt solid #6666cc; ">缺点</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Maven
                                                filtering机制和应用所采用的技术、框架完全无关，对应用完全透明，通用性好。</p></li></ul></div>
                                </td><td style="">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Maven
                                                filtering机制在build时刻永久性改变被过滤的配置文件的内容，build结束以后无法更改。这将导致一个问题：如果要改变配置文件的参数，必须获取源码并重新build。</p></li><li class="listitem"><p>缺少验证机制。当某个placeholder拼写错误；当properties中的值写错；当某配置文件中新增了一个placeholder，而你的properties文件中没有对应的值时，maven不会提醒你。而这些错误往往被拖延到应用程序运行时才会被报告出来。</p></li></ul></div>
                                </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17039"><!--anchor d0e17039--></a>13.1.1.4. AutoConfig机制</h4></div></div></div><p>AutoConfig是一种类似于Maven
                    Filtering的<span class="emphasis"><em>build时刻的工具</em></span>。这意味着该机制与应用所采用的技术、框架完全无关，对应用完全透明，具有良好的通用性。同时，AutoConfig与运行时的配置技术并不冲突。它可以和运行时替换的placeholders以及中心配置服务器完美并存，互为补充。</p><p>AutoConfig书写placeholder的方法和Maven Filtering机制完全相同。换言之，Maven
                        Filtering的配置文件模板（前例中的<code class="filename">/WEB-INF/**.xml</code>）可以不加修改地用在AutoConfig中。</p><p>然而，autoconfig成功克服了Maven Filtering的主要问题。</p><div class="table"><a id="d0e17054"><!--anchor d0e17054--></a><p class="title"><strong>表 13.4. Maven Filtering和AutoConfig的比较</strong></p><div class="table-contents"><table summary="Maven Filtering和AutoConfig的比较" cellpadding="10" style="border: none;"><colgroup><col width="33%" class="c1"/><col width="33%" class="c2"/><col width="34%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">问题</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Maven Filtering</th><th style="border-bottom: 0.5pt solid #6666cc; ">AutoConfig</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">如何修改配置文件的参数？</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Maven Filtering必须获得源码并重新build；</td><td style="border-bottom: 0.5pt solid #6666cc; ">而AutoConfig不需要提取源码，也不需要重新build，即可改变<span class="emphasis"><em>目标文件</em></span>中所有配置文件中placeholders的值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">如何确保placeholder替换的正确性？</td><td style="border-right: 0.5pt solid #6666cc; ">Maven Filtering不能验证placeholder值的缺失和错误；</td><td style="">但AutoConfig可以对placeholder及其值进行检查。</td></tr></tbody></table></div></div><p>接下来，我们将将详细介绍AutoConfig的使用方法。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e17089"><!--anchor d0e17089--></a>13.2. AutoConfig的设计</h2></div></div></div><p>很多人会把AutoConfig看作Maven Filtering机制的简单替代品。事实上，这两者的设计初衷有很大的区别。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17094"><!--anchor d0e17094--></a>13.2.1. 角色与职责</h3></div></div></div><p>为了把事情说清楚，我们必须要定义两种角色：<span class="emphasis"><em>开发者（Developer）</em></span>和<span class="emphasis"><em>部署者（Deployer）</em></span>。</p><div class="table"><a id="d0e17105"><!--anchor d0e17105--></a><p class="title"><strong>表 13.5. 角色和职责</strong></p><div class="table-contents"><table summary="角色和职责" cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">角色名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">职责</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">开发者</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>定义应用所需要的properties，及其限定条件；</p></li><li class="listitem"><p>提供包含placeholders的配置文件模板。</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">部署者</td><td style="">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>根据所定义的properties，提供符合限定条件的属性值。</p></li><li class="listitem"><p>调用AutoConfig来生成目标配置文件。</p></li></ul></div>
                            </td></tr></tbody></table></div></div><p>例如，一个宠物店（petstore）的WEB应用中需要指定一个用来上传文件的目录。于是，</p><div class="table"><a id="d0e17146"><!--anchor d0e17146--></a><p class="title"><strong>表 13.6. Petstore应用中的角色和职责</strong></p><div class="table-contents"><table summary="Petstore应用中的角色和职责" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">开发者</th><th style="border-bottom: 0.5pt solid #6666cc; ">部署者</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <p>开发者定义了一个property：<code class="code">petstore.upload_dir</code>，</p>
                                <p>限定条件为：“合法的文件系统的目录名”。</p>
                            </td><td style="">
                                <p>部署者取得petstore的二进制发布包，通过AutoConfig了解到，应用需要一个名为<code class="code">petstore.upload_dir</code>目录名。</p>
                                <p>部署者便指定一个目录给petstore，该目录名的具体值可能因不同的系统而异。</p>
                                <p>AutoConfig会检验该值是否符合限定条件（是否为合法目录名），如果检验通过，就生成配置文件，并将其中的<code class="code">${petstore.upload_dir}</code>替换成该目录名。</p>
                            </td></tr></tbody></table></div></div><p>需要注意的是，一个“物理人”所对应的“角色”不是一成不变的。例如：某“开发者”需要试运行应用，此时，他就变成“部署者”。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17190"><!--anchor d0e17190--></a>13.2.2. 分享二进制目标文件</h3></div></div></div><p>假设现在有两个team要互相合作，team A的开发者创建了project A，而team B的开发者创建了project B。假定project
                B依赖于project A。如果我们利用maven这样的build工具，那么最显而易见的合作方案是这样的：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Team A发布一个project A的版本到maven repository中。</p></li><li class="listitem"><p>Team B从maven repository中取得project A的二进制目标文件。</p></li></ul></div><p>这种方案有很多好处，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>每个team都可以独立控制自己发布版本的节奏；</p></li><li class="listitem"><p>Team之间的关系较松散，唯一的关系纽带就是maven repository。</p></li><li class="listitem"><p>Team之间不需要共享源码。</p></li></ul></div><p>然而，假如project A中有一些配置文件中的placeholders需要被替换，如果使用Maven Filtering机制，就会出现问题。因为Maven
                Filtering只能在project A被build时替换其中的placeholders，一旦project A被发布到repository中，team
                B的人将无法修改任何project A中的配置参数。除非team B的人取得project A的源码，并重新build。这将带来很大的负担。</p><p>AutoConfig解决了这个问题。因为当team B的人从maven repository中取得project
                A的二进制包时，仍然有机会修改其配置文件里的placeholders。Team B的人甚至不需要了解project
                A里配置文件的任何细节，AutoConfig会自动发现所有的properties定义，并提示编辑。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17218"><!--anchor d0e17218--></a>13.2.3. 部署二进制目标文件</h3></div></div></div><p>部署应用的人（即部署者、deployer）也从中受益。因为deployer不再需要亲手去build源代码，而是从maven
                repository中取得二进制目标文件即可。</p><div class="figure"><a id="d0e17223"><!--anchor d0e17223--></a><div class="figure-contents"><div class="mediaobject"><img src="images/tool/co-op.png" alt="多团队多角色的合作"/></div></div><p class="title"><strong>图 13.1. 多团队多角色的合作</strong></p></div><p>从这个意义上讲，AutoConfig不应当被看成是一个build时的简单配置工具，而是一个“<span class="emphasis"><em>软件安装工具</em></span>”。如同我们安装一个Windows软件
                ——
                我们当然不需要从源码开始build它们，而是执行其安装程序，设定一些参数诸如安装目录、文档目录、可选项等。安装程序就会自动把软件设置好，确保软件可正确运行于当前的Windows环境中。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17234"><!--anchor d0e17234--></a>13.2.4. AutoConfig特性列表</h3></div></div></div><p>为了满足前面所说的目的，我们将AutoConfig设计成下面的样子：</p><div class="table"><a id="d0e17239"><!--anchor d0e17239--></a><p class="title"><strong>表 13.7. AutoConfig Features</strong></p><div class="table-contents"><table summary="AutoConfig Features" cellpadding="10" style="border: none;"><colgroup><col width="28%" class="c1"/><col width="72%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">描述</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">两种用法</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>既可独立使用（支持Windows和Unix-like平台）。</p></li><li class="listitem"><p>也可以作为maven插件来使用。</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">对目标文件而不是源文件进行配置</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>可对同一个目标文件反复配置。</p></li><li class="listitem"><p>配置时不依赖于项目源文件。</p></li><li class="listitem"><p>支持嵌套包文件，例如：ear包含war，war又包含jar。</p></li><li class="listitem"><p>高性能，特别对于嵌套的包文件。 </p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">验证和编辑properties</td><td style="">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>自动发现保存于war包、jar包、ear包中的properties定义。</p></li><li class="listitem"><p>验证properties的正确性。</p></li><li class="listitem"><p>交互式编辑properties。</p></li><li class="listitem"><p>当配置文件中出现未定义的placeholders时，提示报错。 </p></li></ul></div>
                            </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e17303"><!--anchor d0e17303--></a>13.3. AutoConfig的使用 —— 开发者指南</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17306"><!--anchor d0e17306--></a>13.3.1. 建立AutoConfig目录结构</h3></div></div></div><p>和Maven
                    Filtering不同的是，AutoConfig是针对目标文件的配置工具。因此AutoConfig关心的目录结构是<span class="emphasis"><em>目标文件的目录结构</em></span>。不同的build工具，创建同一目标目录结构所需要的源文件的目录结构会各有不同。本文仅以maven标准目录结构为例，来说明源文件的目录结构编排。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17314"><!--anchor d0e17314--></a>13.3.1.1. WAR包的目录结构</h4></div></div></div><p>这里所说的war包，可以是一个以zip方式打包的文件，也可以是一个展开的目录。下面以maven标准目录为例，说明项目源文件和目标文件的目录结构的对比：</p><div class="example"><a id="d0e17319"><!--anchor d0e17319--></a><p class="title"><strong>例 13.3. WAR包的源文件和目标文件目录结构</strong></p><div class="example-contents"><pre class="screen">war-project（源目录结构）               -&gt; war-project.war（目标目录结构）
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         ├─resources                    -&gt; /WEB-INF/classes
         │      file1.xml                      file1.xml
         │      file2.xml                      file2.xml
         │
         └─webapp                       -&gt; /
             ├─<span class="emphasis"><em>META-INF</em></span>                 -&gt; <span class="emphasis"><em>/META-INF</em></span>
             │  └─<span class="emphasis"><em>autoconf</em></span>              -&gt; <span class="emphasis"><em>/META-INF/autoconf</em></span> <a id="co.autoconfig.war.config.dir"><!--anchor co.autoconfig.war.config.dir--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
             │        <span class="emphasis"><em>auto-config.xml</em></span>          <span class="emphasis"><em>auto-config.xml</em></span> <a id="co.autoconfig.war.config"><!--anchor co.autoconfig.war.config--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
             │
             └─WEB-INF                  -&gt; /WEB-INF
                   web.xml                     web.xml
                   file3.xml                   file3.xml</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.war.config.dir"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="filename">/META-INF/autoconf</code>目录用来存放AutoConfig的描述文件，以及可选的模板文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.war.config"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="filename">auto-config.xml</code>是用来指导AutoConfig行为的关键描述文件。</p></td></tr></table></div></div></div><p>创建war包的AutoConfig机制，关键在于创建war目标文件中的<code class="filename">/META-INF/autoconf/auto-config.xml</code>描述文件。该描述文件对应的maven项目源文件为：<code class="filename">/src/main/webapp/META-INF/autoconf/auto-config.xml</code>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17365"><!--anchor d0e17365--></a>13.3.1.2. JAR包的目录结构</h4></div></div></div><p>这里所说的jar包，可以是一个以zip方式打包的文件，也可以是一个展开的目录。下面以maven标准目录为例，说明项目源文件和目标文件的目录结构的对比：</p><div class="example"><a id="d0e17370"><!--anchor d0e17370--></a><p class="title"><strong>例 13.4. JAR包的源文件和目标文件目录结构</strong></p><div class="example-contents"><pre class="screen">jar-project（源目录结构）               -&gt; jar-project.jar（目标目录结构）
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         └─resources                    -&gt; /
             │  file1.xml                      file1.xml
             │  file2.xml                      file2.xml
             │
             └─<span class="emphasis"><em>META-INF</em></span>                 -&gt; <span class="emphasis"><em>/META-INF</em></span>
                 └─<span class="emphasis"><em>autoconf</em></span>             -&gt; <span class="emphasis"><em>/META-INF/autoconf</em></span> <a id="co.autoconfig.jar.config.dir"><!--anchor co.autoconfig.jar.config.dir--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
                       <span class="emphasis"><em>auto-config.xml</em></span>         <span class="emphasis"><em>auto-config.xml</em></span> <a id="co.autoconfig.jar.config"><!--anchor co.autoconfig.jar.config--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.jar.config.dir"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="filename">/META-INF/autoconf</code>目录用来存放AutoConfig的描述文件，以及可选的模板文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.jar.config"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="filename">auto-config.xml</code>是用来指导AutoConfig行为的关键描述文件。</p></td></tr></table></div></div></div><p>创建jar包的AutoConfig机制，关键在于创建jar目标文件中的<code class="filename">/META-INF/autoconf/auto-config.xml</code>描述文件。该描述文件对应的maven项目源文件为：<code class="filename">/src/main/resources/META-INF/autoconf/auto-config.xml</code>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17415"><!--anchor d0e17415--></a>13.3.1.3. 普通目录</h4></div></div></div><p>AutoConfig也支持对普通文件目录进行配置。</p><div class="example"><a id="d0e17420"><!--anchor d0e17420--></a><p class="title"><strong>例 13.5. 对普通的目录执行AutoConfig</strong></p><div class="example-contents"><pre class="screen">directory
 │  file1.xml
 │  file2.xml
 │
 └─<span class="emphasis"><em>conf</em></span> <a id="co.autoconfig.dir.config.dir"><!--anchor co.autoconfig.dir.config.dir--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
       <span class="emphasis"><em>auto-config.xml</em></span> <a id="co.autoconfig.dir.config"><!--anchor co.autoconfig.dir.config--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.dir.config.dir"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>默认情况下，AutoConfig在<code class="filename">/conf</code>目录中寻找AutoConfig的描述文件，以及可选的模板文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.dir.config"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="filename">auto-config.xml</code>是用来指导AutoConfig行为的关键描述文件。</p></td></tr></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17446"><!--anchor d0e17446--></a>13.3.2. 建立auto-config.xml描述文件</h3></div></div></div><p>AutoConfig系统的核心就是<code class="filename">auto-config.xml</code>描述文件。该描述文件中包含两部分内容：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>定义properties：properties的名称、描述、默认值、约束条件等信息；</p></li><li class="listitem"><p>指定包含placeholders的模板文件。 </p></li></ol></div><p>下面是<code class="filename">auto-config.xml</code>文件的样子：（以petstore应用为例）</p><div class="example"><a id="d0e17466"><!--anchor d0e17466--></a><p class="title"><strong>例 13.6. AutoConfig描述文件示例</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;config&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;group&gt;</strong>

        <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"petstore.work"</span>
                    <span class="hl-attribute" style="color: #F5844C">description</span>=<span class="hl-value" style="color: #993300">"应用程序的工作目录"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.autoconfig.config.property1"><!--anchor co.autoconfig.config.property1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>

        <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"petstore.loggingRoot"</span> 
                    <span class="hl-attribute" style="color: #F5844C">defaultValue</span>=<span class="hl-value" style="color: #993300">"${petstore.work}/logs"</span>
                    <span class="hl-attribute" style="color: #F5844C">description</span>=<span class="hl-value" style="color: #993300">"日志文件目录"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.autoconfig.config.property2"><!--anchor co.autoconfig.config.property2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>

        <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"petstore.upload"</span>
                    <span class="hl-attribute" style="color: #F5844C">defaultValue</span>=<span class="hl-value" style="color: #993300">"${petstore.work}/upload"</span>
                    <span class="hl-attribute" style="color: #F5844C">description</span>=<span class="hl-value" style="color: #993300">"上传文件的目录"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.autoconfig.config.property3"><!--anchor co.autoconfig.config.property3--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>

        <strong class="hl-tag" style="color: #000096">&lt;property</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"petstore.loggingLevel"</span>
                    <span class="hl-attribute" style="color: #F5844C">defaultValue</span>=<span class="hl-value" style="color: #993300">"warn"</span>
                    <span class="hl-attribute" style="color: #F5844C">description</span>=<span class="hl-value" style="color: #993300">"日志文件级别"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.autoconfig.config.property4"><!--anchor co.autoconfig.config.property4--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>

            <strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"choice"</span>
                         <span class="hl-attribute" style="color: #F5844C">choice</span>=<span class="hl-value" style="color: #993300">"trace, debug, info, warn, error"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.autoconfig.config.validator"><!--anchor co.autoconfig.config.validator--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>

        <strong class="hl-tag" style="color: #000096">&lt;/property&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;/group&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;script&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;generate</strong> <span class="hl-attribute" style="color: #F5844C">template</span>=<span class="hl-value" style="color: #993300">"WEB-INF/web.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.autoconfig.config.generate"><!--anchor co.autoconfig.config.generate--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;generate</strong> <span class="hl-attribute" style="color: #F5844C">template</span>=<span class="hl-value" style="color: #993300">"WEB-INF/common/resources.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/script&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/config&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.config.property1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.autoconfig.config.property2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> <a href="#co.autoconfig.config.property3"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> <a href="#co.autoconfig.config.property4"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义properties</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.config.validator"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义property的验证规则（可选）</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.config.generate"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>生成配置文件的指令。</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17493"><!--anchor d0e17493--></a>13.3.2.1. 定义properties</h4></div></div></div><p>定义一个property的完整格式如下：</p><div class="example"><a id="d0e17498"><!--anchor d0e17498--></a><p class="title"><strong>例 13.7. 定义一个property</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;property</strong>
    <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"..."</span>
    <span class="hl-attribute" style="color: #F5844C">[defaultValue</span>=<span class="hl-value" style="color: #993300">"..."</span><span class="hl-attribute" style="color: #F5844C">]</span>
    <span class="hl-attribute" style="color: #F5844C">[description</span>=<span class="hl-value" style="color: #993300">"..."</span><span class="hl-attribute" style="color: #F5844C">]</span>
    <span class="hl-attribute" style="color: #F5844C">[required</span>=<span class="hl-value" style="color: #993300">"true|false"</span><span class="hl-attribute" style="color: #F5844C">]</span><strong class="hl-tag" style="color: #000096">
&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/property&gt;</strong></pre></div></div><p>可用的property参数包括：</p><div class="table"><a id="d0e17505"><!--anchor d0e17505--></a><p class="title"><strong>表 13.8. 定义property时可用的参数</strong></p><div class="table-contents"><table summary="定义property时可用的参数" cellpadding="10" style="border: none;"><colgroup><col width="33%" class="c1"/><col width="67%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">name</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">Property名称。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">defaultValue</code>（可选）</td><td style="border-bottom: 0.5pt solid #6666cc; ">默认值。默认值中可包含对其它property的引用，如<code class="code">${petstore.work}/logs</code>。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">description</code>（可选）</td><td style="border-bottom: 0.5pt solid #6666cc; ">对字段的描述，这个描述会显示给deployer，这对他理解该property非常重要。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">required</code>（可选）</td><td style="">是否“必填”，默认为<code class="code">true</code>。如果deployer未提供必填项的值，就会报错。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17551"><!--anchor d0e17551--></a>13.3.2.2. 定义property的验证规则</h4></div></div></div><p>目前，有以下几种验证器：</p><div class="table"><a id="d0e17556"><!--anchor d0e17556--></a><p class="title"><strong>表 13.9. 可用的property验证规则</strong></p><div class="table-contents"><table summary="可用的property验证规则" cellpadding="10" style="border: none;"><colgroup><col width="59%" class="c1"/><col width="41%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">验证规则</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"boolean"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为<code class="code">true</code>或<code class="code">false</code>。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"choice"</span>
           <span class="hl-attribute" style="color: #F5844C">choice</span>=<span class="hl-value" style="color: #993300">"trace, debug, info, warn, error"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为choice所定义的值之一。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"email"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为合法的email格式。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"fileExist"</span>
           <span class="hl-attribute" style="color: #F5844C">[file</span>=<span class="hl-value" style="color: #993300">"WEB-INF/web.xml"</span><span class="hl-attribute" style="color: #F5844C">]</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为某个存在的文件或目录。</p>
                                    <p>如果指定了file，那就意味着property值所指的目录下，必须存在file所指的文件或子目录。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"hostExist"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为合法的IP地址，或者可以解析得到的域名。 </p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"keyword"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为字母、数字、下划线的组合。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"number"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须为数字的组合。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"regexp"</span>
           <span class="hl-attribute" style="color: #F5844C">regexp</span>=<span class="hl-value" style="color: #993300">"..."</span>
           <span class="hl-attribute" style="color: #F5844C">[mode</span>=<span class="hl-value" style="color: #993300">"exact|prefix|contain"</span><span class="hl-attribute" style="color: #F5844C">]</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style="border-bottom: 0.5pt solid #6666cc; "><p>Property值必须符合regexp所指的正则表达式。</p>
                                    <p>其中，mode为匹配的方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>完全匹配exact</p></li><li class="listitem"><p>前缀匹配prefix</p></li><li class="listitem"><p>包含contain</p></li></ul></div>
                                    <p>如未指定mode，默认mode为contain。</p></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;validator</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"url"</span>
           <span class="hl-attribute" style="color: #F5844C">[checkHostExist</span>=<span class="hl-value" style="color: #993300">"false"</span><span class="hl-attribute" style="color: #F5844C">]</span>
           <span class="hl-attribute" style="color: #F5844C">[protocols</span>=<span class="hl-value" style="color: #993300">"http, https"</span><span class="hl-attribute" style="color: #F5844C">]</span>
           <span class="hl-attribute" style="color: #F5844C">[endsWithSlash</span>=<span class="hl-value" style="color: #993300">"true"</span><span class="hl-attribute" style="color: #F5844C">]</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></td><td style=""><p>Property值必须是合法URL。</p>
                                    <p>假如指定了<code class="code">checkHostExist=true</code>，那么还会检查域名或IP的正确性；</p>
                                    <p>假如指定了protocols，那么URL的协议必须为其中之一；</p>
                                    <p>假如指定了<code class="code">endsWithSlash=true</code>，那么URL必须以/结尾。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17672"><!--anchor d0e17672--></a>13.3.2.3. 生成配置文件的指令</h4></div></div></div><p>描述文件中，每个<code class="code">&lt;generate&gt;</code>标签指定了一个包含placeholders的配置文件模板，具体格式为：</p><div class="example"><a id="d0e17680"><!--anchor d0e17680--></a><p class="title"><strong>例 13.8. 生成配置文件的指令</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;generate</strong>
    <span class="hl-attribute" style="color: #F5844C">template</span>=<span class="hl-value" style="color: #993300">"..."</span>
    <span class="hl-attribute" style="color: #F5844C">[destfile</span>=<span class="hl-value" style="color: #993300">"..."</span><span class="hl-attribute" style="color: #F5844C">]</span>
    <span class="hl-attribute" style="color: #F5844C">[charset</span>=<span class="hl-value" style="color: #993300">"..."</span><span class="hl-attribute" style="color: #F5844C">]</span>
    <span class="hl-attribute" style="color: #F5844C">[outputCharset</span>=<span class="hl-value" style="color: #993300">"..."</span><span class="hl-attribute" style="color: #F5844C">]</span><strong class="hl-tag" style="color: #000096">
&gt;</strong></pre></div></div><p>下面是参数的说明：</p><div class="table"><a id="d0e17687"><!--anchor d0e17687--></a><p class="title"><strong>表 13.10. 生成配置文件的指令参数</strong></p><div class="table-contents"><table summary="生成配置文件的指令参数" cellpadding="10" style="border: none;"><colgroup><col width="24%" class="c1"/><col width="76%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">template</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <p>需要配置的模板名。</p>
                                    <p>模板名为相对路径，相对于当前jar/war/ear包的根目录。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">destfile</code>（可选）</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <p>目标文件。</p>
                                    <p>如不指定，表示目标文件和模板文件相同。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">charset</code>（可选）</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <p>模板的字符集编码。</p>
                                    <p>XML文件不需要指定<code class="code">charset</code>，因为AutoConfig可以自动取得XML文件的字符集编码；</p>
                                    <p>对其它文件必须指定charset。</p>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">outputCharset</code>（可选）</td><td style="">
                                    <p>目标文件的输出字符集编码。</p>
                                    <p>如不指定，表示和模板charset相同。</p>
                                </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17757"><!--anchor d0e17757--></a>13.3.3. 建立模板文件</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17760"><!--anchor d0e17760--></a>13.3.3.1. 模板文件的位置</h4></div></div></div><p>定义完<code class="filename">auto-config.xml</code>描述文件以后，就可以创建模板了。模板放在哪里呢？举例说明。</p><div class="example"><a id="d0e17768"><!--anchor d0e17768--></a><p class="title"><strong>例 13.9. 模板文件的位置</strong></p><div class="example-contents"><p>假设在一个典型的WEB应用中，你的<code class="filename">auto-config.xml</code>中包含指定了如下模板：</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;config&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;group&gt;</strong>
        ...
    <strong class="hl-tag" style="color: #000096">&lt;/group&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;script&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;generate</strong> <span class="hl-attribute" style="color: #F5844C">template</span>=<span class="hl-value" style="color: #993300">"WEB-INF/classes/file1.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;generate</strong> <span class="hl-attribute" style="color: #F5844C">template</span>=<span class="hl-value" style="color: #993300">"WEB-INF/classes/file2.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;generate</strong> <span class="hl-attribute" style="color: #F5844C">template</span>=<span class="hl-value" style="color: #993300">"WEB-INF/file3.xml"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/script&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/config&gt;</strong></pre><p>那么，你可以把<code class="filename">file1.xml</code>、<code class="filename">file2.xml</code>、<code class="filename">file3.xml</code>放在下面的位置：</p><pre class="screen">war-project（源目录结构）               -&gt; war-project.war（目标目录结构）
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         ├─<span class="emphasis"><em>resources</em></span>                    -&gt; <span class="emphasis"><em>/WEB-INF/classes</em></span>
         │     <span class="emphasis"><em>file1.xml</em></span>                       <span class="emphasis"><em>file1.xml - 建议放在这里</em></span>
         │     <span class="emphasis"><em>file2.xml</em></span>                       <span class="emphasis"><em>file2.xml - 建议放在这里</em></span>
         │
         └─webapp
             ├─META-INF
             │  └─autoconf
             │      │  auto-config.xml
             │      │
             │      └─WEB-INF           -&gt; /WEB-INF
             │          │ file3.xml            file3.xml - 也可以放在这里
             │          │
             │          └─classes       -&gt; /WEB-INF/classes
             │                file1.xml        file1.xml - 也可以放在这里
             │                file2.xml        file2.xml - 也可以放在这里
             │
             └─<span class="emphasis"><em>WEB-INF</em></span>                  -&gt; <span class="emphasis"><em>/WEB-INF</em></span>
                   <span class="emphasis"><em>file3.xml</em></span>                   <span class="emphasis"><em>file3.xml - 建议放在这里</em></span></pre></div></div><p>AutoConfig的寻找模板的逻辑是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>如果在<code class="filename">auto-config.xml</code>所在的目录下发现模板文件，就使用它；</p></li><li class="listitem"><p>否则在包的根目录中查找模板文件；如果两处均未找到，则报错。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17832"><!--anchor d0e17832--></a>13.3.3.2. 模板的写法</h4></div></div></div><p>书写模板是很简单的事，你只要：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>把需要配置的点替换成placeholder：“<code class="code">${property.name}</code>”。当然，你得确保property.name被定义在<code class="filename">auto-config.xml</code>中。</p></li><li class="listitem"><p>假如模板中包含<span class="emphasis"><em>不希望被替换的</em></span>运行时的placeholder“<span class="emphasis"><em><code class="code">$</code></em></span><code class="code">{...}</code>”，需要更改成“<span class="emphasis"><em><code class="code">${D}</code></em></span><code class="code">{...}</code>”
                                。</p></li></ul></div><div class="example"><a id="d0e17865"><!--anchor d0e17865--></a><p class="title"><strong>例 13.10. 模板示例</strong></p><div class="example-contents"><pre class="programlisting">...
<strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingRoot<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>${petstore.loggingRoot}</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingLevel<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>${petstore.loggingLevel}</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
...
<span class="emphasis"><em>${D}</em></span>{runtime.placeholder}</pre></div></div><p>此外，AutoConfig模板其实是由Velocity模板引擎来渲染的。因此，所有的placeholder必须能够通过velocity的语法。</p><div class="example"><a id="d0e17881"><!--anchor d0e17881--></a><p class="title"><strong>例 13.11. 使用不符合velocity语法的placeholders</strong></p><div class="example-contents"><p>例如，下面的placeholder被velocity看作非法：</p><pre class="programlisting">${my.property<span class="emphasis"><em>.2</em></span>}</pre><p>解决的办法是，改写成如下样式：</p><pre class="programlisting">${my<span class="emphasis"><em>_</em></span>property<span class="emphasis"><em>_2</em></span>}</pre></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e17901"><!--anchor d0e17901--></a>13.4. AutoConfig的使用 —— 部署者指南</h2></div></div></div><p>部署者有两种方法可以使用AutoConfig：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>在命令行上直接运行。</p></li><li class="listitem"><p>在maven中调用AutoConfig plugin。</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17913"><!--anchor d0e17913--></a>13.4.1. 在命令行中使用AutoConfig</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="tool.autoconfig.getbinary"><!--anchor tool.autoconfig.getbinary--></a>13.4.1.1. 取得可执行文件</h4></div></div></div><p>AutoConfig提供了Windows以及Unix-like（Linux、Mac
                    OS等）等平台上均可使用的native可执行程序。可执行程序文件被发布在Maven repository中。</p><p>如果你已经配置好了maven，那么可以让maven来帮你下载目标文件。</p><div class="example"><a id="d0e17923"><!--anchor d0e17923--></a><p class="title"><strong>例 13.12. 让maven帮忙下载AutoConfig可执行文件</strong></p><div class="example-contents"><p>请创建一个临时文件：<code class="filename">pom.xml</code>。</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parent&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.alibaba.citrus.tool<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>antx-parent<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.2<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong> <a id="co.autoconfig.native.version"><!--anchor co.autoconfig.native.version--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/parent&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;modelVersion&gt;</strong>4.0.0<strong class="hl-tag" style="color: #000096">&lt;/modelVersion&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>temp<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.native.version"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>文件中的parent pom的版本号（1.2）决定了你要取得的AutoConfig的版本号。</p></td></tr></table></div><p>然后在命令行上执行如下命令：</p><pre class="screen">mvn dependency:copy</pre></div></div><p>这样就取得了两个文件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">autoconfig-1.2.tgz</code></p></li><li class="listitem"><p><code class="filename">autoexpand-1.2.tgz</code> -
                                    AutoExpand是另一个小工具。它是用来展开war、jar、ear包的。关于AutoExpand的详情，请见<a class="xref" href="#tool.autoexpand" title="第 14 章 AutoExpand工具使用指南">第 14 章 <em>AutoExpand工具使用指南</em></a>。</p></li></ul></div><p>你也可以直接去maven repository中手工下载以上两个包：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://repo1.maven.org/maven2/com/alibaba/citrus/tool/antx-autoconfig/1.2/antx-autoconfig-1.2.tgz" target="_top">http://repo1.maven.org/maven2/com/alibaba/citrus/tool/antx-autoconfig/1.2/antx-autoconfig-1.2.tgz</a></p></li><li class="listitem"><p><a class="link" href="http://repo1.maven.org/maven2/com/alibaba/citrus/tool/antx-autoexpand/1.2/antx-autoexpand-1.2.tgz" target="_top">http://repo1.maven.org/maven2/com/alibaba/citrus/tool/antx-autoexpand/1.2/antx-autoexpand-1.2.tgz</a></p></li></ul></div><p>取得压缩包以后，可以用下面的命令来展开并安装工具。</p><div class="table"><a id="d0e17968"><!--anchor d0e17968--></a><p class="title"><strong>表 13.11. 展开并安装工具</strong></p><div class="table-contents"><table summary="展开并安装工具" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Unix-like系统</th><th style="border-bottom: 0.5pt solid #6666cc; ">Windows系统</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <pre class="screen">tar zxvf autoconfig-1.2.tgz
tar zxvf autoexpand-1.2.tgz
cp autoconfig /usr/local/bin
cp autoexpand /usr/local/bin</pre>
                                </td><td style=""><pre class="screen">tar zxvf autoconfig-1.2.tgz
tar zxvf autoexpand-1.2.tgz
copy autoconfig.exe c:\windows\system32
copy autoexpand.exe c:\windows\system32</pre></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17990"><!--anchor d0e17990--></a>13.4.1.2. 执行AutoConfig命令</h4></div></div></div><p>取得可执行文件以后，就可以试用一下：在命令行上输入<span class="command"><strong>autoconfig</strong></span>。不带参数的<span class="command"><strong>autoconfig</strong></span>命令会显示出如下帮助信息。 </p><div class="example"><a id="d0e18001"><!--anchor d0e18001--></a><p class="title"><strong>例 13.13. AutoConfig的帮助信息</strong></p><div class="example-contents"><pre class="screen">$ <span class="command"><strong>autoconfig</strong></span>
Detected system charset encoding: UTF-8
If your can't read the following text, specify correct one like this: 
  autoconfig -c mycharset

使用方法：autoconfig [可选参数] [目录名|包文件名]
                
可选参数：
 -c,--charset                输入/输出编码字符集
 -d,--include-descriptors
                             包含哪些配置描述文件，例如：conf/auto-config.xml，可使用*、**、?通配符，如有多项，用逗号分隔
 -D,--exclude-descriptors    排除哪些配置描述文件，可使用*、**、?通配符，如有多项，用逗号分隔
 -g,--gui                    图形用户界面（交互模式）
 -h,--help                   显示帮助信息
 -i,--interactive            交互模式：auto|on|off，默认为auto，无参数表示on
 -I,--non-interactive        非交互模式，相当于--interactive=off
 -n,--shared-props-name      共享的属性文件的名称
 -o,--output                 输出文件名或目录名
 -P,--exclude-packages       排除哪些打包文件，可使用*、**、?通配符，如有多项，用逗号分隔
 -p,--include-packages
                             包含哪些打包文件，例如：target/*.war，可使用*、**、?通配符，如有多项，用逗号分隔
 -s,--shared-props           共享的属性文件URL列表，以逗号分隔
 -T,--type                   文件类型，例如：war, jar, ear等
 -t,--text                   文本用户界面（交互模式）
 -u,--userprop               用户属性文件
 -v,--verbose                显示更多信息

总耗费时间：546毫秒</pre></div></div><p>最简单的AutoConfig命令如下：</p><div class="example"><a id="d0e18011"><!--anchor d0e18011--></a><p class="title"><strong>例 13.14. 最简单的AutoConfig命令</strong></p><div class="example-contents"><pre class="screen">autoconfig petstore.war</pre></div></div><p>无论<code class="filename">petstore.war</code>是一个zip包还是目录，AutoConfig都会正确地生成其中的配置文件。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18021"><!--anchor d0e18021--></a>13.4.2. 在maven中使用AutoConfig</h3></div></div></div><p>AutoConfig也可以通过maven plugin来执行。</p><p>这种方式使用方式，方便了开发者试运行并测试应用程序。开发者可以在build项目的同时，把AutoConfig也配置好。然而对于非开发的应用测试人员、发布应用的系统管理员来说，最好的方法是使用独立可执行的AutoConfig来配置应用的二进制目标文件。</p><p>为了使用maven插件，你需要修改项目的<code class="filename">pom.xml</code>来设定它。请注意，一般来说，不要在parent
                    <code class="filename">pom.xml</code>中设定AutoConfig，因为这个设置会作用在每个子项目上，导致不必要的AutoConfig执行。只在生成最终目标文件的子项目<code class="filename">pom.xml</code>中设定AutoConfig就可以了。例如，对于一个web项目，你可以在生成war包的子项目上设置AutoConfig
                plugin。</p><div class="example"><a id="d0e18039"><!--anchor d0e18039--></a><p class="title"><strong>例 13.15. 在pom.xml中设定AutoConfig plugin</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;properties&gt;</strong>
        ...
        <em class="hl-comment" style="color: green">&lt;!-- 定义autoconfig的版本，建议将此行写在parent pom.xml中。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;autoconfig-plugin-version&gt;</strong>1.2<strong class="hl-tag" style="color: #000096">&lt;/autoconfig-plugin-version&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/properties&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.alibaba.citrus.tool<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>autoconfig-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${autoconfig-plugin-version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 要进行AutoConfig的目标文件，默认为${project.artifact.file}。 
                    &lt;dest&gt;${project.artifact.file}&lt;/dest&gt;
                    --&gt;</em>
                    <em class="hl-comment" style="color: green">&lt;!-- 配置后，是否展开目标文件，默认为false，不展开。 
                    &lt;exploding&gt;true&lt;/exploding&gt;
                    --&gt;</em>
                    <em class="hl-comment" style="color: green">&lt;!-- 展开到指定目录，默认为${project.build.directory}/${project.build.finalName}。 
                    &lt;explodedDirectory&gt;
                        ${project.build.directory}/${project.build.finalName}
                    &lt;/explodedDirectory&gt;
                    --&gt;</em>
                <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;phase&gt;</strong>package<strong class="hl-tag" style="color: #000096">&lt;/phase&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>autoconfig<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre></div></div><p>这样，每次执行<code class="code">mvn package</code>或者<code class="code">mvn
                install</code>时，都会激活AutoConfig，对package目标文件进行配置。</p><p>想要避免AutoConfig，只需要一个额外的命令行参数：</p><div class="example"><a id="d0e18054"><!--anchor d0e18054--></a><p class="title"><strong>例 13.16. 避免执行AutoConfig</strong></p><div class="example-contents"><pre class="screen">mvn install <span class="emphasis"><em>–Dautoconfig.skip</em></span></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18061"><!--anchor d0e18061--></a>13.4.3. 运行并观察AutoConfig的结果</h3></div></div></div><p>第一次执行AutoConfig，无论通过何种方式（独立命令行或maven插件），AutoConfig都会提示你修改user
                properties文件，以提供所需要的properties值。AutoConfig提供了一套基于文本的交互式界面来编辑这些properties。</p><div class="example"><a id="d0e18066"><!--anchor d0e18066--></a><p class="title"><strong>例 13.17. 交互式编辑properties</strong></p><div class="example-contents"><pre class="screen">╭───────────────────────┈┈┈┈
│
│ 您的配置文件需要被更新：
│
│ file:/.../<span class="emphasis"><em>antx.properties</em></span>
│
│ 这个文件包括了您个人的特殊设置，
│ 包括服务器端口、您的邮件地址等内容。
│
└───────┈┈┈┈┈┈┈┈┈┈┈

 如果不更新此文件，可能会导致配置文件的内容不完整。
 您需要现在更新此文件吗? [Yes][No] y</pre><p>当你通过交互式界面填写了所有properties的值，并通过了AutoConfig的验证以后，AutoConfig就开始生成配置文件：</p><pre class="screen">即将保存到文件"file:/.../antx.properties"中, 确定? [Yes][No] y

╭───────────────────────┈┈┈┈
│ 保存文件 file:/.../antx.properties...
│┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
│petstore.loggingLevel  = warn
│petstore.loggingRoot   = ${petstore.work}/logs
│petstore.upload        = ${petstore.work}/upload
│petstore.work          = /tmp
└───────┈┈┈┈┈┈┈┈┈┈┈
 已保存至文件: file:/.../antx.properties
Loading file:/.../antx.properties
&lt;jar:file:/.../Work/my/apps/petstore-webx3/target/petstore.war!/&gt;
    <span class="emphasis"><em>Generating WEB-INF/web.xml [UTF-8] =&gt; WEB-INF/web.xml [UTF-8]</em></span>

&lt;jar:file:/.../Work/my/apps/petstore-webx3/target/petstore.war!/&gt;
    <span class="emphasis"><em>Generating WEB-INF/common/resources.xml [UTF-8] =&gt; WEB-INF/common/resources.xml [UTF-8]</em></span>

&lt;jar:file:/.../Work/my/apps/petstore-webx3/target/petstore.war!/&gt;
    <span class="emphasis"><em>Generating log file: META-INF/autoconf/auto-config.xml.log</em></span>

Expanding: /.../Work/my/apps/petstore-webx3/target/petstore.war
       To: /.../Work/my/apps/petstore-webx3/target/petstore
done.</pre><p>假如发现模板中某个placeholder，并未在<code class="filename">auto-config.xml</code>中定义，就会出现以下错误：</p><pre class="screen">ERROR - Undefined placeholders found in template:
- Template:   META-INF/autoconf/WEB-INF/web.xml
- Descriptor: META-INF/autoconf/auto-config.xml
- Base URL:   file:/.../Work/my/apps/petstore-webx3/target/petstore/
---------------------------------------------------------------
-&gt; petstore.loggingRoot
---------------------------------------------------------------</pre></div></div><p>出现错误以后，Maven会报错，并停止build过程。假如你不希望maven停止，可以用下面的命令来执行maven：</p><div class="example"><a id="d0e18096"><!--anchor d0e18096--></a><p class="title"><strong>例 13.18. 避免maven因为placeholder未定义而停止</strong></p><div class="example-contents"><pre class="screen">mvn ... <span class="emphasis"><em>–Dautoconfig.strict=false</em></span></pre></div></div><p>AutoConfig会生成一个日志文件，就在<code class="filename">auto-config.xml</code>所在的目录下，名字为：<code class="filename">auto-config.xml.log</code>。</p><div class="example"><a id="d0e18111"><!--anchor d0e18111--></a><p class="title"><strong>例 13.19. AutoConfig所生成的日志文件</strong></p><div class="example-contents"><pre class="screen">Last Configured at: Fri Jun 18 13:54:22 CST 2010

Base URL: file:/.../Work/my/apps/petstore-webx3/target/petstore/
Descriptor: META-INF/autoconf/auto-config.xml

Generating META-INF/autoconf/WEB-INF/web.xml [UTF-8] =&gt; WEB-INF/web.xml [UTF-8]
Generating META-INF/autoconf/WEB-INF/common/resources.xml [UTF-8] =&gt; WEB-INF/common/resources.xml [UTF-8]</pre></div></div><p>最后，让我们查看一下AutoConfig所生成的文件，其中所有的placeholders应当被替换成你所提供的值了。</p><div class="example"><a id="d0e18118"><!--anchor d0e18118--></a><p class="title"><strong>例 13.20. AutoConfig生成的结果</strong></p><div class="example-contents"><pre class="programlisting">...
<strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingRoot<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>/tmp/logs</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;context-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>loggingLevel<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>warn</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/context-param&gt;</strong>
...
<span class="emphasis"><em>$</em></span>{runtime.placeholder}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18132"><!--anchor d0e18132--></a>13.4.4. 共享properties文件</h3></div></div></div><p>当需要配置的内容越来越多时，即使使用AutoConfig这样的机制，也会变得不胜其烦。</p><p>假如你的项目包含了好几个模块，而你只负责其中的一个模块。一般来说，你对其它模块的配置是什么并不清楚，事实上你也懒得去关心。但是你为了运行这个项目，你不得不去配置这些模块。假如模块A就是一个你不想关心的模块，但为了运行它，你需要告诉模块A一些参数：数据库连接的参数、域名、端口、文件目录、搜索引擎……可你并不清楚这些参数应该取什么值。</p><p>好在AutoConfig提供了一个共享properties文件的方法。 </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18141"><!--anchor d0e18141--></a>13.4.4.1. 共享的properties文件</h4></div></div></div><p>你可以创建一系列文件：<code class="filename">module-a-db.properites</code>，<code class="filename">module-a-searchengine.properties</code>等等。每个文件中都包含了某个运行环境中的关于module
                    A模块的配置参数。</p><p>现在，你可以不关心module A了！你只要使用下面的命令：</p><div class="example"><a id="d0e18154"><!--anchor d0e18154--></a><p class="title"><strong>例 13.21. 指定共享的properties文件</strong></p><div class="example-contents"><pre class="screen">autoconfig <span class="emphasis"><em>-s module-a-db.properties,module-a-searchengine.properties</em></span><a id="co.autoconfig.shared.specifiy"><!--anchor co.autoconfig.shared.specifiy--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> ……</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.specifiy"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">-s</code>参数代表“共享的properties文件”。</p></td></tr></table></div></div></div><p>同时，你的<code class="filename">antx.properties</code>也被简化了，因为这里只会保存你定义的配置项，而不会包含共享的配置项。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18174"><!--anchor d0e18174--></a>13.4.4.2. 共享整个目录</h4></div></div></div><p>假如共享的文件很多的话，AutoConfig还有一个贴心的功能，你可以把这些文件按目录来组织：</p><div class="example"><a id="d0e18179"><!--anchor d0e18179--></a><p class="title"><strong>例 13.22. 按目录组织要被共享的properties文件</strong></p><div class="example-contents"><pre class="screen">shared-properties/
 ├─<span class="emphasis"><em>test/</em></span>                                 // 测试环境的共享配置
 │    module-a-db.properties
 │    module-a-searchengine.properties
 │    module-b.properties
 └─<span class="emphasis"><em>prod/</em></span>                                 // 生产环境的共享配置
       module-a-db.properties
       module-a-searchengine.properties
       module-b.properties</pre></div></div><p>然后，你可以直接在AutoConfig中引用目录：</p><div class="example"><a id="d0e18192"><!--anchor d0e18192--></a><p class="title"><strong>例 13.23. 共享指定目录中的所有properties文件</strong></p><div class="example-contents"><pre class="screen">autoconfig -s <span class="emphasis"><em>shared-propertes/test/</em></span> ……</pre></div></div><p>AutoConfig就会为你装载这个目录下的所有共享配置文件。（注意，<span class="emphasis"><em>目录必须以斜杠“/”结尾</em></span>）</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18205"><!--anchor d0e18205--></a>13.4.4.3. 将共享目录放在http、https或ssh服务器上</h4></div></div></div><p>AutoConfig还支持从http、https或ssh服务器上取得共享配置文件，只需要将前面例子中的文件名改成http或ssh的URI就可以了：</p><div class="example"><a id="d0e18210"><!--anchor d0e18210--></a><p class="title"><strong>例 13.24. 共享远程服务器上的properties文件或目录</strong></p><div class="example-contents"><pre class="screen">autoconfig -s <span class="emphasis"><em>http://share.alibaba.com</em></span>/shared-propertes/test/<a id="co.autoconfig.shared.http"><!--anchor co.autoconfig.shared.http--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> ……
autoconfig -s <span class="emphasis"><em>http://myname@share.alibaba.com</em></span>/shared-propertes/test/<a id="co.autoconfig.shared.http.withuser"><!--anchor co.autoconfig.shared.http.withuser--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> ……
autoconfig -s <span class="emphasis"><em>https://share.alibaba.com</em></span>/shared-propertes/test/<a id="co.autoconfig.shared.https"><!--anchor co.autoconfig.shared.https--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span> ……
autoconfig -s <span class="emphasis"><em>https://myname@share.alibaba.com</em></span>/shared-propertes/test/<a id="co.autoconfig.shared.https.withuser"><!--anchor co.autoconfig.shared.https.withuser--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span> ……
autoconfig -s <span class="emphasis"><em>ssh://myname@share.alibaba.com</em></span>/shared-propertes/test/<a id="co.autoconfig.shared.ssh"><!--anchor co.autoconfig.shared.ssh--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span> ……</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.http"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>共享远程http服务器上的properties文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.http.withuser"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>共享远程http服务器上的properties文件，指定登录用户名。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.https"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>共享远程https服务器上的properties文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.https.withuser"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>共享远程https服务器上的properties文件，指定登录用户名。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.ssh"><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>共享远程ssh服务器上的properties文件，必须指定用户名。</p></td></tr></table></div></div></div><p>由于Subversion、Git服务器是支持HTTP/HTTPS协议的，因此将properties文件存放在Subversion或Git服务器上，也是一个极好的办法。由于采用了Subversion或Git，properties文件的版本管理问题也被一举解决了。</p><p>需要注意的是，访问http和ssh有可能需要验证用户和密码。当需要验证时，AutoConfig会提示你输入用户名和密码。输入以后，密码将被保存在<span class="emphasis"><em><code class="filename">$HOME/passwd.autoconfig</code></em></span>文件中，以后就不需要重复提问了。
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18264"><!--anchor d0e18264--></a>13.4.4.4. 在多种配置项中切换</h4></div></div></div><p>当你使用前文所述的<code class="code">autoconfig
                        –s</code>命令来生成<code class="filename">antx.properties</code>文件时，你会发现<code class="filename">antx.properties</code>中增加了几行特别的内容：</p><div class="example"><a id="d0e18278"><!--anchor d0e18278--></a><p class="title"><strong>例 13.25. 包含共享文件、目录信息的<code class="filename">antx.properties</code>文件</strong></p><div class="example-contents"><pre class="screen">antx.properties.<span class="emphasis"><em>default</em></span>  = http://share.alibaba.com/shared-propertes/test/</pre><p>如果你在<code class="code">-s</code>参数中指定了多项共享properties文件或目录，那么<code class="filename">antx.properties</code>中将会这样：</p><pre class="screen">antx.properties.<span class="emphasis"><em>default.1</em></span>  = http://share.alibaba.com/shared-propertes/test/
antx.properties.<span class="emphasis"><em>default.2</em></span>  = file:/shared-properties/test/my-1.properites
antx.properties.<span class="emphasis"><em>default.3</em></span>  = file:/shared-properties/test/my-2.properites</pre></div></div><p>事实上，AutoConfig还支持多组共享配置，请试用下面的命令：</p><div class="example"><a id="d0e18310"><!--anchor d0e18310--></a><p class="title"><strong>例 13.26. 使用多组共享配置</strong></p><div class="example-contents"><pre class="screen">autoconfig -s http://share.alibaba.com/shared-propertes/test/ <span class="emphasis"><em>-n test</em></span><a id="co.autoconfig.shared.multi.name"><!--anchor co.autoconfig.shared.multi.name--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> ……</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.autoconfig.shared.multi.name"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>为当前共享配置定义一个名字，以后可以用这个名字来简化命令。</p></td></tr></table></div><p>这时，antx.properties就会是这个样子：</p><pre class="screen">antx.properties = <span class="emphasis"><em>test</em></span>
antx.properties.<span class="emphasis"><em>test</em></span> = http://share.alibaba.com/shared-propertes/test/</pre><p>再执行：</p><pre class="screen">autoconfig -s http://share.alibaba.com/shared-propertes/prod/ <span class="emphasis"><em>-n prod</em></span> ……</pre><p>antx.properties就会变成这个样子：</p><pre class="screen">antx.properties = <span class="emphasis"><em>prod</em></span>
antx.properties.test = http://share.alibaba.com/shared-propertes/test/
antx.properties.<span class="emphasis"><em>prod</em></span> = http://share.alibaba.com/shared-propertes/prod/</pre><p>以后再执行，就不需要再指定<code class="code">-s</code>参数了，只需用<code class="code">-n</code>参数选择一组共享properties文件即可。例如：</p><pre class="screen">autoconfig <span class="emphasis"><em>-n prod</em></span><a id="co.autoconfig.shared.multi.prod"><!--anchor co.autoconfig.shared.multi.prod--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span> ……                      // 使用prod生产环境的参数
autoconfig <span class="emphasis"><em>-n test</em></span><a id="co.autoconfig.shared.multi.test"><!--anchor co.autoconfig.shared.multi.test--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span> ……                      // 使用test测试环境的参数
autoconfig <a id="co.autoconfig.shared.multi.last"><!--anchor co.autoconfig.shared.multi.last--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span> ……                             // 不指定，则使用最近一次所选择的共享文件</pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18370"><!--anchor d0e18370--></a>13.4.5. AutoConfig常用命令</h3></div></div></div><p>下面罗列了AutoConfig的常用的命令及参数：</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18375"><!--anchor d0e18375--></a>13.4.5.1. 指定交互式界面的charset</h4></div></div></div><p>一般不需要特别指定charset，除非AutoConfig自动识别系统编码出错，导致显示乱码。</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="screen">autoconfig ... <span class="emphasis"><em>-c GBK</em></span></pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">
                                    <pre class="screen">mvn ... <span class="emphasis"><em>-Dautoconfig.charset=GBK</em></span></pre>
                                </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18405"><!--anchor d0e18405--></a>13.4.5.2. 指定交互模式</h4></div></div></div><p>默认情况下，交互模式为自动（auto）。仅当user
                    properties中的值不满足auto-config.xml中的定义时，才会交互式地引导用户提供properties值。</p><p>但你可以强制打开交互模式： </p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="screen">autoconfig ... <span class="emphasis"><em>–i</em></span>
autoconfig ... <span class="emphasis"><em>–i on</em></span></pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">
                                    <pre class="screen">mvn ... <span class="emphasis"><em>-Dautoconfig.interactive</em></span>
mvn ...  <span class="emphasis"><em>-Dautoconfig.interactive=true</em></span></pre>
                                </td></tr></tbody></table></div><p>或强制关闭交互模式：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="screen">autoconfig ... <span class="emphasis"><em>–I</em></span>
autoconfig ... <span class="emphasis"><em>–i off</em></span></pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">
                                    <pre class="screen">mvn ...  <span class="emphasis"><em>-Dautoconfig.interactive=false</em></span></pre>
                                </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18473"><!--anchor d0e18473--></a>13.4.5.3. 指定user properties</h4></div></div></div><p>默认情况下，AutoConfig会按下列顺序查找user properties：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="filename">当前目录/antx.properties</code></p></li><li class="listitem"><p><code class="filename">当前用户HOME目录/antx.properties</code>
                            </p></li></ol></div><p>但你可以指定一个自己的properties文件，用下面的命令：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="screen">autoconfig ... <span class="emphasis"><em>–u my.props</em></span></pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">
                                    <pre class="screen">mvn ... <span class="emphasis"><em>-Dautoconfig.userProperties=my.props</em></span></pre>
                                </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18515"><!--anchor d0e18515--></a>13.4.5.4. 显示详细的信息</h4></div></div></div><p>默认情况下，AutoConfig只输出重要的信息，但有时你想了解更多内部的情况，只需要用下面的命令：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="screen">autoconfig ... <span class="emphasis"><em>–v</em></span></pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">不适用</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18540"><!--anchor d0e18540--></a>13.4.5.5. 指定输出文件</h4></div></div></div><p>默认情况下，AutoConfig所生成的配置文件以及日志信息会直接输出到当前包文件或目录中。例如以下命令会改变<code class="filename">petstore.war</code>的内容：</p><pre class="screen">autoconfig petstore.war</pre><p>但你可以指定另一个输出文件或目录，这样，原来的文件或目录就不会被修改：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="screen">autoconfig petstore.war <span class="emphasis"><em>–o petstore-configured.war</em></span></pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">不适用</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18572"><!--anchor d0e18572--></a>13.4.5.6. 避免执行AutoConfig</h4></div></div></div><p>将AutoConfig和maven package
                    phase绑定以后，每次build都会激活AutoConfig。假如你想跳过这一步，只需要下面的命令：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">不适用</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">
                                    <pre class="screen">mvn ... <span class="emphasis"><em>-Dautoconfig.skip</em></span></pre>
                                </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e18597"><!--anchor d0e18597--></a>13.4.5.7. 避免中断maven build</h4></div></div></div><p>默认情况下，假如发现有未定义的placeholders，AutoConfig会报错并中止maven的执行。假如你不想中断maven
                    build，可以这样做：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">运行AutoConfig独立可执行程序</td><td style="border-bottom: 0.5pt solid #6666cc; ">不适用</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">运行AutoConfig maven插件</td><td style="">
                                    <pre class="screen">mvn ... <span class="emphasis"><em>-Dautoconfig.strict=false</em></span></pre>
                                </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e18622"><!--anchor d0e18622--></a>13.5. 本章总结</h2></div></div></div><p>AutoConfig是一个简单而有用的小工具，弥补了Maven Filtering及类似机制的不足。但它还有不少改进的余地。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>界面不够直观。如果能够通过GUI或WEB界面来配置，就更好了。</p></li><li class="listitem"><p>Properties validator目前不易扩展。</p></li><li class="listitem"><p>缺少集成环境的支持。</p></li></ul></div></div></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="tool.autoexpand"><!--anchor tool.autoexpand--></a>第 14 章 AutoExpand工具使用指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e18641">14.1. AutoExpand工具简介</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18646">14.1.1. Java、JavaEE打包的格式</a></span></dt><dt><span class="section"><a href="#d0e18704">14.1.2. 应用部署的方式</a></span></dt><dt><span class="section"><a href="#d0e18741">14.1.3. AutoExpand的用武之地</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18791">14.2. AutoExpand的使用</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e18794">14.2.1. 取得AutoExpand</a></span></dt><dt><span class="section"><a href="#d0e18801">14.2.2. 执行AutoExpand</a></span></dt><dt><span class="section"><a href="#d0e18870">14.2.3. AutoExpand和AutoConfig的合作</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e18884">14.3. AutoExpand的参数</a></span></dt><dt><span class="section"><a href="#d0e19001">14.4. 本章总结</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e18641"><!--anchor d0e18641--></a>14.1. AutoExpand工具简介</h2></div></div></div><p>AutoExpand是一个小工具，可以快速地把应用包展开到目录中。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18646"><!--anchor d0e18646--></a>14.1.1. Java、JavaEE打包的格式</h3></div></div></div><p>Java和JavaEE的应用通常被打成一个ZIP格式的包。</p><div class="table"><a id="d0e18651"><!--anchor d0e18651--></a><p class="title"><strong>表 14.1. 标准的Java、JavaEE包的格式</strong></p><div class="table-contents"><table summary="标准的Java、JavaEE包的格式" cellpadding="10" style="border: none;"><colgroup><col width="15%" class="c1"/><col width="85%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">包类型</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">jar</td><td style="border-bottom: 0.5pt solid #6666cc; ">Java ARchive。共享类库，EJB，独立应用。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">war</td><td style="border-bottom: 0.5pt solid #6666cc; ">Web application ARchive。WEB应用。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">ear</td><td style="border-bottom: 0.5pt solid #6666cc; ">Enterprise ARchive。企业级应用。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">rar</td><td style="">Resource Adapter Archive。</td></tr></tbody></table></div></div><p>其中jar和war包是当今最常用的格式。其次还有ear。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Ear包中可以包含多个jar包（包括ejb-jar包）、rar包、war包。</p></li><li class="listitem"><p>War包中可以包含多个jar包。</p></li></ul></div><div class="example"><a id="d0e18693"><!--anchor d0e18693--></a><p class="title"><strong>例 14.1. 包的内部格式</strong></p><div class="example-contents"><p>下面是一个典型的ear包的内部格式：</p><pre class="screen">myapp.ear
 │  foo-ejb.jar            // 内嵌ejb-jar包。
 │  bar.jar                // 内嵌普通jar包。
 │  myweb.war              // 内嵌war包。
 │
 └─META-INF
       application.xml     // EAR描述文件。</pre><p>下面是一个典型的war包的内部格式：</p><pre class="screen">myweb.war
 │  index.jsp
 │
 ├─images
 ├─META-INF
 └─WEB-INF
    │  web.xml             // WAR描述文件。
    │
    ├─classes
    │     foo.class        // Java类文件。
    │
    └─lib
          bar.jar          // 内嵌jar包。
          baz.jar</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18704"><!--anchor d0e18704--></a>14.1.2. 应用部署的方式</h3></div></div></div><p>多数应用服务器都支持两种类型的部署方式：以包的形式部署，或者以展开目录的形式部署。</p><div class="table"><a id="d0e18709"><!--anchor d0e18709--></a><p class="title"><strong>表 14.2. 部署应用的方法</strong></p><div class="table-contents"><table summary="部署应用的方法" cellpadding="10" style="border: none;"><colgroup><col width="30%" class="c1"/><col width="70%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">方法</th><th style="border-bottom: 0.5pt solid #6666cc; ">用途</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">以包的形式部署</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                <p>你可以把WEB应用的war包直接发布在应用服务器上，应用服务器不需要把包打开就能运行它。</p>
                                <p>发布一个应用包（只有一个文件），对于deployer来说是比较方便的。通常他只需要把这个包往指定的应用服务器目录一丢，就可以把应用跑起来。</p>
                                <p>但是以包形式发布的应用不太好调试，因为你为了修改包中的任何一个文件，都必须重新打包。这是很费时的工作。</p>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">以展开目录的形式部署</td><td style="">以展开目录的形式部署的应用，更适合于开发阶段。这样，开发者可以方便地替换应用中的任何一个文件，而不需要重新打包。这节省了很多时间。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18741"><!--anchor d0e18741--></a>14.1.3. AutoExpand的用武之地</h3></div></div></div><p>AutoExpand的功能就是把包文件展开到文件夹中。</p><p>事实上，对于多数情况来说，用AutoExpand来展开一个包，和直接使用<span class="command"><strong>jar</strong></span>命令来展开包是没有差别的。例如，展开一个war包，可以用下面两种方法：</p><div class="example"><a id="d0e18751"><!--anchor d0e18751--></a><p class="title"><strong>例 14.2. 用AutoExpand展开一个war包</strong></p><div class="example-contents"><pre class="screen">$ <span class="command"><strong>autoexpand</strong></span> myweb.war 
Detected system charset encoding: UTF-8
If your can't read the following text, specify correct one like this: 
  autoexpand -c mycharset

Expanding: /.../myweb.war
       To: /.../myweb
done.

总耗费时间：762毫秒</pre></div></div><div class="example"><a id="d0e18759"><!--anchor d0e18759--></a><p class="title"><strong>例 14.3. 用<span class="command">jar</span>命令展开一个war包</strong></p><div class="example-contents"><pre class="screen">$ <span class="command"><strong>mkdir</strong></span> myweb
$ <span class="command"><strong>cd</strong></span> myweb
$ <span class="command"><strong>jar</strong></span> xvf ../myweb.war
  创建：META-INF/
  解压 META-INF/MANIFEST.MF
  ...</pre></div></div><p>但是使用AutoExpand有如下好处：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>可展开嵌套的包，例如：一个ear中包含war包，用AutoExpand可以一举把它们同时展开。</p></li><li class="listitem"><p>支持更多选项，例如：更新、覆盖、删除多余文件等。</p></li><li class="listitem"><p>比<span class="command"><strong>jar</strong></span>命令速度更快。</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e18791"><!--anchor d0e18791--></a>14.2. AutoExpand的使用</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18794"><!--anchor d0e18794--></a>14.2.1. 取得AutoExpand</h3></div></div></div><p>请参考<a class="xref" href="#tool.autoconfig.getbinary" title="13.4.1.1. 取得可执行文件">第 13.4.1.1 节 “取得可执行文件”</a>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18801"><!--anchor d0e18801--></a>14.2.2. 执行AutoExpand</h3></div></div></div><p>直接输入<span class="command"><strong>autoexpand</strong></span>可得到如下帮助信息。</p><div class="example"><a id="d0e18809"><!--anchor d0e18809--></a><p class="title"><strong>例 14.4. AutoExpand的帮助信息</strong></p><div class="example-contents"><pre class="screen">$ <span class="command"><strong>autoexpand</strong></span>
Detected system charset encoding: UTF-8
If your can't read the following text, specify correct one like this: 
  autoexpand -c mycharset

使用方法：antxexpand [可选参数] 文件名 [目标目录]
                
可选参数：
 -c,--charset                 输入/输出编码字符集
 -e,--expand-ejb-jar          是否展开ejb-jar（yes|no），默认为no
 -h,--help                    显示帮助信息
 -k,--keep-redundant-files    如果目标目录中有多余的文件，是否保持而不删除，默认为no
 -o,--overwrite               如果目标目录中的文件比zip文件中的项要新，是否覆盖之，默认为no
 -r,--expand-rar              是否展开rar（yes|no），默认为yes
 -v,--verbose                 显示更多信息
 -w,--expand-war              是否展开war（yes|no），默认为yes

总耗费时间：203毫秒</pre></div></div><p>最简单的AutoExpand命令如下：</p><div class="example"><a id="d0e18819"><!--anchor d0e18819--></a><p class="title"><strong>例 14.5. 最简单的AutoExpand命令</strong></p><div class="example-contents"><pre class="screen">autoexpand myweb.war</pre></div></div><p>这条命令将<code class="filename">myweb.war</code>展开到<code class="filename">myweb</code>目录中。</p><p>你也可以指定一个输出目录：</p><div class="example"><a id="d0e18834"><!--anchor d0e18834--></a><p class="title"><strong>例 14.6. 执行AutoExpand命令：指定输出目录</strong></p><div class="example-contents"><pre class="screen">autoexpand myweb.war myweb-expanded.war</pre></div></div><p>这条命令将<code class="filename">myweb.war</code>展开到<code class="filename">myweb-expanded.war</code>目录中。<span class="emphasis"><em>在目录名中指定后缀（如<code class="code">.war</code>）是一个好主意</em></span>。这样，同一个名称（<code class="code">*.war</code>）既可作为目录名，也可作为包名。你可以在目录和包文件之间自由地切换，而不需要改动服务器的脚本或配置。</p><p>你可以用一条命令展开嵌套的包。例如：</p><div class="example"><a id="d0e18858"><!--anchor d0e18858--></a><p class="title"><strong>例 14.7. 执行AutoExpand命令：展开嵌套的包</strong></p><div class="example-contents"><pre class="screen">autoexpand myapp.ear myapp-expanded.ear</pre></div></div><p>这条命令可以一举把ear以及ear中的所有war都展开。</p><div class="example"><a id="d0e18865"><!--anchor d0e18865--></a><p class="title"><strong>例 14.8. 展开ear以及ear中的所有war</strong></p><div class="example-contents"><pre class="screen">myapp-expanded.ear
│  foo-ejb.jar
│  bar.jar
│
├─myweb.war        // 展开嵌套的war
│  │  index.jsp
│  │
│  ├─images
│  ├─META-INF
│  └─WEB-INF
│     │  web.xml
│     │
│     ├─classes
│     │     foo.class
│     │
│     └─lib
│           bar.jar
│           baz.jar
│
└─META-INF
      application.xml</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e18870"><!--anchor d0e18870--></a>14.2.3. AutoExpand和AutoConfig的合作</h3></div></div></div><p>你可以让AutoConfig maven插件在配置完应用以后，将应用展开到指定的目录。</p><div class="example"><a id="d0e18875"><!--anchor d0e18875--></a><p class="title"><strong>例 14.9. AutoConfig完成后，再用AutoExpand展开</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;project</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;properties&gt;</strong>
        ...
        <em class="hl-comment" style="color: green">&lt;!-- 定义autoconfig的版本，建议将此行写在parent pom.xml中。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;autoconfig-plugin-version&gt;</strong>1.2<strong class="hl-tag" style="color: #000096">&lt;/autoconfig-plugin-version&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/properties&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;build&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;plugins&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;plugin&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>com.alibaba.citrus.tool<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>autoconfig-maven-plugin<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>${autoconfig-plugin-version}<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;configuration&gt;</strong>
                    ...
                    <em class="hl-comment" style="color: green">&lt;!-- 配置后，是否展开目标文件，默认为false，不展开。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;exploding&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/exploding&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 展开到指定目录，默认为${project.build.directory}/${project.build.finalName}。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;explodedDirectory&gt;</strong>
                        ${project.build.directory}/${project.build.finalName}
                    <strong class="hl-tag" style="color: #000096">&lt;/explodedDirectory&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/configuration&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;executions&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;execution&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;phase&gt;</strong>package<strong class="hl-tag" style="color: #000096">&lt;/phase&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;goals&gt;</strong>
                            <strong class="hl-tag" style="color: #000096">&lt;goal&gt;</strong>autoconfig<strong class="hl-tag" style="color: #000096">&lt;/goal&gt;</strong>
                        <strong class="hl-tag" style="color: #000096">&lt;/goals&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;/execution&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/executions&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/plugin&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/plugins&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/build&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/project&gt;</strong></pre></div></div><p>关于AutoConfig详情，请看<a class="xref" href="#tool.autoconfig" title="第 13 章 AutoConfig工具使用指南">第 13 章 <em>AutoConfig工具使用指南</em></a>。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e18884"><!--anchor d0e18884--></a>14.3. AutoExpand的参数</h2></div></div></div><p>AutoExpand可用的参数包括：</p><div class="table"><a id="d0e18889"><!--anchor d0e18889--></a><p class="title"><strong>表 14.3. AutoExpand命令的参数</strong></p><div class="table-contents"><table summary="AutoExpand命令的参数" cellpadding="10" style="border: none;"><colgroup><col width="28%" class="c1"/><col width="72%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">-w</code> 或 <code class="code">--expand-war</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>是否展开war（yes或no），默认为yes。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">-r</code> 或 <code class="code">--expand-rar</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>是否展开rar（yes或no），默认为yes。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">-e</code> 或 <code class="code">--expand-ejb-jar</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>是否展开ejb-jar（yes或no），默认为no。</p>
                            <p>展开ejb-jar需要读取<code class="filename">/META-INF/application.xml</code>文件，因此会降低展开的速度。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">-o</code> 或 <code class="code">--overwrite</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>如果目标目录中的文件比包文件中的项要新，是否覆盖之，默认为no。</p>
                            <p>指定该参数可强制覆盖文件。</p>
                            <p>如果你不信任文件中的时间戳，就可以指定这个参数。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">-k</code> 或 <code class="code">--keep-redundant-files</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>如果目标目录存在多余的文件（也就是包里不存在的文件），AutoExpand会将它们删除，以确保展开后的目录内容与包的内容完全一致，不多不少。</p>
                            <p>指定这个参数可以避免AutoExpand删除多余的文件。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">-v</code> 或 <code class="code">--verbose</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">
                            <p>显示更多信息。</p>
                        </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">-c</code> 或 <code class="code">--charset</code></td><td style="">
                            <p>如果AutoExpand显示的信息是乱码，请通过这个参数指定正确的字符集编码。</p>
                        </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e19001"><!--anchor d0e19001--></a>14.4. 本章总结</h2></div></div></div><p>AutoExpand虽然小，但很好用，可以作为<span class="command"><strong>jar</strong></span>命令部分功能的替代品。此外，AutoConfig也利用AutoExpand来展开经过配置的包文件。</p></div></div></div></div></body></html>