<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>第 6 章 Filter、Request Contexts和Pipeline</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="home" href="index.html" title="Webx框架指南"/><link rel="up" href="pt02.html" title="部分 II. Webx基础设施服务"/><link rel="prev" href="resourceloading.html" title="第 5 章 Resource Loading服务指南"/><link rel="next" href="requestcontexts.html" title="第 7 章 Request Contexts功能指南"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 6 章 Filter、Request Contexts和Pipeline</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="resourceloading.html">上一页</a> </td><th width="60%" align="center">部分 II. Webx基础设施服务</th><td width="20%" align="right"> <a accesskey="n" href="requestcontexts.html">下一页</a></td></tr></table><hr/></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.filter.requestcontexts.pipeline"><!--anchor webx.filter.requestcontexts.pipeline--></a>第 6 章 Filter、Request Contexts和Pipeline</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="filter.html#d0e4894">6.1. Filter</a></span></dt><dd><dl><dt><span class="section"><a href="filter.html#d0e4897">6.1.1. Filter的用途</a></span></dt><dt><span class="section"><a href="filter.html#d0e4957">6.1.2. Filter工作原理</a></span></dt><dt><span class="section"><a href="filter.html#d0e5017">6.1.3. Filter的限制</a></span></dt><dt><span class="section"><a href="filter.html#d0e5045">6.1.4. Webx对filter功能的补充</a></span></dt></dl></dd><dt><span class="section"><a href="filter.html#d0e5103">6.2. Request Contexts服务</a></span></dt><dd><dl><dt><span class="section"><a href="filter.html#d0e5106">6.2.1. Request Contexts工作原理</a></span></dt><dt><span class="section"><a href="filter.html#d0e5148">6.2.2. Request Contexts的用途</a></span></dt><dt><span class="section"><a href="filter.html#d0e5217">6.2.3. Request Contexts的使用</a></span></dt></dl></dd><dt><span class="section"><a href="filter.html#d0e5451">6.3. Pipeline服务</a></span></dt><dd><dl><dt><span class="section"><a href="filter.html#d0e5454">6.3.1. Pipeline工作原理</a></span></dt><dt><span class="section"><a href="filter.html#d0e5477">6.3.2. Pipeline的用途</a></span></dt><dt><span class="section"><a href="filter.html#d0e5490">6.3.3. Pipeline的使用</a></span></dt></dl></dd><dt><span class="section"><a href="filter.html#d0e6044">6.4. 本章总结</a></span></dt></dl></div><p>Filter是Servlet规范2.3版及更新版所支持的一种机制。和Servlet/JSP不同，Filter自己往往不会直接产生response，相反，它提供了一种“符加”的功能，可以作用在任何一个servlet、JSP以及其它filter之上。然而，在实际的应用中，我们发现filter有很多不足之处。</p><p>Webx框架提供了两种机制（Request
        Contexts和Pipeline）来作为filter机制的补充。在大多数情况下，它们都可以实现类似filter的功能，但比filter更容易扩展、更容易配置、也更轻量。Webx并没有打算完全替代filter，相反它还是可以和任何filter搭配使用。</p><p>本章先简略介绍filter的功能和不足，再向你介绍Request Contexts和Pipeline的工作原理，及使用方法。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e4894"><!--anchor d0e4894--></a>6.1. Filter</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4897"><!--anchor d0e4897--></a>6.1.1. Filter的用途</h3></div></div></div><p>Filter这种机制常被用来实现下面的功能：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="19%" class="c1"/><col width="81%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">页面授权</td><td style="border-bottom: 0.5pt solid #6666cc; ">根据登录用户的权限，阻止或许可用户访问特定的页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">日志和审计</td><td style="border-bottom: 0.5pt solid #6666cc; ">记录和检查用户访问WEB应用的情况。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">图片转换</td><td style="border-bottom: 0.5pt solid #6666cc; ">改变图片的格式、精度、尺寸等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">页面压缩</td><td style="border-bottom: 0.5pt solid #6666cc; ">压缩页面内容，加快下载速度。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">本地化</td><td style="border-bottom: 0.5pt solid #6666cc; ">显示本地语言和风格的页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">XSLT转换</td><td style="border-bottom: 0.5pt solid #6666cc; ">对XML内容进行XSLT转换，使之适用于多种客户端。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">高速缓存</td><td style="">高速缓存页面，提高响应速度。</td></tr></tbody></table></div><p>当然还有更多种的应用，我们不可能一一列举。</p><p>Filter的通用性很好。任何filter均独立于其它filter和servlet，因此它可以和任意其它filter和servlet组合搭配。下面是一段配置示例
                ── 通过<code class="code">SetLoggingContextFilter</code>，日志系统可以记录当前请求的信息，例如：URL、referrer URL、query
                string等。</p><div class="example"><a id="d0e4949"><!--anchor d0e4949--></a><p class="title"><strong>例 6.1. Filter配置示例（<code class="filename">/WEB-INF/web.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>mdc<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-class&gt;</strong>com.alibaba.citrus.webx.servlet.SetLoggingContextFilter<strong class="hl-tag" style="color: #000096">&lt;/filter-class&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filter-mapping&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>mdc<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url-pattern&gt;</strong>/*<strong class="hl-tag" style="color: #000096">&lt;/url-pattern&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter-mapping&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4957"><!--anchor d0e4957--></a>6.1.2. Filter工作原理</h3></div></div></div><div class="figure"><a id="d0e4960"><!--anchor d0e4960--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/filter-chain.png" alt="Filter Chain"/></div></div><p class="title"><strong>图 6.1. Filter Chain</strong></p></div><p>如图所示。多个filter和至多一个servlet被串联成一个链，被称为Filter
                    Chain。执行的时候，引擎将控制权交给链条中的头一个filter（如果有的话）。然后，就像<span class="emphasis"><em>击鼓传花</em></span>一样，控制权被依次传递给filter chain中的下一个filter或servlet。每一个得到控制权的filter可以做下面的事：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>继续传递控制权或立即终止filter chain。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Filter可将控制权传递给链条中的下一个filter或者最终的servlet。</p></li><li class="listitem"><p>Filter也可以不将控制权传递给下一个filter或servlet，这样便中止了整个filter
                                        chain的执行。</p></li></ul></div></li><li class="listitem"><p>预处理。在传递控制权给下一个filter或servlet之前，filter可以预先做一些事情：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>设置request、response中的参数，例如：character encoding、content
                                        type等。</p></li><li class="listitem"><p>将<code class="code">HttpServletRequestWrapper</code>传递给链条中的下一位，filter可以通过wrapper改变request中的任意值。</p></li><li class="listitem"><p>将<code class="code">HttpServletResponseWrapper</code>传递给链条中的下一位，filter可以通过wrapper来拦截后续filter或servlet对response的修改。</p></li></ul></div></li><li class="listitem"><p>提交。在控制权从filter chain中返回以后，filter还可以做一些后续提交的操作。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>例如，将response中拦截而来的数据，压缩或转换格式，并发送给客户端或filter
                                        chain的上一级。</p></li><li class="listitem"><p>通过<code class="code">try</code>、<code class="code">catch</code>还可以捕获filter
                                        chain下一级所有的异常，并做处理。 </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5017"><!--anchor d0e5017--></a>6.1.3. Filter的限制</h3></div></div></div><p>Filter是很有用的。作为servlet的补充，filter也是很成功的。但是filter并没有被设计用来完成一切事情。事实上，filter的设计限制了filter的用途。每个filter具有下面的限制：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Filter可以访问和修改数据。但它只能访问和修改<code class="code">HttpServletRequest</code>、<code class="code">HttpServletResponse</code>、<code class="code">ServletContext</code>等容器级的对象，而不能（或很难）访问应用程序中的状态。所以filter无法实现和应用逻辑密切相关的功能。</p></li><li class="listitem"><p>Filter可以影响执行流程。但它不能改变filter chain的结构和顺序。Filter
                                chain的结构和顺序是由<code class="filename">web.xml</code>中定义的。当filter得到控制权以后，它只能选择继续下去，或者立即结束，而没法进行循环、分支、条件判断等更复杂的控制。因此，filter只能用来实现粗粒度的流程控制功能（例如，当用户未获授权时，停止执行filter
                            chain），难以应付更细致的应用程序内的控制需求。</p></li><li class="listitem"><p>Filter与其它filter和servlet之间，除了request和response对象以外，无法共享其它的状态。这既是优点又是缺点。优点是使filter更独立、更通用；缺点是filter与其它filter、servlet之间难以协作，有时甚至会引起无谓的性能损失。</p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5045"><!--anchor d0e5045--></a>6.1.4. Webx对filter功能的补充</h3></div></div></div><p>综上所述，一个filter常常做的两件事是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>改变request/response对象（通过<code class="code">HttpServletRequestWrapper</code>和<code class="code">HttpServletResponseWrapper</code>）；</p></li><li class="listitem"><p>改变应用执行的流程。</p></li></ul></div><p>其实，大部分filter只做其中一件事。例如：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>页面压缩filter仅仅改变response，并不改变应用的流程。</p></li><li class="listitem"><p>页面授权filter根据当前请求用户的身份，判定他是否有权限访问当前页面。这个filter会影响应用流程，却不会去改变request和response。
                        </p></li></ul></div><p>当然也有例外。有一些filter不做上面两件事中任何一件。例如，日志filter仅仅读取request对象并记录日志而已，既不改变request/response，也不影响应用的流程。还有一些filter同时做上面两件事。比如高速缓存页面的filter不仅要修改response，而且当cache被命中时，不再执行下一步的流程，而是直接返回cache中的内容，以提高性能。</p><p>Webx框架提供了两个服务，正好吻合了上述两个最常用的filter的功能。</p><div class="informaltable"><table cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Request Contexts服务</td><td style="border-bottom: 0.5pt solid #6666cc; ">该服务负责访问和修改request和response，但不负责改变应用执行的流程。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Pipeline服务</td><td style="">提供应用执行的流程，但不关心request和response。</td></tr></tbody></table></div><p>虽然这两个服务看起来和filter的功能类似，但是它们远比filter要强大和方便 ── 它们克服了上述filter的几个限制：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>和Filter不同，Request Contexts和Pipeline服务可以访问应用内部的状态和资源，效率更高，功能更强。</p></li><li class="listitem"><p>和Filter不同，Pipeline服务可以定义灵活（但仍然简单）地控制应用的流程
                            。Pipeline不仅可以控制流程的中断或继续，还可以实现子流程、循环、条件转移、异常处理等更精细的流程控制。Pipeline服务甚至可以运用在非WEB的环境中。</p></li><li class="listitem"><p>和Filter不同，Request Contexts服务中的每一个环节（Request
                            Context）之间并非完全独立、互不干涉的。每个request context可以访问它所依赖的其它request
                            context中的状态。</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e5103"><!--anchor d0e5103--></a>6.2. Request Contexts服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5106"><!--anchor d0e5106--></a>6.2.1. Request Contexts工作原理</h3></div></div></div><p>Request Context，顾名思义，就是一个请求的上下文。事实上，你可以把Request
                    Context看作是<code class="code">HttpServletRequest</code>和<code class="code">HttpServletResponse</code>这两个对象的总和。除此之外，多个Request
                Context可以被串接起来，被称为Request Context Chain，类似于filter chain。</p><div class="figure"><a id="d0e5117"><!--anchor d0e5117--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/request-context-chain.png" alt="Request Context Chain"/></div></div><p class="title"><strong>图 6.2. Request Context Chain</strong></p></div><p>如上图所示，每一个Request Context都可以包括两个基本的操作：“预处理”和“提交”。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>在一个请求开始的时候，每个Request Context的“预处理”过程被依次调用。最内层的（即最先的）Request
                            Context最先被调用，最外层的（即最后的）Request Context最后被调用；</p></li><li class="listitem"><p>在一个请求结束的时候，每个Request Context的“提交”过程被依次调用。和“预处理”的顺序相反，最外层的（即最后的）Request
                            Context最先被调用，最内层的（即最先的）Request Context最后被调用。</p></li></ul></div><p>Request
                    Context在预处理的时候，可以利用<code class="code">HttpServletRequestWrapper</code>和<code class="code">HttpServletResponseWrapper</code>来包装和修改request和response
                ── 这一点和filter相同。每一层Request Context，都会增加一个新的特性。最先的Request Context成为最内层的包装，最后的Request
                Context成为最外层的包装。如下图所示。</p><div class="figure"><a id="d0e5140"><!--anchor d0e5140--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/request-contexts.png" alt="Request Contexts的嵌套"/></div></div><p class="title"><strong>图 6.3. Request Contexts的嵌套</strong></p></div><p>和filter原理中的图进行对比，你会发现，尽管Request Contexts和Filter的执行方案有明显的不同，但是Request
                Contexts预处理和提交的顺序是和filter
                chain完全一致的。预处理时，由内层执行到外层；提交时，反过来由外层执行到内层。不同的是，filter能够决定是否继续传递控制权给filter
                chain中的下一位，而Request Context则没有这个权利。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5148"><!--anchor d0e5148--></a>6.2.2. Request Contexts的用途</h3></div></div></div><p>Webx目前提供了以下几种request context的实现，每个都有独特的功能。</p><div class="table"><a id="d0e5153"><!--anchor d0e5153--></a><p class="title"><strong>表 6.1. Request Contexts的功能</strong></p><div class="table-contents"><table summary="Request Contexts的功能" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">功能</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;basic&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">提供基础安全特性，例如：过滤response headers、cookies，限制cookie的大小等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;buffered&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">缓存response中的内容。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;lazy-commit&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">延迟提交response。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;parser&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">解析参数，支持multipart/form-data（即上传文件请求）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;rewrite&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">重写请求的URL和参数。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;session&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">一套可扩展的session框架，重新实现了HttpSession接口。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;set-locale&gt;</code></td><td style="" valign="middle">设置locale区域和charset字符集编码。</td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>本章对以上所有的request contexts的功能和用法不作具体的介绍，详情请参阅<a class="xref" href="requestcontexts.html" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>和<a class="xref" href="session.html" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>。</p></td></tr></table></div><p>需要特别指出的是，你还可以扩展出更多的Request Context，以实现新的功能。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5217"><!--anchor d0e5217--></a>6.2.3. Request Contexts的使用</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5220"><!--anchor d0e5220--></a>6.2.3.1. 配置</h4></div></div></div><p>除了下面例子所示的一段配置之外，你不需要做太多的事，就可以使用Request Contexts。因为Request Contexts对于应用来说是透明的
                    ──
                    多数应用只需要依赖于<code class="code">HttpServletRequest</code>和<code class="code">HttpServletResponse</code>就可以了。</p><div class="example"><a id="d0e5231"><!--anchor d0e5231--></a><p class="title"><strong>例 6.2. Request Context的配置（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:request-contexts</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
                http://localhost:8080/schema/services.xsd
        http://www.alibaba.com/schema/services/request-contexts
                http://localhost:8080/schema/services-request-contexts.xsd
        http://www.springframework.org/schema/beans
                http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...

    <strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <em class="hl-comment" style="color: green">&lt;!-- Optional -
        &lt;session /&gt;
        &lt;rewrite /&gt;
        --&gt;</em>
    <strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre></div></div><p>由于使用了SpringExt的schema机制，所以在支持schema的XML编辑器的帮助下，很容易书写和验证Request
                    Contexts的配置。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5241"><!--anchor d0e5241--></a>6.2.3.2. 排序</h4></div></div></div><p>Request Contexts之间，有时会有依赖关系，所以Request Contexts出现的先后顺序是非常重要的。例如，</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">&lt;session&gt;</code>提供了基于cookie的session支持。然而cookie属于response
                                    header。一旦response被提交，header就无法再修改了。因此<code class="code">&lt;session&gt;</code>依赖于<code class="code">&lt;lazy-commit&gt;</code>，以阻止response过早提交。也就是说，<code class="code">&lt;lazy-commit&gt;</code>必须排在<code class="code">&lt;session&gt;</code>之前。</p></li><li class="listitem"><p><code class="code">&lt;rewrite&gt;</code>需要访问参数，而参数是能过<code class="code">&lt;parser&gt;</code>解析的，所以<code class="code">&lt;parser&gt;</code>要排在<code class="code">&lt;rewrite&gt;</code>之前。</p></li></ul></div><p>类似的约束还有很多。如果把Request
                    Contexts的顺序排错，可能会导致某项功能错误或失效。然而，对于一般的应用开发者而言，这些约束往往是神秘的、并非显而易见的，需要经过细致地分析才能了解它们。</p><p>好在Request Contexts内部提供了一个机制，可以根据预定义的约束条件，对所有的Request
                    Contexts进行自动排序。和Filter不同，应用开发者不需要在意Request Contexts在配置文件中的排列顺序，就可以保证所有的Request
                    Contexts能够正常工作。下面的两种配置文件是等效的：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <div class="example"><a id="d0e5290"><!--anchor d0e5290--></a><p class="title"><strong>例 6.3. Request Contexts等效配置1</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;rewrite /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div>
                                </td><td style="">
                                    <div class="example"><a id="d0e5298"><!--anchor d0e5298--></a><p class="title"><strong>例 6.4. Request Contexts等效配置2</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;rewrite /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;session /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div>
                                </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5304"><!--anchor d0e5304--></a>6.2.3.3. 访问特定的Request Context</h4></div></div></div><p>一般来说，Request Contexts对于应用程序是透明的 ── 也就是说，应用程序最多只需要访问Servlet
                        API中的接口：<code class="code">HttpServletRequest</code>和<code class="code">HttpServletResponse</code>即可，就好像Request
                    Contexts不存在一样。</p><p>比如，Request Context
                        <code class="code">&lt;parser&gt;</code>能够解析<code class="code">multipart/form-data</code>类型的请求（即上传图片请求）。但你不需要用另一个API来访问请求中的普通数据，你只需要用<code class="code">HttpServletRequest</code>中定义的方法就可以访问，仿佛这是一个普通的请求：</p><div class="example"><a id="d0e5326"><!--anchor d0e5326--></a><p class="title"><strong>例 6.5. 访问任意类型的请求中的参数</strong></p><div class="example-contents"><pre class="programlisting">String value = request.getParameter(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div><p>再比如，Request Context
                    <code class="code">&lt;session&gt;</code>重新实现了<code class="code">HttpSession</code>的接口，但是应用程序并不需要关心这些，他们还是和原来一样访问session：</p><div class="example"><a id="d0e5339"><!--anchor d0e5339--></a><p class="title"><strong>例 6.6. 访问session</strong></p><div class="example-contents"><pre class="programlisting">HttpSession session = request.getSession();

String value = (String) session.getAttribute(<strong class="hl-string"><em style="color:navy">"myattr"</em></strong>);
session.setAttribute(<strong class="hl-string"><em style="color:navy">"myattr"</em></strong>, newValue);</pre></div></div><p>然而，有一些功能在原有的Servlet
                    API中是不存在的。对于这一类功能，你必须访问特定的<code class="code">RequestContext</code>接口，才能使用它们。例如，你只能用另一个API才能读取用户上传的文件。下面的代码可以用来取得上传文件的信息：</p><div class="example"><a id="d0e5349"><!--anchor d0e5349--></a><p class="title"><strong>例 6.7. 访问特定的<code class="code">RequestContext</code>接口</strong></p><div class="example-contents"><pre class="programlisting">ParserRequestContext parserRequestContext =
                RequestContextUtil.findRequestContext(request, ParserRequestContext.<strong class="hl-keyword" style="color: maroon">class</strong>);

ParameterParser params = parserRequestContext.getParameters();

FileItem myfile = params.getFileItem(<strong class="hl-string"><em style="color:navy">"myfile"</em></strong>);

String filename = myfile.getName();
InputStream istream = myfile.getInputStream();</pre></div></div><p>另外有一些功能，使用Request Context接口比原来的Servlet
                        API接口更方便。例如，原来的<code class="code">request.getParameter()</code>方法只能取得字符串的参数值，但是利用<code class="code">ParserRequestContext</code>所提供的接口，就可以直接取得其它类型的值：</p><div class="example"><a id="d0e5365"><!--anchor d0e5365--></a><p class="title"><strong>例 6.8. 通过<code class="code">ParserRequestContext</code>接口访问参数比<code class="code">HttpServletRequest</code>更方便</strong></p><div class="example-contents"><pre class="programlisting">ParameterParser params = parserRequestContext.getParameters();

String stringValue = params.getString(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>); <em class="hl-comment" style="color: green">// 取得字符串值，默认为null</em>
<strong class="hl-keyword" style="color: maroon">int</strong> intValue = params.getInt(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>); <em class="hl-comment" style="color: green">// 取得整数值，默认为0</em>
<strong class="hl-keyword" style="color: maroon">boolean</strong> booleanValue = params.getBoolean(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, true); <em class="hl-comment" style="color: green">// 取得boolean值，指定默认值为true</em></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5376"><!--anchor d0e5376--></a>6.2.3.4. 注入request作用域的对象</h4></div></div></div><p>Spring最强大的功能是依赖注入。但是依赖注入有一个限制：小作用域的对象不能被注入到大作用域的对象。你不能够把request和session作用域的对象注入到singleton对象中。前者在每次WEB请求时，均会创建新的实例，每个线程独享这个request/session作用域的对象；后者是在Spring初始化或第一次使用时被创建，然后被所有的线程共享。假如你把某个request/session作用域的对象意外注入到singleton对象中，将可能产生致命的应用错误，甚至导致数据库的错乱。</p><div class="table"><a id="d0e5381"><!--anchor d0e5381--></a><p class="title"><strong>表 6.2. Webx中的重要对象及其作用域</strong></p><div class="table-contents"><table summary="Webx中的重要对象及其作用域" cellpadding="10" style="border: none;"><colgroup><col width="62%" class="c1"/><col width="38%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">对象类型</th><th style="border-bottom: 0.5pt solid #6666cc; ">作用域</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">ServletContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Singleton scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">HttpServletRequest</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Request scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">HttpServletResponse</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Request scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">HttpSession</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">Session scope</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">所有<code class="code">RequestContext</code>对象，如：<code class="code">ParserRequestContext</code>、<code class="code">SessionRequestContext</code>等</td><td style="" valign="middle">Request scope</td></tr></tbody></table></div></div><p><span class="emphasis"><em>在一般的情况下</em></span>，对于一个singleton对象而言，例如，Webx中的action module、pipeline
                    valve对象等，下面的代码是错误的：</p><div class="example"><a id="d0e5436"><!--anchor d0e5436--></a><p class="title"><strong>例 6.9. 在action（singleton对象）中注入request scope的对象</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> ParserRequestContext parser;
}</pre></div></div><p>因为你不能把一个短期的对象如request、response和request
                        context注入到<code class="code">MyAction</code>这个singleton对象。然而，<span class="emphasis"><em>在Webx中，这样做是可以的</em></span>！奥秘在于Request
                    Contexts服务对上表所列的这些短期对象作了特殊的处理，使它们可以被注入到singleton对象中。事实上，被注入的只是一个“空壳”，真正的对象是在被访问到的时候才会从线程中取得的。</p><p>Webx鼓励应用程序使用singleton作用域的对象，不仅更简单，也更高效。经过上述技术处理以后，singleton对象访问request作用域对象的方法被大大简化了。
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e5451"><!--anchor d0e5451--></a>6.3. Pipeline服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5454"><!--anchor d0e5454--></a>6.3.1. Pipeline工作原理</h3></div></div></div><p>Pipeline的意思是管道，管道中有许多阀门（Valve），阀门可以控制水流的走向。在Webx中，pipeline的作用就是控制应用程序流程的走向。</p><div class="figure"><a id="d0e5459"><!--anchor d0e5459--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/pipeline-valves.png" alt="Pipeline和Valves"/></div></div><p class="title"><strong>图 6.4. Pipeline和Valves</strong></p></div><p>Pipeline的设计和filter非常相似，也是击鼓传花式的流程控制。但是有几点不同：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Pipeline只能控制流程，不能改变request和response。</p></li><li class="listitem"><p>Pipeline是轻量级组件，它甚至不依赖于WEB环境。Pipeline既可以在程序中直接装配，也可以由spring和schema来配置。</p></li><li class="listitem"><p>Pipeline支持更复杂的流程结构，例如：子流程、条件分支、循环等。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5477"><!--anchor d0e5477--></a>6.3.2. Pipeline的用途</h3></div></div></div><p>Pipeline可以说是Webx框架的核心功能之一。利用pipeline，你可以定制一个请求处理过程的每一步。</p><div class="example"><a id="d0e5482"><!--anchor d0e5482--></a><p class="title"><strong>例 6.10. 一个典型的Webx应用的pipeline配置文件（<code class="filename">pipeline.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans:beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:services</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:pl-conditions</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/conditions"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:pl-valves</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:beans</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:p</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/p"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://www.alibaba.com/schema/services
                http://localhost:8080/schema/services.xsd
        http://www.alibaba.com/schema/services/pipeline/conditions
                http://localhost:8080/schema/services-pipeline-conditions.xsd
        http://www.alibaba.com/schema/services/pipeline/valves
                http://localhost:8080/schema/services-pipeline-valves.xsd
        http://www.springframework.org/schema/beans
                http://localhost:8080/schema/www.springframework.org/schema/beans/spring-beans.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 初始化turbine rundata，并在pipelineContext中设置可能会用到的对象(如rundata、utils)，以便valve取得。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;prepareForTurbine /&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 设置日志系统的上下文，支持把当前请求的详情打印在日志中。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;setLoggingContext /&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 分析URL，取得target。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;analyzeURL</strong> <span class="hl-attribute" style="color: #F5844C">homepage</span>=<span class="hl-value" style="color: #993300">"homepage"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- 检查csrf token，防止csrf攻击和重复提交。 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;checkCsrfToken /&gt;</strong>

        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 执行带模板的screen，默认有layout。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"null, vm, jsp"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performTemplateScreen /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;renderTemplate /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 执行不带模板的screen，默认无layout。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;pl-conditions:target-extension-condition</strong> <span class="hl-attribute" style="color: #F5844C">extension</span>=<span class="hl-value" style="color: #993300">"do"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performAction /&gt;</strong>
                    <strong class="hl-tag" style="color: #000096">&lt;performScreen /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong>
                    <em class="hl-comment" style="color: green">&lt;!-- 将控制交还给servlet engine。 --&gt;</em>
                    <strong class="hl-tag" style="color: #000096">&lt;exit /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>

            <em class="hl-comment" style="color: green">&lt;!-- 假如rundata.setRedirectTarget()被设置，则循环，否则退出循环。 --&gt;</em>
            <strong class="hl-tag" style="color: #000096">&lt;breakUnlessTargetRedirected /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans:beans&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5490"><!--anchor d0e5490--></a>6.3.3. Pipeline的使用</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5493"><!--anchor d0e5493--></a>6.3.3.1. 创建一个valve</h4></div></div></div><div class="example"><a id="d0e5496"><!--anchor d0e5496--></a><p class="title"><strong>例 6.11. 一个简单的valve实现</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyValve <strong class="hl-keyword" style="color: maroon">implements</strong> Valve {
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invoke(PipelineContext pipelineContext) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        System.out.println(<strong class="hl-string"><em style="color:navy">"valve started."</em></strong>);

        pipelineContext.invokeNext(); <em class="hl-comment" style="color: green">// 调用后序valves</em>

        System.out.println(<strong class="hl-string"><em style="color:navy">"valve ended."</em></strong>);
    }
}</pre><p>配置（<code class="filename">pipeline.xml</code>）</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;valve</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.myapp.pipeline.MyValve"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div><p>上面的代码和配置创建了一个基本的valve ── 事实上，它只是打印了一些消息，然后把控制权传递给后序的valves。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5510"><!--anchor d0e5510--></a>6.3.3.2. 执行一个pipeline</h4></div></div></div><div class="example"><a id="d0e5513"><!--anchor d0e5513--></a><p class="title"><strong>例 6.12. 在代码中执行pipeline</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<strong class="hl-keyword" style="color: maroon">private</strong> Pipeline myPipeline;

<strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invokePipeline() {
    PipelineInvocationHandle invocation = myPipeline.newInvocation();

    invocation.invoke();

    System.out.println(invocation.isFinished());
    System.out.println(invocation.isBroken());
}</pre></div></div><p>从spring容器中取得一个pipeline对象以后（一般是通过注入取得），我们就可以执行它。上面代码中，<code class="code">PipelineInvocationHandle</code>对象代表此次执行pipeline的状态。Pipeline执行结束以后，访问<code class="code">invocation</code>对象就可以了解到pipeline的执行情况
                    ── 正常结束还是被中断？</p><p>Pipeline对象是线程安全的，可被所有线程所共享。但<code class="code">PipelineInvocationHandle</code>对象不是线程安全的，每次执行pipeline时，均需要取得新的<code class="code">invocation</code>对象。
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5534"><!--anchor d0e5534--></a>6.3.3.3. 调用子流程</h4></div></div></div><p>Pipeline支持子流程。事实上，子流程不过是另一个pipeline对象而已。</p><div class="figure"><a id="d0e5539"><!--anchor d0e5539--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/sub-pipelines.png" alt="Pipeline和子流程"/></div></div><p class="title"><strong>图 6.5. Pipeline和子流程</strong></p></div><p>子流程是从valve中发起的。下面的Valve代码启动了一个子流程。</p><div class="example"><a id="d0e5547"><!--anchor d0e5547--></a><p class="title"><strong>例 6.13. 在valve中发起一个子流程</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyNestableValve <strong class="hl-keyword" style="color: maroon">implements</strong> Valve {
    <strong class="hl-keyword" style="color: maroon">private</strong> Pipeline subPipeline;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setSubPipeline(Pipeline subPipeline) {
        <strong class="hl-keyword" style="color: maroon">this</strong>.subPipeline = subPipeline;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invoke(PipelineContext pipelineContext) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        <em class="hl-comment" style="color: green">// 发起子流程，以当前流程的pipelineContext为参数</em>
        PipelineInvocationHandle subInvocation = subPipeline.newInvocation(pipelineContext);

        subInvocation.invoke();

        System.out.println(subInvocation.isFinished());
        System.out.println(subInvocation.isBroken());

        pipelineContext.invokeNext(); <em class="hl-comment" style="color: green">// 别忘了调用后序的valves</em>
    }
}</pre><p>配置文件（<code class="filename">pipeline.xml</code>）</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/pipeline/valves"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;valve</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.myapp.pipeline.MyNestableValve"</span> <span class="hl-attribute" style="color: #F5844C">p:subPipeline-ref</span>=<span class="hl-value" style="color: #993300">"subPipeline"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5559"><!--anchor d0e5559--></a>6.3.3.4. 中断一个pipeline</h4></div></div></div><p>Pipeline可以被中断。当有多级子pipeline时，你可以中断到任何一级pipeline。</p><div class="example"><a id="d0e5564"><!--anchor d0e5564--></a><p class="title"><strong>例 6.14. 中断一个pipeline</strong></p><div class="example-contents"><pre class="programlisting">pipelineContext.breakPipeline(<span class="hl-number">0</span>); <em class="hl-comment" style="color: green">// level=0，中断当前pipeline</em>
pipelineContext.breakPipeline(<span class="hl-number">1</span>); <em class="hl-comment" style="color: green">// level=1，中断上一级pipeline</em>

pipelineContext.breakPipeline(<strong class="hl-string"><em style="color:navy">"label"</em></strong>); <em class="hl-comment" style="color: green">// 中断到指定label的上级pipeline</em>
<em class="hl-comment" style="color: green">// 以上调用相当于：</em>
pipelineContext.breakPipeline(pipelineContext.findLabel(<strong class="hl-string"><em style="color:navy">"label"</em></strong>));

pipelineContext.breakPipeline(Pipeline.TOP_LABEL); <em class="hl-comment" style="color: green">// 终止所有pipelines</em></pre></div></div><div class="figure"><a id="d0e5569"><!--anchor d0e5569--></a><div class="figure-contents"><div class="mediaobject"><img src="images/filter/breaking-pipelines.png" alt="中断一个pipeline"/></div></div><p class="title"><strong>图 6.6. 中断一个pipeline</strong></p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5575"><!--anchor d0e5575--></a>6.3.3.5. 条件分支、循环</h4></div></div></div><p>条件分支和循环其实只不过是子流程的运用而已：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="27%" class="c1"/><col width="73%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">条件分支</td><td style="border-bottom: 0.5pt solid #6666cc; ">根据一定的条件，来决定是否要执行子流程、执行哪一个子流程（多条件分支）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">循环</td><td style="">多次执行子流程。</td></tr></tbody></table></div><p>下面的valve将子流程执行了至多10遍。如果子流程内部中断了流程，则循环终止。</p><div class="example"><a id="d0e5597"><!--anchor d0e5597--></a><p class="title"><strong>例 6.15. 将子流程循环执行10次</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> Loop10 <strong class="hl-keyword" style="color: maroon">implements</strong> Valve {
    <strong class="hl-keyword" style="color: maroon">private</strong> Pipeline loopBody;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setLoopBody(Pipeline loopBody) {
        <strong class="hl-keyword" style="color: maroon">this</strong>.loopBody = loopBody;
    }

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> invoke(PipelineContext pipelineContext) <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        PipelineInvocationHandle handle = loopBody.newInvocation(pipelineContext);

        <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> i = <span class="hl-number">0</span>; i &lt; <span class="hl-number">10</span> &amp;&amp; !handle.isBroken(); i++) {
            handle.invoke();
        }

        pipelineContext.invokeNext();
    }
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5602"><!--anchor d0e5602--></a>6.3.3.6. 存取pipeline的状态</h4></div></div></div><p>当一个pipeline在运行时，你可以通过<code class="code">PipelineContext</code>取得一些上下文信息：</p><div class="example"><a id="d0e5610"><!--anchor d0e5610--></a><p class="title"><strong>例 6.16. 在valve中存取pipeline的状态</strong></p><div class="example-contents"><pre class="programlisting">pipelineContext.index(); <em class="hl-comment" style="color: green">// 当前valve在pipeline中的序号</em>
pipelineContext.level(); <em class="hl-comment" style="color: green">// 当前pipeline在所有子pipeline中的级别</em>
pipelineContext.isBroken(); <em class="hl-comment" style="color: green">// 当前pipeline是否已经被中断</em>
pipelineContext.isFinished(); <em class="hl-comment" style="color: green">// 当前pipeline的所有valves是否已经执行完</em>

<em class="hl-comment" style="color: green">// 存取任意数据</em>
pipelineContext.getAttribute(key);
pipelineContext.setAttribute(key, value);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5615"><!--anchor d0e5615--></a>6.3.3.7. 现成可用的valves</h4></div></div></div><p>一般情况下，你并不需要写前面例子中的代码，因为Webx已经为你提供了一系列现成的valves来实现同样的功能。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">无条件循环 - <code class="code">&lt;loop&gt;</code></span></dt><dd><div class="example"><a id="d0e5627"><!--anchor d0e5627--></a><p class="title"><strong>例 6.17. 无条件循环</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span> <span class="hl-attribute" style="color: #F5844C">maxLoopCount</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.loop.params"><!--anchor co.valve.loop.params--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.loop.break"><!--anchor co.valve.loop.break--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.loop.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义循环变量<code class="code">loopCounterName</code>，这个变量值将被保存在<code class="code">PipelineContext</code>中，且可被其它的valve所访问。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.loop.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义<code class="code">maxLoopCount=10</code>最大循环圈数，以避免循环失控。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.loop.break"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件循环一定要和<code class="code">&lt;break&gt;</code>、<code class="code">&lt;break-if&gt;</code>或<code class="code">&lt;break-unless&gt;</code>等valve相配合。</p></td></tr></table></div></div></div></dd><dt><span class="term">条件循环 - <code class="code">&lt;while&gt;</code></span></dt><dd><div class="example"><a id="d0e5670"><!--anchor d0e5670--></a><p class="title"><strong>例 6.18. 条件循环</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;while</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"count &amp;lt;= 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.while.params"><!--anchor co.valve.while.params--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/while&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;while</strong> <span class="hl-attribute" style="color: #F5844C">maxLoopCount</span>=<span class="hl-value" style="color: #993300">"10"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.while.maxLoop"><!--anchor co.valve.while.maxLoop--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.while.condition"><!--anchor co.valve.while.condition--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/while&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义循环变量<code class="code">loopCounterName</code>，这个变量值将被保存在<code class="code">PipelineContext</code>中，且可被其它的valve所访问。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.params"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>通过判断循环变量“<code class="code">count &lt;= 2</code>”，循环2次。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.maxLoop"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义<code class="code">maxLoopCount=10</code>，以避免循环失控。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.while.condition"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可以自定义任意条件。</p></td></tr></table></div></div></div></dd><dt><span class="term">单条件分支 - <code class="code">&lt;if&gt;</code></span></dt><dd><div class="example"><a id="d0e5712"><!--anchor d0e5712--></a><p class="title"><strong>例 6.19. 单条件分支</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"1 == 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.if.test"><!--anchor co.valve.if.test--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;if&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.if.condition"><!--anchor co.valve.if.condition--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.if.test"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>JEXL条件表达式。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.if.condition"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>自定义任意条件。</p></td></tr></table></div></div></div></dd><dt><span class="term">多条件分支 - <code class="code">&lt;choose&gt;&lt;when&gt;&lt;otherwise&gt;</code></span></dt><dd><div class="example"><a id="d0e5734"><!--anchor d0e5734--></a><p class="title"><strong>例 6.20. 多条件分支</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;choose&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;when</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"1 == 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.choose.b1"><!--anchor co.valve.choose.b1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;when&gt;</strong> <a id="co.valve.choose.b2"><!--anchor co.valve.choose.b2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/when&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;otherwise&gt;</strong> <a id="co.valve.choose.b3"><!--anchor co.valve.choose.b3--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/otherwise&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/choose&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.choose.b1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>条件分支1，用JEXL表达式来判断。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.choose.b2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>条件分支2，用任意条件判断。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.choose.b3"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>分支3，当所有条件均不符合时，选择该分支。</p></td></tr></table></div></div></div></dd><dt><span class="term">无条件中断 - &lt;break&gt;</span></dt><dd><div class="example"><a id="d0e5759"><!--anchor d0e5759--></a><p class="title"><strong>例 6.21. 无条件中断</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong> <a id="co.valve.break.loop1"><!--anchor co.valve.break.loop1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break /&gt;</strong> <a id="co.valve.break.level0"><!--anchor co.valve.break.level0--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong> <a id="co.valve.break.loop2"><!--anchor co.valve.break.loop2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;break</strong> <span class="hl-attribute" style="color: #F5844C">levels</span>=<span class="hl-value" style="color: #993300">"1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.break.level1"><!--anchor co.valve.break.level1--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">label</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.break.loop3"><!--anchor co.valve.break.loop3--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;break</strong> <span class="hl-attribute" style="color: #F5844C">toLabel</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.break.label"><!--anchor co.valve.break.label--></a><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.break.level0"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件中止当前的pipeline（即loop循环<a id="co.valve.break.loop1"><!--anchor co.valve.break.loop1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>）。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.break.level1"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件中止上一层（<code class="code">levels=1</code>）的pipeline（即loop循环<a id="co.valve.break.loop2"><!--anchor co.valve.break.loop2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>）。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.break.label"><span class="calloutno"><img src="images/callouts/6.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>无条件中止指定label的pipeline（即loop循环<a id="co.valve.break.loop3"><!--anchor co.valve.break.loop3--></a><span class="calloutno"><img src="images/callouts/5.png" border="0"/></span>）。</p></td></tr></table></div></div></div></dd><dt><span class="term">有条件中断 -
                            <code class="code">&lt;break-if&gt;</code>、<code class="code">&lt;break-unless&gt;</code></span></dt><dd><p>有条件中断是<code class="code">&lt;break&gt;</code>和<code class="code">&lt;if&gt;</code>的组合。</p><div class="example"><a id="d0e5812"><!--anchor d0e5812--></a><p class="title"><strong>例 6.22. 有条件中断</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"count &amp;gt; 2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.valve.breakif.test"><!--anchor co.valve.breakif.test--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">label</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-if</strong> <span class="hl-attribute" style="color: #F5844C">toLabel</span>=<span class="hl-value" style="color: #993300">"MY_LOOP"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.breakif.params"><!--anchor co.valve.breakif.params--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;conditions:condition</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>  <a id="co.valve.breakif.condition"><!--anchor co.valve.breakif.condition--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/break-if&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;loop</strong> <span class="hl-attribute" style="color: #F5844C">loopCounterName</span>=<span class="hl-value" style="color: #993300">"count"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;break-unless</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"count &amp;lt;= 2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>  <a id="co.valve.breakunless.test"><!--anchor co.valve.breakunless.test--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakif.test"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>当<code class="code">count&gt;2</code>时中断。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakif.params"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;break-if&gt;</code>和<code class="code">&lt;break-unless&gt;</code>均支持和<code class="code">&lt;break&gt;</code>类似的其它选项：<code class="code">levels</code>和<code class="code">toLabel</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakif.condition"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>和<code class="code">&lt;if&gt;</code>类似，也支持任意condition。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.breakunless.test"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;break-unless&gt;</code>和<code class="code">&lt;break-if&gt;</code>的条件相反：<span class="emphasis"><em>除非</em></span><code class="code">count&lt;=2</code>，否则中断。</p></td></tr></table></div></div></div></dd><dt><span class="term">无条件退出整个pipeline - <code class="code">&lt;exit&gt;</code></span></dt><dd><p>退出整个pipeline，意思是结束所有的嵌套层次。</p><div class="example"><a id="d0e5876"><!--anchor d0e5876--></a><p class="title"><strong>例 6.23. 无条件退出整个pipeline</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;loop&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;exit /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/loop&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div><p>对于Webx而言，<code class="code">&lt;exit&gt;</code>还有一层特殊的含义：放弃<code class="code">WebxFrameworkFilter</code>的控制权，把它交还给servlet
                                engine。以URL
                                <code class="code">http://localhost:8081/myapp/myimage.jpg</code>为例，把控制权交还给servlet
                                engine，意味着让servlet
                                    engine去显示myapp应用目录下的静态图片：<code class="filename">myimage.jpg</code>。</p></dd><dt><span class="term">异常捕获和finally处理 - <code class="code">&lt;try-catch-finally&gt;</code></span></dt><dd><p>类似Java中的<code class="code">try/catch/finally</code>结构。</p><div class="example"><a id="d0e5906"><!--anchor d0e5906--></a><p class="title"><strong>例 6.24. 异常捕获和finally处理</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;try-catch-finally&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;try&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/try&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;catch</strong> <span class="hl-attribute" style="color: #F5844C">exceptionName</span>=<span class="hl-value" style="color: #993300">"myexception"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.valve.catch.exceptionName"><!--anchor co.valve.catch.exceptionName--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/catch&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;finally&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/finally&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/try-catch-finally&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.valve.catch.exceptionName"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">&lt;catch&gt;</code>标签可以将捕获的异常以指定名称保存在<code class="code">PipelineContext</code>中，以便其它valve取得。</p></td></tr></table></div></div></div></dd><dt><span class="term">创建子流程 - <code class="code">&lt;sub-pipeline&gt;</code></span></dt><dd><p>单纯使用这个valve，对执行结果不会有任何影响。但可用来对较长的pipeline进行分段管理。</p><div class="example"><a id="d0e5930"><!--anchor d0e5930--></a><p class="title"><strong>例 6.25. 创建子流程</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;sub-pipeline</strong> <span class="hl-attribute" style="color: #F5844C">label</span>=<span class="hl-value" style="color: #993300">"mylabel"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/sub-pipeline&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;valve /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/services:pipeline&gt;</strong></pre></div></div></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5935"><!--anchor d0e5935--></a>6.3.3.8. 条件</h4></div></div></div><p>在前文所述的各种条件valve（例如<code class="code">&lt;if&gt;</code>、<code class="code">&lt;when&gt;</code>、<code class="code">&lt;while&gt;</code>、<code class="code">&lt;break-if&gt;</code>、<code class="code">&lt;break-unless&gt;</code>等）中，都用到一个共同的对象：condition。<code class="code">Condition</code>是一个简单的接口。</p><div class="example"><a id="d0e5958"><!--anchor d0e5958--></a><p class="title"><strong>例 6.26. <code class="code">Condition</code>接口</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">interface</strong> Condition {
    <strong class="hl-tag" style="color: blue">/**
     * 如满足条件，则返回&lt;code&gt;true&lt;/code&gt;。
     */</strong>
    <strong class="hl-keyword" style="color: maroon">boolean</strong> isSatisfied(PipelineStates pipelineStates);
}</pre></div></div><p>为了方便起见，Webx默认提供了一个<code class="code">JexlCondtion</code>。</p><div class="example"><a id="d0e5970"><!--anchor d0e5970--></a><p class="title"><strong>例 6.27. 使用<code class="code">JexlCondition</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;if&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;conditions:jexl-condition</strong> <span class="hl-attribute" style="color: #F5844C">expr</span>=<span class="hl-value" style="color: #993300">"loopCount == 2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;break /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong></pre><p>以上配置可以简化为：</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;if</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"loopCount == 2"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;break /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/if&gt;</strong></pre></div></div><p>JEXL表达式是Apache的一个小项目，表达式语法详见：<a class="link" href="http://commons.apache.org/jexl/reference/syntax.html" target="_top">http://commons.apache.org/jexl/reference/syntax.html</a>。在JEXL表达式中，你可以使用<code class="code">pipelineContext.getAttribute()</code>所能取得的所有状态值。例如，loop循环时，如果你设置了<code class="code">loopCounterName</code>，那么循环计数器就可以被JEXL表达式所访问。</p><p>除此之外，Webx还提供了三个组合式的条件。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">&lt;all-of&gt;</code></span></dt><dd><p>要求所有条件均满足，相当于Java中的<code class="code">&amp;&amp;</code>操作符。</p><div class="example"><a id="d0e6004"><!--anchor d0e6004--></a><p class="title"><strong>例 6.28. <code class="code">组合式的条件：&lt;all-of&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;all-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition1 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition2 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition3 /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/all-of&gt;</strong></pre></div></div></dd><dt><span class="term"><code class="code">&lt;any-of&gt;</code></span></dt><dd><p>只要求任一条件满足，相当于Java中的<code class="code">||</code>操作符。</p><div class="example"><a id="d0e6020"><!--anchor d0e6020--></a><p class="title"><strong>例 6.29. <code class="code">组合式的条件：&lt;any-of&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;any-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition1 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition2 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition3 /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/any-of&gt;</strong></pre></div></div></dd><dt><span class="term"><code class="code">&lt;none-of&gt;</code></span></dt><dd><p>要求所有条件均不满足，相当于Java中的<code class="code">!</code>操作符。</p><div class="example"><a id="d0e6036"><!--anchor d0e6036--></a><p class="title"><strong>例 6.30. <code class="code">组合式的条件：&lt;none-of&gt;</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;none-of&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition1 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition2 /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition3 /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/none-of&gt;</strong></pre></div></div></dd></dl></div><p>这三个组合式条件可以互相组合，以构成任意复杂的条件判断语句。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e6044"><!--anchor d0e6044--></a>6.4. 本章总结</h2></div></div></div><p>Request Contexts和Pipeline是Webx框架中的两个核心服务。它们分别从两个方面实现了原本需要由Filter来实现的功能 ── Request
            Contexts提供了包装和修改request/response的机制，而pipeline则提供了流程控制的能力。Request
            contexts和pipeline组合起来的功能比servlet
            filter机制更加强大。因为它们是基于Spring的轻量组件，其性能、配置的方便性、扩展性都优于filter。</p><p>当然，Request Contexts和Pipeline并不想取代filter。在好几种场合，filter仍然是唯一的选择：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>如果你既想要修改request/response，又想要控制流程；</p></li><li class="listitem"><p>如果你希望独立于任何框架。 </p></li></ul></div><p>但在你接到一个需求，正打算用filter来实现之前，请考虑一下，是否可以采用Webx所提供的这两种机制来取代。倘若可行，必然会带来更多的好处。</p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resourceloading.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="pt02.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="requestcontexts.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 5 章 Resource Loading服务指南 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 7 章 Request Contexts功能指南</td></tr></table></div></body></html>