<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>第 3 章 Webx Framework</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="home" href="index.html" title="Webx框架指南"/><link rel="up" href="pt01.html" title="部分 I. Webx框架概览"/><link rel="prev" href="springext.html" title="第 2 章 SpringExt"/><link rel="next" href="turbine.html" title="第 4 章 Webx Turbine"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 3 章 Webx Framework</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="springext.html">上一页</a> </td><th width="60%" align="center">部分 I. Webx框架概览</th><td width="20%" align="right"> <a accesskey="n" href="turbine.html">下一页</a></td></tr></table><hr/></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.overview.framework"><!--anchor webx.overview.framework--></a>第 3 章 Webx Framework</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="webxframework.html#d0e1269">3.1. Webx的初始化</a></span></dt><dd><dl><dt><span class="section"><a href="webxframework.html#d0e1272">3.1.1. 初始化级联的Spring容器</a></span></dt><dt><span class="section"><a href="webxframework.html#d0e1330">3.1.2. 初始化日志系统</a></span></dt></dl></dd><dt><span class="section"><a href="webxframework.html#d0e1385">3.2. Webx响应请求</a></span></dt><dd><dl><dt><span class="section"><a href="webxframework.html#d0e1412">3.2.1. 增强request、response、session的功能</a></span></dt><dt><span class="section"><a href="webxframework.html#d0e1566">3.2.2. Pipeline流程机制</a></span></dt><dt><span class="section"><a href="webxframework.html#d0e1673">3.2.3. 异常处理机制</a></span></dt><dt><span class="section"><a href="webxframework.html#webx.overview.framework.devmode">3.2.4. 开发模式工具</a></span></dt><dt><span class="section"><a href="webxframework.html#d0e1901">3.2.5. 响应和处理请求的更多细节</a></span></dt></dl></dd><dt><span class="section"><a href="webxframework.html#d0e2093">3.3. 定制Webx Framework</a></span></dt><dd><dl><dt><span class="section"><a href="webxframework.html#d0e2096">3.3.1. 定制<code class="code">WebxRootController</code></a></span></dt><dt><span class="section"><a href="webxframework.html#d0e2127">3.3.2. 定制<code class="code">WebxController</code></a></span></dt></dl></dd><dt><span class="section"><a href="webxframework.html#d0e2172">3.4. 本章总结</a></span></dt></dl></div><p>Webx是一套基于Java Servlet API的通用Web框架。整个Webx框架分成三个层次，本章将简单介绍其第二个层次：Webx
        Framework。事实上，这是第一个真正涉足WEB技术的层次。前一个层次SpringExt只是提供了一个通用的扩展机制。</p><p>Webx Framework负责完成一系列基础性的任务，如下表所示：</p><div class="table"><a id="d0e1236"><!--anchor d0e1236--></a><p class="title"><strong>表 3.1. Webx Framework的任务</strong></p><div class="table-contents"><table summary="Webx Framework的任务" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">系统初始化</th><th style="border-bottom: 0.5pt solid #6666cc; ">响应请求</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; ">初始化Spring容器</td><td style="">增强request/response/session的功能</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">初始化日志系统</td><td style="">提供pipeline流程处理机制</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "> </td><td style="">异常处理</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "> </td><td style="">开发模式</td></tr></tbody></table></div></div><p>本章不会涉及太深的细节，如果你想了解更多，请参考其它文档。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e1269"><!--anchor d0e1269--></a>3.1. Webx的初始化</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1272"><!--anchor d0e1272--></a>3.1.1. 初始化级联的Spring容器</h3></div></div></div><p>Webx Framework将负责创建一组级联的Spring容器结构。Webx所创建的Spring容器<span class="emphasis"><em>完全兼容于Spring
                    MVC所创建的容器</em></span>，可被所有使用Spring框架作为基础的WEB框架所使用。</p><div class="example"><a id="d0e1280"><!--anchor d0e1280--></a><p class="title"><strong>例 3.1. 初始化Spring容器 - <code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong><span class="emphasis"><em>com.alibaba.citrus.webx.context.WebxContextLoaderListener</em></span><strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong> <a id="co.init.context"><!--anchor co.init.context--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.init.context"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Webx利用<code class="code">WebxContextLoaderListener</code>来初始化Spring，用来取代Spring的<code class="code">ContextLoaderListener</code>。事实上，前者是从后者派生的。</p></td></tr></table></div></div></div><p>Webx
                Framework将会自动搜索<code class="filename">/WEB-INF</code>目录下的XML配置文件，并创建下面这种级联的spring容器。</p><div class="figure"><a id="d0e1307"><!--anchor d0e1307--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/context-tree.png" alt="级联的Spring容器"/></div></div><p class="title"><strong>图 3.1. 级联的Spring容器</strong></p></div><p>如图所示。Webx Framework将一个WEB应用分解成多个小应用模块：<code class="code">app1</code>、<code class="code">app2</code>，当然名字可以任意取。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>每个小应用模块独享一个Spring Sub Context子容器。两个子容器之间的beans无法互相注入。</p></li><li class="listitem"><p>所有小应用模块共享一个Spring Root
                            Context根容器。根容器中的bean可被注入到子容器的bean中；反之不可以。</p></li></ul></div><p>将一个大的应用分解成若干个小应用模块，并使它们的配置文件相对独立，这是一种很不错的开发实践。然而，如果你的应用确实很简单，你不希望把你的应用分成多个小应用模块，那么，你还是需要配置至少一个小应用模块（子容器）。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1330"><!--anchor d0e1330--></a>3.1.2. 初始化日志系统</h3></div></div></div><p>每个现代的WEB应用，都需要日志系统。流行的日志系统包括Log4j、Logback。</p><p>Webx Framework使用SLF4J作为它的日志框架。因此Webx
                Framework理论上支持所有日志系统。然而目前为止，它只包含了log4j和logback这两种日志系统的初始化模块（如有需要，可以扩充）。初始化日志系统很简单。</p><div class="example"><a id="d0e1337"><!--anchor d0e1337--></a><p class="title"><strong>例 3.2. 初始化日志系统 - <code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;listener&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;listener-class&gt;</strong><span class="emphasis"><em>com.alibaba.citrus.logconfig.LogConfiguratorListener</em></span><strong class="hl-tag" style="color: #000096">&lt;/listener-class&gt;</strong> <a id="co.init.log"><!--anchor co.init.log--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/listener&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.init.log"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>Webx利用<code class="code">LogConfiguratorListener</code>来初始化日志系统。</p></td></tr></table></div></div></div><p><code class="code">LogConfiguratorListener</code>会根据你当前应用所依赖的日志系统（通常配置在maven project中），来自动选择合适的日志配置文件。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>假设你的应用依赖了logback的jar包，那么listener就会查找<code class="filename">/WEB-INF/logback.xml</code>，并用它来初始化logback；</p></li><li class="listitem"><p>如果你的应用依赖了log4j的jar包，那么listener也会很聪明地查找<code class="filename">/WEB-INF/log4j.xml</code>配置文件。</p></li><li class="listitem"><p>假如以上配置文件不存在，listener会使用默认的配置 —— 把日志打印在控制台上。</p></li><li class="listitem"><p>Listener支持对配置文件中的placeholders进行替换。</p></li><li class="listitem"><p>Listener支持同时初始化多种日志系统。</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关日志系统的使用方法，另有文档详细讲述。</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e1385"><!--anchor d0e1385--></a>3.2. Webx响应请求</h2></div></div></div><div class="figure"><a id="d0e1388"><!--anchor d0e1388--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/request-processing.png" alt="Webx Framework如何响应请求"/></div></div><p class="title"><strong>图 3.2. Webx Framework如何响应请求</strong></p></div><p>当Webx Framework接收到一个来自WEB的请求以后，实际上它主要做了两件事： </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>首先，它会增强request、response、session的功能，并把它们打包成更易使用的<code class="code">RequestContext</code>对象。</p></li><li class="step"><p>其次，它会调用相应子应用的pipeline，用它来做进一步的处理。</p></li><li class="step"><p>假如在上面的过程中出现异常，则会触发Webx Framework处理异常的过程。</p></li></ol></div><p>
        </p><p>此外，Webx Framework还提供了一组辅助开发的功能，例如查看环境变量，查看schema等。这些功能只在开发模式生效，生产模式下自动关闭。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1412"><!--anchor d0e1412--></a>3.2.1. 增强request、response、session的功能</h3></div></div></div><p>Webx Framework提供了一个request contexts服务。Request
                    contexts服务利用<code class="code">HttpServletRequestWrapper</code>和<code class="code">HttpServletResponseWrapper</code>对request和response对象进行包装，以实现新的功能。</p><p>一个基本的request contexts的配置看起来是下面的样子： </p><div class="example"><a id="d0e1425"><!--anchor d0e1425--></a><p class="title"><strong>例 3.3. 配置request contexts服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>Request contexts所有的功能都是可配置、可扩展的 —— 它是基于SpringExt的扩展机制。</p><p>Request contexts所增加的功能对于所有的基于标准Servlet API的应用都是透明的 ——
                这些应用根本不需要知道这些扩展的存在。例如，假如你在request contexts服务中配置了增强的session框架，那么所有通过标准的Servlet
                API取得session的应用，都将获得新功能：</p><div class="example"><a id="d0e1434"><!--anchor d0e1434--></a><p class="title"><strong>例 3.4. 取得增强的session对象</strong></p><div class="example-contents"><pre class="programlisting">HttpSession session = request.getSession();</pre></div></div><p>再比如，只要你配置了upload服务，那么下面的调用将同样适用于<code class="code">multipart/form-data</code>类型的请求（Servlet
                API本身是不支持upload表单的）：</p><div class="example"><a id="d0e1444"><!--anchor d0e1444--></a><p class="title"><strong>例 3.5. 取得upload表单的参数</strong></p><div class="example-contents"><pre class="programlisting">String value = request.getParameter(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关Request Contexts的原理和使用方法的详情，请参阅<a class="xref" href="filter.html" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>。</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1454"><!--anchor d0e1454--></a>3.2.1.1. Request contexts中可用的功能</h4></div></div></div><div class="table"><a id="d0e1457"><!--anchor d0e1457--></a><p class="title"><strong>表 3.2. 可用的<code class="code">RequestContext</code>扩展</strong></p><div class="table-contents"><table summary="可用的RequestContext扩展" cellpadding="10" style="border: none;"><colgroup><col width="20%" class="c1"/><col width="80%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;basic&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">对输入、输出的数据进行安全检查，排除可能的攻击。例如：XSS过滤、CRLF换行回车过滤等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;buffered&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">对写入response中的数据进行缓存，以便于实现嵌套的页面。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;lazy-commit&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">延迟提交response，用来支持基于cookie的session。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;parser&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">解析用户提交的参数，无论是普通的请求，还是multipart/form-data这样的用于上传文件的请求。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;set-locale&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">设置当前请求的区域（locale）、编码字符集（charset）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">&lt;rewrite&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; ">改写URL及参数，类似于Apache HTTPD Server中的rewrite模块。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; "><code class="code">&lt;session&gt;</code></td><td style="">增强的Session框架，可将session中的对象保存到cookie、数据库或其它存储中。</td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关以上所有Request Contexts的详情，请参阅<a class="xref" href="requestcontexts.html" title="第 7 章 Request Contexts功能指南">第 7 章 <em>Request Contexts功能指南</em></a>和<a class="xref" href="session.html" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1522"><!--anchor d0e1522--></a>3.2.1.2. 注入特殊对象</h4></div></div></div><p>在Webx中，你可以这样做，例如：</p><div class="example"><a id="d0e1527"><!--anchor d0e1527--></a><p class="title"><strong>例 3.6. 注入request、response、session</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> LoginAction {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpSession session;
    ...
}</pre></div></div><p>在这个例子中，<code class="code">LoginAction</code>类可以是一个singleton。一般来说，你<span class="emphasis"><em>不能把request
                            scope的对象，注入到<code class="code">singleton</code>
                            scope的对象中</em></span>。但你<span class="emphasis"><em>可以把<code class="code">HttpServletRequest</code>、<code class="code">HttpServletResponse</code>和<code class="code">HttpSession</code>对象注入到singleton对象中</em></span>。为什么呢？原来，Request
                    contexts服务对这几个常用对象进行了特殊处理，将它们转化成了singleton对象。</p><p>如果没有这个功能，那么我们就不得不将上例中的<code class="code">LoginAction</code>配置成<code class="code">request</code>
                        scope。这增加了系统的复杂性，也成倍地降低了性能。而将<code class="code">LoginAction</code>设置成singleton，只需要在系统启动时初始化一次，以后就可以快速引用它。
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1566"><!--anchor d0e1566--></a>3.2.2. Pipeline流程机制</h3></div></div></div><p>Webx Framework赋予开发者极大的自由，来定制处理请求的流程。这种机制就是pipeline。</p><p>Pipeline的意思是管道，管道中有许多阀门（Valve），阀门可以控制水流的走向。Webx
                Framework中的pipeline可以控制处理请求的流程的走向。如图所示。 </p><div class="figure"><a id="d0e1573"><!--anchor d0e1573--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/pipeline.png" alt="Pipeline工作原理示意"/></div></div><p class="title"><strong>图 3.3. Pipeline工作原理示意</strong></p></div><p>Webx Framework并没有规定管道的内容 —— 定制管道是应用开发者的自由。然而Webx
                Framework提供了一系列通用valves，你可以使用它们：</p><div class="table"><a id="d0e1581"><!--anchor d0e1581--></a><p class="title"><strong>表 3.3. 通用valves</strong></p><div class="table-contents"><table summary="通用valves" cellpadding="10" style="border: none;"><colgroup><col width="16%" class="c1"/><col width="31%" class="c2"/><col width="53%" class="c3"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">分类</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">Valves</th><th style="border-bottom: 0.5pt solid #6666cc; " valign="middle">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2" valign="middle">循环</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;while&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">有条件循环</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;loop&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">无条件循环</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="2" valign="middle">选择分支</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;if&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">单分支</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;choose&gt;&lt;when&gt;&lt;otherwise&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">多分支</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " rowspan="3" valign="middle">中断</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;break&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">无条件中断</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <p><code class="code">&lt;break-if&gt;</code></p>
                                <p><code class="code">&lt;break-unless&gt;</code></p>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">有条件中断</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;exit&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">无条件退出整个pipeline（结束所有的嵌套层次）</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">异常捕获</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;try-catch-finally&gt;</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">类似Java中的try-catch-finally结构</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">嵌套</td><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;sub-pipeline&gt;</code></td><td style="" valign="middle">创建嵌套的子pipeline。 </td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有关Pipeline的原理和使用方法的详情，请参阅<a class="xref" href="filter.html" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>。</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1673"><!--anchor d0e1673--></a>3.2.3. 异常处理机制</h3></div></div></div><p>当应用发生异常时，Webx Framework可以处理这些异常。</p><div class="table"><a id="d0e1678"><!--anchor d0e1678--></a><p class="title"><strong>表 3.4. Webx如何处理异常</strong></p><div class="table-contents"><table summary="Webx如何处理异常" cellpadding="10" style="border: none;"><colgroup><col width="17%" class="c1"/><col width="35%" class="c2"/><col width="48%" class="c3"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">条件</th><th style="border-bottom: 0.5pt solid #6666cc; " valign="middle">处理</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " colspan="2" valign="middle">开发模式</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">展示详细出错信息。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " rowspan="2" valign="middle">生产模式</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">假如存在exception pipeline</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">用exception pipeline来处理异常；</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">不存在exception pipeline</td><td style="" valign="middle">显示web.xml中定义的默认错误页面。</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="webx.overview.framework.devmode"><!--anchor webx.overview.framework.devmode--></a>3.2.4. 开发模式工具</h3></div></div></div><p>Webx Framework提供了一个开关，可以让应用运行于“<span class="emphasis"><em>生产模式（Production
                    Mode）</em></span>”或是“<span class="emphasis"><em>开发模式（Development Mode）</em></span>” 。</p><div class="example"><a id="d0e1720"><!--anchor d0e1720--></a><p class="title"><strong>例 3.7. 配置运行模式</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:webx-configuration&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;services:productionMode&gt;</strong><span class="emphasis"><em>${productionMode:true}</em></span><strong class="hl-tag" style="color: #000096">&lt;/services:productionMode&gt;</strong> <a id="co.webx.running.mode"><!--anchor co.webx.running.mode--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/services:webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.running.mode"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>使用这行配置，并且在启动应用服务器时指定参数“<code class="code">-DproductionMode=false</code>”，就会让Webx以开发模式启动。</p></td></tr></table></div></div></div><p>在开发模式下，会有一系列不同于生产模式的行为。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>不同的主页 —— 在开发模式的主页中，可以查看和查询系统内部的信息。</p><div class="figure"><a id="d0e1743"><!--anchor d0e1743--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-homepage.png" alt="开发模式的主页"/></div></div><p class="title"><strong>图 3.4. 开发模式的主页</strong></p></div></li><li class="listitem"><p>不同的详细出错页面。</p><div class="figure"><a id="d0e1752"><!--anchor d0e1752--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-errorpage.png" alt="开发模式的详细出错页面"/></div></div><p class="title"><strong>图 3.5. 开发模式的详细出错页面</strong></p></div></li><li class="listitem"><p>开发模式下，可展示所有可用的schemas。</p><div class="figure"><a id="d0e1761"><!--anchor d0e1761--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-schemapage.png" alt="开发模式下展示所有可用的schemas"/></div></div><p class="title"><strong>图 3.6. 开发模式下展示所有可用的schemas</strong></p></div></li><li class="listitem"><p>开发模式下，可以查阅容器内部的信息。</p><div class="figure"><a id="d0e1770"><!--anchor d0e1770--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/dev-explorerpage.png" alt="开发模式下查阅容器内部的信息"/></div></div><p class="title"><strong>图 3.7. 开发模式下查阅容器内部的信息</strong></p></div><p>可供查阅的信息包括：</p><div class="table"><a id="d0e1778"><!--anchor d0e1778--></a><p class="title"><strong>表 3.5. 开发模式中可供查阅的容器信息</strong></p><div class="table-contents"><table summary="开发模式中可供查阅的容器信息" cellpadding="10" style="border: none;"><colgroup><col width="23%" class="c1"/><col width="77%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Beans</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看各Spring容器中的全部bean的定义。</p>
                                        <p>这个工具有助于开发者理解用schema所定义的services和spring
                                            beans之间的联系。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Configurations</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看用来创建各Spring容器的配置文件。</p>
                                        <p>这个工具会以树状和语法高亮显示配置文件以及所有被import的配置文件的内容。</p>
                                        <p>不同于Beans工具，Configurations工具只忠实地展现配置文件的内容。而Beans工具展现的是真实的Beans结构。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Resolvable Dependencies</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看所有由框架置入到容器中的对象，例如：<code class="classname">HttpServletRequest</code>对象。这些对象不需要在配置文件中定义，就可被注入到应用中。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Resources</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>跟踪Resources的装载过程，显示Resources的树状结构。</p>
                                        <p>这个工具有助于开发者理解<code class="classname">ResourceLoadingService</code>的工作原理。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">URIs</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                        <p>查看所有的URI brokers。</p>
                                    </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Pull Tools</td><td style="">
                                        <p>查看所有模板中可用的pull tools。</p>
                                    </td></tr></tbody></table></div></div></li></ul></div><p>事实上，Webx Framework提供了一套专用的内部框架，使你可以往开发模式中添加更多的开发工具。例如，创建下面的功能并非难事：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>查看session对象。</p></li><li class="listitem"><p>提供各种编码、解码的工具，以方便开发、调试应用。例如：将<code class="code">UTF-8</code>编码的字符串转换成<code class="code">GBK</code>编码；或者将字符串进行URL
                            escape编码、解码等。</p></li></ul></div><p>Webx Framework提供了一个接口：<code class="code">ProductionModeAware</code>。Spring
                context中的beans，如果实现了这个接口，就可以感知当前系统的运行模式，从而根据不同的模式选择不同的行为 ——
                例如：在生产模式中打开cache，在开发模式中关闭cache。</p><div class="example"><a id="d0e1877"><!--anchor d0e1877--></a><p class="title"><strong>例 3.8. 利用<code class="code">ProductionModeAware</code>接口感知运行模式，并自动开关cache</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> ModuleLoaderServiceImpl <strong class="hl-keyword" style="color: maroon">implements</strong> ProductionModeAware {  <a id="co.prod.mode.aware.impl"><!--anchor co.prod.mode.aware.impl--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> setProductionMode(<strong class="hl-keyword" style="color: maroon">boolean</strong> productionMode) { <a id="co.prod.mode.aware.impl2"><!--anchor co.prod.mode.aware.impl2--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-keyword" style="color: maroon">this</strong>.productionMode = productionMode;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword" style="color: maroon">protected</strong> <strong class="hl-keyword" style="color: maroon">void</strong> init() {
        ……
        <strong class="hl-keyword" style="color: maroon">if</strong> (cacheEnabled == null) {
            cacheEnabled = productionMode; <a id="co.prod.mode.aware.cache"><!--anchor co.prod.mode.aware.cache--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        }
        ……
    }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.prod.mode.aware.impl"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> <a href="#co.prod.mode.aware.impl2"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>实现<code class="code">ProductionModeAware</code>接口。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.prod.mode.aware.cache"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>根据当前运行模式自动开关cache。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1901"><!--anchor d0e1901--></a>3.2.5. 响应和处理请求的更多细节</h3></div></div></div><p>当一个HTTP请求到达时，首先由WebxFrameworkFilter接手这个请求：</p><div class="example"><a id="d0e1906"><!--anchor d0e1906--></a><p class="title"><strong>例 3.9. 配置<code class="code">WebxFrameworkFilter</code> -
                    <code class="filename">/WEB-INF/web.xml</code></strong></p><div class="example-contents"><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;web-app</strong> <span class="hl-attribute" style="color: #F5844C">version</span>=<span class="hl-value" style="color: #993300">"2.4"</span> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://java.sun.com/xml/ns/j2ee"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"
        http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd
    "</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
    <strong class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>webx<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-class&gt;</strong><span class="emphasis"><em>com.alibaba.citrus.webx.servlet.WebxFrameworkFilter</em></span><strong class="hl-tag" style="color: #000096">&lt;/filter-class&gt;</strong> <a id="co.webx.filter"><!--anchor co.webx.filter--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>excludes<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 需要被“排除”的URL路径，以逗号分隔，前缀!表示“包含”。例如/static, *.jpg, !/uploads/*.jpg --&gt;</em><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>  <a id="co.webx.filter.exclude"><!--anchor co.webx.filter.exclude--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>passthru<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><em class="hl-comment" style="color: green">&lt;!-- 需要被“略过”的URL路径，以逗号分隔，前缀!表示“不要略过”。例如/myservlet, *.jsp --&gt;</em><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>  <a id="co.webx.filter.passthru"><!--anchor co.webx.filter.passthru--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;filter-mapping&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;filter-name&gt;</strong>webx<strong class="hl-tag" style="color: #000096">&lt;/filter-name&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url-pattern&gt;</strong><span class="emphasis"><em>/*</em></span><strong class="hl-tag" style="color: #000096">&lt;/url-pattern&gt;</strong>  <a id="co.webx.filter.mapping"><!--anchor co.webx.filter.mapping--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/filter-mapping&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/web-app&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>定义<code class="code">WebxFrameworkFilter</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter.exclude"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可选的参数：“排除”指定名称的path，以逗号分隔，例如：<code class="code">/static</code>,
                                <code class="code">*.jpg</code>。如果路径以<code class="code">!</code>开始，表示“不排除”特殊目录。例如：<code class="code">*.jpg,
                                !/uploads/*.jpg</code>表示排除所有JPG图像文件，但不排除<code class="code">/uploads</code>目录下的JPG图像文件。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter.passthru"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>可选的参数：“略过”指定名称的path，以逗号分隔，例如：<code class="code">/myservlet</code>,
                                <code class="code">*.jsp</code>。和<code class="code">excludes</code>参数一样，也支持<code class="code">!</code>前缀，表示“不要略过”特殊目录。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.filter.mapping"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>匹配所有的path。</p></td></tr></table></div></div></div><p>为什么使用filter而不是servlet呢？传统的WEB框架的控制器一般都是用servlet实现的。原因是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Filter可以“返还控制” —— 上面的配置文件直接把“/*”映射到webx
                            filter中，这意味着webx接管了这个应用的所有请求。静态页面和资源怎么办？没关系，如果webx发现这个请求不应该由webx来处理，就会把控制“返还”给原来的控制器
                            ——
                            可能是另一个filter、servlet或者返回给servlet引擎，以默认的方式来处理。而Servlet是不具备“返还控制”的机制的。</p></li><li class="listitem"><p>Servlet/Filter mapping的局限性 ——
                            标准的servlet引擎将URL映射到filter或servlet时，只支持前缀映射和后缀映射两种方式，非常局限。而实际情况往往复杂得多。Webx建议将所有请求都映射给webx来处理，让webx对请求做更灵活的映射。
                        </p></li></ul></div><p>如果你的web.xml中还有一些其它的servlet
                    mappings，为了避免和Webx的URL起冲突，你可以把这些mapping加在<code class="code">excludes</code>或<code class="code">passthru</code>参数里。这样，WebxFrameworkFilter就会排除或略过指定的URL。例如：</p><pre class="programlisting">        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>excludes<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>/static, *.jpg, !/uploads/*.jpg</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;init-param&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-name&gt;</strong>passthru<strong class="hl-tag" style="color: #000096">&lt;/param-name&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;param-value&gt;</strong><span class="emphasis"><em>/myservlet, *.jsp</em></span><strong class="hl-tag" style="color: #000096">&lt;/param-value&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/init-param&gt;</strong></pre><p>“<code class="code">passthru</code>略过”和“<code class="code">excludes</code>排除”的区别在于，如果一个servlet或filter接手被webx
                    <code class="code">passthru</code>的请求时，它们还是可以访问到webx的部分服务，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">RequestContext</code>服务，例如：解析参数、解析upload请求、重写请求、设置字符集编码和区域、基于cookie的session等。</p></li><li class="listitem"><p>开发模式及工具。</p></li><li class="listitem"><p>异常处理。</p></li><li class="listitem"><p>共享webx的spring容器。</p></li></ul></div><p>也就是说，对于一个被<code class="code">passthru</code>的请求，webx的行为更像是一个普通的filter。而“排除”则不同，如果一个请求被“排除”，webx将会立即放弃控制，将请求交还给服务器。接手控制的servlet或filter将无法访问webx一切的服务。</p><p>下图是WebxFrameworkFilter处理一个WEB请求的过程。</p><div class="figure"><a id="d0e2031"><!--anchor d0e2031--></a><div class="figure-contents"><div class="mediaobject"><img src="images/o3/request-processing-detailed.png" alt="WebxFrameworkFilter处理请求的详细过程"/></div></div><p class="title"><strong>图 3.8. <code class="code">WebxFrameworkFilter</code>处理请求的详细过程</strong></p></div><p>如图所示，<code class="code">WebxFrameworkFilter</code>接到请求以后，就会调用<code class="code">WebxRootController</code>。从这里开始，进入Spring的世界
                ——
                    此后所有的对象：<code class="code">WebxRootController</code>、<code class="code">WebxController</code>、<code class="code">RequestContext</code>、<code class="code">Pipeline</code>等，全部是通过SpringExt配置在Spring
                Context中的。</p><p><code class="code">WebxRootController</code>对象存在于root
                    context中，它被所有子应用所共享。它会创建<code class="code">RequestContext</code>实例 ——
                    从而增强request、response、session的功能。接下来，<code class="code">WebxController</code>对象会被调用。</p><p><code class="code">WebxController</code>对象是由每个子应用独享的，子应用<code class="code">app1</code>和<code class="code">app2</code>可以有不同的<code class="code">WebxController</code>实现。默认的实现，会调用pipeline。</p><p>Pipeline也是由各子应用自己来配置的。假如pipeline碰到无法处理的请求，如静态页面、图片等，pipeline应当执行<code class="code">&lt;exit/&gt;</code>
                    valve强制退出。然后<code class="code">WebxRootController</code>就会“放弃控制” ——
                    这意味着request将被返还给<code class="filename">/WEB-INF/web.xml</code>中定义的servlet、filter或者返还给servlet
                engine本身来处理。 </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2093"><!--anchor d0e2093--></a>3.3. 定制Webx Framework</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2096"><!--anchor d0e2096--></a>3.3.1. 定制<code class="code">WebxRootController</code></h3></div></div></div><p><code class="code">WebxRootController</code>是被所有子应用所共享的逻辑。
                    假如你想创建一种新的WEB框架，可以自己定义一个新的<code class="code">WebxRootController</code>的实现。这个方案非常适合作为一个新Web框架的起点。</p><div class="example"><a id="d0e2108"><!--anchor d0e2108--></a><p class="title"><strong>例 3.10. 自定义<code class="code">WebxRootController</code></strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;webx-configuration</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;components&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rootController</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyRootController"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.webx.root.controller"><!--anchor co.webx.root.controller--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;/components&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.root.controller"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>创建自己的<code class="code">WebxRootController</code>。最简便的方法是：扩展<code class="code">AbstractWebxRootController</code>，免去了创建Servlet/Filter、初始化Spring容器、处理request、response等繁杂事务，并且完全支持SpringExt的所有功能，此外还包含了错误处理、开发模式等Webx
                            Framework中的一切便利。。 </p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2127"><!--anchor d0e2127--></a>3.3.2. 定制<code class="code">WebxController</code></h3></div></div></div><p><code class="code">WebxController</code>是用来控制子应用的。每个子应用可以拥有不同的<code class="code">WebxController</code>实现。</p><p>Webx
                    Framework默认的<code class="code">WebxController</code>是调用pipeline。假如你不想用pipeline，而希望实现自己的针对子应用的逻辑，那么最简单的方法就是实现自己的<code class="code">WebxController</code>或者扩展<code class="code">AbstractWebxController</code>。 </p><div class="example"><a id="d0e2150"><!--anchor d0e2150--></a><p class="title"><strong>例 3.11. 自定义WebxController</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;webx-configuration</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;components</strong> <span class="hl-attribute" style="color: #F5844C">defaultControllerClass</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyController"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.webx.controller.default"><!--anchor co.webx.controller.default--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;component</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"app1"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;controller</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.myframework.MyController"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.webx.controller.app"><!--anchor co.webx.controller.app--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
        <strong class="hl-tag" style="color: #000096">&lt;/component&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/components&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/webx-configuration&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.controller.default"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>指定默认的<code class="code">WebxController</code>实现类。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.webx.controller.app"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>对特定子应用明确指定<code class="code">WebxController</code>实现类。</p></td></tr></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e2172"><!--anchor d0e2172--></a>3.4. 本章总结</h2></div></div></div><p>Webx Framework提供了一个可剪裁、可扩展的处理WEB请求基本框架。它所提供的基本功能事实上是每个WEB框架都需要用到的。Webx
            Framework为进一步实现WEB框架提供了坚实的基础。</p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="springext.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="pt01.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="turbine.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 2 章 SpringExt </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 4 章 Webx Turbine</td></tr></table></div></body></html>