<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>第 7 章 Request Contexts功能指南</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="home" href="index.html" title="Webx框架指南"/><link rel="up" href="pt02.html" title="部分 II. Webx基础设施服务"/><link rel="prev" href="filter.html" title="第 6 章 Filter、Request Contexts和Pipeline"/><link rel="next" href="session.html" title="第 8 章 Request Context之Session指南"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 7 章 Request Contexts功能指南</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="filter.html">上一页</a> </td><th width="60%" align="center">部分 II. Webx基础设施服务</th><td width="20%" align="right"> <a accesskey="n" href="session.html">下一页</a></td></tr></table><hr/></div><div xml:lang="zh-CN" class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="webx.requestcontexts"><!--anchor webx.requestcontexts--></a>第 7 章 Request Contexts功能指南</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="requestcontexts.html#webx3.requestcontexts.basic">7.1. <code class="code">&lt;basic&gt;</code> - 提供基础特性</a></span></dt><dd><dl><dt><span class="section"><a href="requestcontexts.html#d0e6148">7.1.1. 拦截器接口</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e6263">7.1.2. 默认拦截器</a></span></dt></dl></dd><dt><span class="section"><a href="requestcontexts.html#webx3.requestcontexts.setlocale">7.2. <code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码</a></span></dt><dd><dl><dt><span class="section"><a href="requestcontexts.html#d0e6310">7.2.1. Locale基础</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e6385">7.2.2. Charset编码基础</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e6456">7.2.3. Locale和charset的关系</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e6620">7.2.4. 设置locale和charset</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e6788">7.2.5. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="requestcontexts.html#webx3.requestcontexts.parser">7.3. <code class="code">&lt;parser&gt;</code> - 解析参数</a></span></dt><dd><dl><dt><span class="section"><a href="requestcontexts.html#d0e7126">7.3.1. 基本使用方法</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e7262">7.3.2. 上传文件</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e7441">7.3.3. 高级选项</a></span></dt></dl></dd><dt><span class="section"><a href="requestcontexts.html#webx3.requestcontexts.buffered">7.4. <code class="code">&lt;buffered&gt;</code> - 缓存response中的内容</a></span></dt><dd><dl><dt><span class="section"><a href="requestcontexts.html#d0e7851">7.4.1. 实现原理</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e7918">7.4.2. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="requestcontexts.html#webx3.requestcontexts.lazycommit">7.5. <code class="code">&lt;lazy-commit&gt;</code> - 延迟提交response</a></span></dt><dd><dl><dt><span class="section"><a href="requestcontexts.html#d0e8029">7.5.1. 什么是提交</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8073">7.5.2. 实现原理</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8092">7.5.3. 使用方法</a></span></dt></dl></dd><dt><span class="section"><a href="requestcontexts.html#webx3.requestcontexts.rewrite">7.6. <code class="code">&lt;rewrite&gt;</code> -重写请求的URL和参数</a></span></dt><dd><dl><dt><span class="section"><a href="requestcontexts.html#d0e8198">7.6.1. 概述</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8268">7.6.2. 取得路径</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8308">7.6.3. 匹配rules</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8375">7.6.4. 匹配conditions</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8723">7.6.5. 替换路径</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8827">7.6.6. 替换参数</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8904">7.6.7. 后续操作 </a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e8971">7.6.8. 重定向</a></span></dt><dt><span class="section"><a href="requestcontexts.html#d0e9047">7.6.9. 自定义处理器</a></span></dt></dl></dd><dt><span class="section"><a href="requestcontexts.html#d0e9067">7.7. 本章总结</a></span></dt></dl></div><p>在<a class="xref" href="filter.html" title="第 6 章 Filter、Request Contexts和Pipeline">第 6 章 <em>Filter、Request Contexts和Pipeline</em></a>中，我们已经介绍了Request
        Contexts服务的作用和原理。本章我们将介绍除了session机制以外，每一个可用的Request
            Context的功能和用法。由于Session机制比较复杂，所以我们另辟单独的一章（<a class="xref" href="session.html" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>）来解释它。</p><p>本章涉及的内容包括： </p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="16%" class="c1"/><col width="33%" class="c2"/><col width="51%" class="c3"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">名称</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">接口</th><th style="border-bottom: 0.5pt solid #6666cc; ">功能</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;basic&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">BasicRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">提供基础安全特性，例如：过滤response headers、cookies，限制cookie的大小等。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;set-locale&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">SetLocaleRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">设置locale区域和charset字符集编码。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;parser&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">ParserRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">解析参数，支持<code class="code">multipart/form-data</code>（即上传文件请求）。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;buffered&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">BufferedRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">缓存response中的内容。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;lazy-commit&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">LazyCommitRequestContext</code></td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">延迟提交response。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">&lt;rewrite&gt;</code></td><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">RewriteRequestContext</code></td><td style="" valign="middle">重写请求的URL和参数。</td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.basic"><!--anchor webx3.requestcontexts.basic--></a>7.1. <code class="code">&lt;basic&gt;</code> - 提供基础特性</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6148"><!--anchor d0e6148--></a>7.1.1. 拦截器接口</h3></div></div></div><p><code class="code">BasicRequestContext</code>提供了一组interceptors拦截器接口，通过它们，你可以拦截并干预一些事件。</p><div class="figure"><a id="d0e6155"><!--anchor d0e6155--></a><div class="figure-contents"><div class="mediaobject"><img src="images/requestcontexts/basic-rc.png" alt="BasicRequestContext所提供的拦截器"/></div></div><p class="title"><strong>图 7.1. <code class="code">BasicRequestContext</code>所提供的拦截器</strong></p></div><p>你可以在<code class="code">&lt;basic&gt;</code>中指定上图所示的任何一个<code class="code">Interceptor</code>接口，以便干预特定的事件：</p><div class="table"><a id="d0e6171"><!--anchor d0e6171--></a><p class="title"><strong>表 7.1. <code class="code">BasicRequestContext</code>所提供的拦截器</strong></p><div class="table-contents"><table summary="BasicRequestContext所提供的拦截器" cellpadding="10" style="border: none;"><colgroup><col width="43%" class="c1"/><col width="57%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">拦载器接口</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <code class="code">RequestContextLifecycleInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截“预处理（prepare）”和“提交（commit）”事件。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <code class="code">ResponseHeaderInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对response header的修改。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">HeaderNameInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对header的修改、添加操作。可修改header name，或拒绝对header的修改。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">HeaderValueInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对header的修改、添加操作。可修改header value，或拒绝对header的修改。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">CookieInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有对cookie的添加操作。可修改或拒绝cookie对象。需要注意的是，有两种方法可以添加cookie：通过cookie对象，或者直接写response
                                    header。对于后者，需要使用<code class="code">CookieHeaderValueInterceptor</code>才能拦截得到。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">CookieHeaderValueInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有通过添加header来创建cookie的操作。可修改或拒绝该cookie。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">RedirectLocaitonInterceptor</code>
                            </td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">拦截所有外部重定向的操作。可修改或拒绝重定向URL。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle">➥ <code class="code">StatusMessageInterceptor</code>
                            </td><td style="" valign="middle">拦截所有设置status message的操作。可以修改或拒绝该message。</td></tr></tbody></table></div></div><p>通过下面的配置，就可以指定任意多个interceptor的实现。</p><div class="example"><a id="d0e6255"><!--anchor d0e6255--></a><p class="title"><strong>例 7.1. 配置interceptors（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;basic&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;request-contexts:interceptors</strong>
            <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts/basic/interceptors"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/request-contexts:interceptors&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/basic&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6263"><!--anchor d0e6263--></a>7.1.2. 默认拦截器</h3></div></div></div><p>即使你不加说明，<code class="code">BasicRequestContext</code>也总是会启用一个默认的interceptor实现：<code class="code">ResponseHeaderSecurityFilter</code>。这个类实现了下列功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>避免header name和value中出现CRLF字符 ──
                            在header中嵌入CRLF（回车换行）字符是一种常见的攻击手段。攻击者嵌入CRLF以后，使服务器对HTTP请求发生错误判断，从而执行攻击者的恶意代码。事实上，现在的servlet引擎如tomcat已经可以防御这种攻击。但作为框架，并不能依赖于特定的servlet引擎，所以加上这个额外的安全检查，确保万无一失。</p></li><li class="listitem"><p>将status message用HTML entity编码重写 ── 通常status
                            message会被显示在HTML页面中。攻击者可以利用这一点在页面中嵌入恶意代码。将status message以HTML
                            entity编码重写以后，就可以避免这个问题。</p></li><li class="listitem"><p>限制cookie的总大小 ──
                            过大的cookie可能使WEB服务器拒绝响应请求。攻击者同样可以利用这一点使用户无法正常访问网站。限制cookie的总大小可以部分地解决这种危机。</p></li></ul></div><p>如果需要，你可以对<code class="code">ResponseHeaderSecurityFilter</code>指定一些参数。</p><div class="example"><a id="d0e6289"><!--anchor d0e6289--></a><p class="title"><strong>例 7.2. 配置<code class="code">ResponseHeaderSecurityFilter</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;request-contexts:interceptors</strong>
            <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts/basic/interceptors"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;interceptor</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"...Interceptor2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;response-header-security-filter</strong> <span class="hl-attribute" style="color: #F5844C">maxSetCookieSize</span>=<span class="hl-value" style="color: #993300">"5K"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/request-contexts:interceptors&gt;</strong></pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.setlocale"><!--anchor webx3.requestcontexts.setlocale--></a>7.2. <code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码</h2></div></div></div><p>区域和编码问题（尤其是后者）是每个WEB应用都必须处理好的基本问题。它虽然本身并不复杂，但是在现实开发中，由于涉及面很广，一旦发生问题（例如乱码）经常让人手足无措。<code class="code">&lt;set-locale&gt;</code>提供了一个机制，确保Web应用能够设置正确的区域和编码。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6310"><!--anchor d0e6310--></a>7.2.1. Locale基础</h3></div></div></div><p>Locale是国际化的基础。</p><p>一个locale的格式是：<code class="code">language_country_variant</code>，例如：<code class="code">zh_CN</code>、<code class="code">zh_TW</code>、<code class="code">en_US</code>、<code class="code">es_ES_Traditional_WIN</code>等。</p><p>Java和框架根据不同的locale，可以取得不同的文本、对象。下面的Java代码根据不同的locale，取得不同语言版本的文字： </p><div class="example"><a id="d0e6334"><!--anchor d0e6334--></a><p class="title"><strong>例 7.3. 利用<code class="code">ResourceBundle</code>和locale取得国际化字符</strong></p><div class="example-contents"><pre class="programlisting">Locale.setDefault(Locale.US);

String s1 = getResourceBundle(Locale.CHINA).getString(<strong class="hl-string"><em style="color:navy">"happy"</em></strong>); <em class="hl-comment" style="color: green">// 快乐</em>
String s2 = getResourceBundle(Locale.TAIWAN).getString(<strong class="hl-string"><em style="color:navy">"happy"</em></strong>); <em class="hl-comment" style="color: green">// 快樂</em>
String s3 = getResourceBundle(Locale.US).getString(<strong class="hl-string"><em style="color:navy">"happy"</em></strong>); <em class="hl-comment" style="color: green">// happy</em>
...
ResourceBundle getResourceBundle(Locale locale) {
    <strong class="hl-keyword" style="color: maroon">return</strong> ResourceBundle.getBundle(<strong class="hl-string"><em style="color:navy">"ApplicationResources"</em></strong>, locale);
}</pre><p>其中所用到的<code class="code">ResourceBundle</code>文件定义如下：</p><div class="informaltable"><table cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="filename">ApplicationResources.properties</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">happy </span>= happy</pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="filename">ApplicationResources_zh_CN.properties</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">happy </span>= \u5FEB\u4E50</pre>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="filename">ApplicationResources_zh_TW.properties</code>
                                </td><td style="">
                                    <pre class="programlisting"><span class="hl-attribute" style="color: #F5844C">happy </span>= \u5FEB\u6A02</pre>
                                </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6385"><!--anchor d0e6385--></a>7.2.2. Charset编码基础</h3></div></div></div><p>Charset全称Character
                    Encoding或字符集编码。Charset是将字符（characters）转换成字节（bytes）或者将字节转换成字符的算法。Java内部采用unicode来表示一个字符。将unicode字符转换成字节的过程，称为“<span class="emphasis"><em>编码</em></span>”；将字节恢复成unicode字符的过程，称为“<span class="emphasis"><em>解码</em></span>”。</p><p>浏览器发送给WEB应用的request参数，是以字节流的方式来表示的。Request参数必须经过解码才能被Java程序所解读。用来解码request参数的charset被称为“<span class="emphasis"><em>输入字符集编码（Input
                    Charset）</em></span>”；</p><p>WEB应用返回给浏览器的response响应内容必须编码成字节流，才能被浏览器或客户端解读。用来编码response内容的charset被称为“<span class="emphasis"><em>输出字符集编码（Output
                    Charset）</em></span>”。</p><p>一般情况下，input charset和output
                    charset是相同的。因为浏览器发送表单数据时，总是采用当前页面的charset来编码的。例如，有一个表单页面，它的“<code class="code">contentType=text/html;
                    charset=GBK</code>”，那么用户填完全表单并提交时，浏览器会以<code class="code">GBK</code>来编码用户所输入的表单数据。如果input
                charset和output charset不相同，服务器就不能正确解码浏览器根据output charset所发回给WEB应用的表单数据。</p><p>然而有一些例外情况下面，输入和输出的charset可能会不同：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>通过Java
                            Script发送的表单，总是用<code class="code">UTF-8</code>编码的。这意味着你必须用<code class="code">UTF-8</code>作为input
                            charset方能正确解码参数。这样，除非output
                            charset也是<code class="code">UTF-8</code>，否则两者就是不同的。</p></li><li class="listitem"><p>应用间互相用HTTP访问时，可能采用不同的编码。例如，应用A以<code class="code">UTF-8</code>访问应用B，而应用B是以<code class="code">GBK</code>作为input/output
                            charset的。此时会产生参数解码的错误。</p></li><li class="listitem"><p>直接在浏览器地址栏里输入包含参数的URL，根据不同的浏览器和操作系统的设置，会有不同的结果：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>例如，中文Windows中，无论ie还是firefox，经试验，默认都以<code class="code">GBK</code>来编码参数。IE对直接输入的参数，连URL
                                        encoding也没做。</p></li><li class="listitem"><p>而在mac系统中，无论safari还是firefox，经试验，默认都是以<code class="code">UTF-8</code>来编码参数。
                                    </p></li></ul></div></li></ul></div><p>框架必须要能够应付上面各种不确定的charset编码。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6456"><!--anchor d0e6456--></a>7.2.3. Locale和charset的关系</h3></div></div></div><p>Locale和charset是相对独立的两个参数，但是又有一定的关系。</p><p>Locale决定了要显示的文字的语言，而charset则将这种语言的文字编码成bytes或从bytes解码成文字。因此，charset必须能够涵盖locale所代表的语言文字，如果不能，则可能出现乱码。下表列举了一些locale和charset的组合：</p><div class="table"><a id="d0e6463"><!--anchor d0e6463--></a><p class="title"><strong>表 7.2. Locale和Charset的关系</strong></p><div class="table-contents"><table summary="Locale和Charset的关系" cellpadding="10" style="border: none;"><colgroup><col width="40%" align="center" class="c1"/><col width="16%" align="center" class="c2"/><col width="8%" align="center" class="c3"/><col width="8%" align="center" class="c4"/><col width="8%" align="center" class="c5"/><col width="12%" align="center" class="c6"/><col width="8%" align="center" class="c7"/></colgroup><thead valign="middle"><tr><th style="border-right: 0.5pt solid #6666cc; " rowspan="2" align="center" valign="middle">Locale</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">英文字符集</th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " colspan="3" align="center" valign="middle">中文字符集</th><th style="border-bottom: 0.5pt solid #6666cc; " colspan="2" align="center" valign="middle">全字符集</th></tr><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">ISO-8859-1</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">GB2312</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">Big5</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">GBK</code>
                            </th><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">GB18030</code>
                            </th><th style="border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">
                                <code class="code">UTF-8</code>
                            </th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"><code class="code">en_US</code>（美国英文）</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"><code class="code">zh_CN</code>（简体中文）</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-bottom: 0.5pt solid #6666cc; " align="center" valign="middle">√</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle"><code class="code">zh_TW</code>、<code class="code">zh_HK</code>（台湾中文、香港中文）</td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle"> </td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="border-right: 0.5pt solid #6666cc; " align="center" valign="middle">√</td><td style="" align="center" valign="middle">√</td></tr></tbody></table></div></div><p>在所有charset中，有几个“全能”编码：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">UTF-8</code></span></dt><dd><p>涵盖了unicode中的所有字符。然而用<code class="code">UTF-8</code>来编码中文为主的页面时，每个中文会占用3个字节。建议以非中文为主的页面采用<code class="code">UTF-8</code>编码。</p></dd><dt><span class="term"><code class="code">GB18030</code></span></dt><dd><p>中文国际标准，和<code class="code">UTF-8</code>一样，涵盖了unicode中的所有字符。用<code class="code">GB18030</code>来编码中文为主的页面时有一定优势，因为绝大多数常用中文仅占用2个字节，比<code class="code">UTF-8</code>短1/3。然而<code class="code">GB18030</code>在非中文的操作系统中，有可能不能识别，其通用性不如<code class="code">UTF-8</code>好。因此仅建议以中文为主的页面采用<code class="code">GB18030</code>编码。</p></dd><dt><span class="term"><code class="code">GBK</code></span></dt><dd><p>严格说，<code class="code">GBK</code>不是全能编码（例如对很多西欧字符就支持不好），也不是国际标准。但它支持的字符数量接近于<code class="code">GB18030</code>。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6620"><!--anchor d0e6620--></a>7.2.4. 设置locale和charset</h3></div></div></div><p>在Servlet API中，以下API是和locale和charset有关的。</p><div class="table"><a id="d0e6625"><!--anchor d0e6625--></a><p class="title"><strong>表 7.3. 和locale、charset相关的servlet API</strong></p><div class="table-contents"><table summary="和locale、charset相关的servlet API" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="35%" class="c1"/><col width="27%" class="c2"/><col width="38%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3"><code class="code">HttpServletRequest</code></th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getCharacterEncoding()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">读取输入编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setCharacterEncoding(charset)</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">设置输入编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>必须在第一次调用<code class="code">request.getParameter()</code>
                                                和<code class="code">request.getParameterMap()</code>前设置，否则无效。</p></li><li class="listitem"><p>如果不设置，则默认以<code class="code">ISO-8859-1</code>来解码参数。</p></li><li class="listitem"><p>一般只影响POST请求参数的解码，但这里有一些复杂性，参见<a class="xref" href="requestcontexts.html#webx3.requestcontexts.parser" title="7.3. &lt;parser&gt; - 解析参数">第 7.3 节 “<code class="code">&lt;parser&gt;</code> - 解析参数”</a>。</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getLocale()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得Accept-Language中浏览器首选的locale</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getLocales()</code></td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">取得所有Accept-Language中所指定的locales</td><td style="" valign="middle"> </td></tr></tbody></table><table summary="和locale、charset相关的servlet API" cellpadding="10" style="border-collapse: collapse;border-top: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; border-left: 0.5pt solid #6666cc; border-right: 0.5pt solid #6666cc; "><colgroup><col width="35%" class="c1"/><col width="27%" class="c2"/><col width="38%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3"><code class="code">HttpServletResponse</code></th></tr></thead><tbody valign="middle"><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getCharacterEncoding()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得输出编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setCharacterEncoding(charset)</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">设置输出编码</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Since Servlet 2.4</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getContentType()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得content type</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Since Servlet 2.4</p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setContentType(contentType)</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">设置content type</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Content type中可能包含charset定义，例如：<code class="code">text/html;
                                                charset=GBK</code></p></li></ul></div>
                            </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle"><code class="code">.getLocale()</code></td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; " valign="middle">取得输出locale</td><td style="border-bottom: 0.5pt solid #6666cc; " valign="middle"> </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; " valign="middle"><code class="code">.setLocale(locale)</code></td><td style="border-right: 0.5pt solid #6666cc; " valign="middle">设置输出locale</td><td style="" valign="middle">
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>必须在response被commit之前调用，否则无效。</p></li><li class="listitem"><p>它同时也会设置charset，除非content
                                            type已经被设置过，并用包含了charset的定义。</p></li></ul></div>
                            </td></tr></tbody></table></div></div><p>设置locale和charset是一件看起来容易，做起来不容易的事：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>输入编码必须<span class="emphasis"><em>在第一个读取request参数的调用之前</em></span>设置好，否则就无效。只有把<code class="code">&lt;set-locale&gt;</code>作为Request
                            Contexts服务的一环，才有可能确保读取request参数之前，设置好输入编码。</p></li><li class="listitem"><p>在Servlet 2.3之前，设置输出参数的唯一方法，是通过设置带有charset定义的content type。这一点在Servlet
                                2.4以后得到改进，添加了独立的设置输出编码的方法。<code class="code">&lt;set-locale&gt;</code>弥补了Servlet
                            2.3和Servlet 2.4之间的差异，使WEB应用在所有的环境下，都可以独立设置content type和charset。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6788"><!--anchor d0e6788--></a>7.2.5. 使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6791"><!--anchor d0e6791--></a>7.2.5.1. 使用默认值</h4></div></div></div><div class="example"><a id="d0e6794"><!--anchor d0e6794--></a><p class="title"><strong>例 7.4. 设置默认的locale和charset</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"GB18030"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div><p>上面的配置，将WEB应用的输入charset、输出charset均设置成<code class="code">GB18030</code>，将输出locale设置成<code class="code">zh_CN</code>。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6807"><!--anchor d0e6807--></a>7.2.5.2. 临时覆盖默认的charset</h4></div></div></div><p>前面讲到在一些情况下面，服务器所收到的参数（表单数据）不是用应用默认的charset来编码的。例如Java
                        Script总是以<code class="code">UTF-8</code>来提交表单；系统间通过HTTP协议通信；或者用户直接在浏览器地址栏中输入参数。</p><p>如何应付这些不确定的charset呢？<code class="code">&lt;set-locale&gt;</code>提供的方法是，在URL中指定输入编码，并覆盖默认值。</p><p>假设当前应用的默认值是<code class="code">defaultLocale=zh_CN</code>、<code class="code">defaultCharset=GB18030</code>，那么下面的请求将使用默认的<code class="code">GB18030</code>来解码参数，并用默认的<code class="code">GB18030</code>来输出页面：</p><pre class="screen">http://localhost:8081/myapp/myform</pre><p>假如你希望改用<code class="code">UTF-8</code>来解码参数，那么可以使用下面的URL来覆盖默认值：</p><div class="example"><a id="d0e6841"><!--anchor d0e6841--></a><p class="title"><strong>例 7.5. 在URL中覆盖默认的input charset</strong></p><div class="example-contents"><pre class="screen">http://localhost:8081/myapp/myform<span class="emphasis"><em>?_input_charset=UTF-8</em></span></pre></div></div><p>这样，Webx将采用<code class="code">UTF-8</code>来解码参数，但<span class="emphasis"><em>仍然使用默认的<code class="code">GB18030</code>来输出页面</em></span>。</p><p>需要注意的是，对于POST请求，你必须把<code class="code">_input_charset</code>这个特殊的参数写在URL中，而不能写成普通的表单字段，例如：</p><div class="example"><a id="d0e6864"><!--anchor d0e6864--></a><p class="title"><strong>例 7.6. 在POST表单中覆盖默认的input charset</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">"http://localhost:8081/myapp/myform?_input_charset=UTF-8"</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"POST"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.charset.override.post"><!--anchor co.charset.override.post--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"param1"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"value1"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"hidden"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"param2"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"value2"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.charset.override.post"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>必须把<code class="code">_input_charset</code>这个特殊的参数写在URL中，即便是POST类型的表单。</p></td></tr></table></div></div></div><p>在写AJAX Java Script代码时，也要注意：</p><div class="example"><a id="d0e6880"><!--anchor d0e6880--></a><p class="title"><strong>例 7.7. 在AJAX代码中覆盖默认的input charset</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">var</strong> xhreq = <strong class="hl-keyword" style="color: maroon">new</strong> XMLHttpRequest();
xhreq.open(<strong class="hl-string"><em style="color:navy">"post"</em></strong>, <strong class="hl-string"><em style="color:navy">"/myapp/myform?_input_charset=UTF-8"</em></strong>, true); <a id="co.charset.override.ajax"><!--anchor co.charset.override.ajax--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
...
xhreq.send(<strong class="hl-string"><em style="color:navy">"a=1&amp;b=2"</em></strong>);</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.charset.override.ajax"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>必须把<code class="code">_input_charset</code>这个特殊的参数写在URL中。</p></td></tr></table></div></div></div><p>此外，<code class="code">&lt;set-locale&gt;</code>也提供了临时覆盖输出编码的方法：</p><div class="example"><a id="d0e6899"><!--anchor d0e6899--></a><p class="title"><strong>例 7.8. 在URL中覆盖默认的output charset</strong></p><div class="example-contents"><pre class="screen">http://localhost:8081/myapp/myform<span class="emphasis"><em>?_output_charset=UTF-8</em></span></pre></div></div><p>临时覆盖的输入、输出编码只会影响当前请求，它不会被记住。当一个不带有覆盖参数的请求进来时，将仍然按照默认值来设置输入、输出编码。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6908"><!--anchor d0e6908--></a>7.2.5.3. 持久覆盖默认的locale和charset</h4></div></div></div><p>还有一种需求，就是多语言网页的支持。用户可以选择自己的语言：简体中文、繁体中文等。一旦用户作出选择，那么后续的网页将全部以用户所选择的语言和编码来显示。<code class="code">&lt;set-locale&gt;</code>直接支持这个功能。只要你按下面的URL访问页面，用户的语言和编码即被切换成简体中文和<code class="code">UTF-8</code>编码。</p><div class="example"><a id="d0e6919"><!--anchor d0e6919--></a><p class="title"><strong>例 7.9. 持久覆盖默认的locale和charset</strong></p><div class="example-contents"><pre class="screen">http://localhost:8081/myapp<span class="emphasis"><em>?_lang=zh_CN:UTF-8</em></span></pre></div></div><p>参数值<code class="code">_lang=zh_CN:UTF-8</code>将被保存在session中，后续的请求不需要再次指定<code class="code">_lang</code>参数。用户所作出的选择将一直持续在整个session中，直到session被作废。</p><p>需要说明的是，假如我们采用了<code class="code">&lt;session&gt;</code> request
                    context来取代原来的session机制，那么该参数实际的保存位置将取决于session框架的设置 ──
                        例如：你可以把参数值保存在某个cookie中。然而，<code class="code">&lt;set-locale&gt;</code>并不需要关心于session的实现细节或是用来保存参数的cookie的细节。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6942"><!--anchor d0e6942--></a>7.2.5.4. <code class="code">&lt;set-locale&gt;</code>的影响力</h4></div></div></div><p><code class="code">&lt;set-locale&gt;</code>所设置的<span class="emphasis"><em>输出locale</em></span>和<span class="emphasis"><em>输出charset</em></span>值将会被保存在当前线程中，从而对整个线程产生影响。</p><div class="table"><a id="d0e6957"><!--anchor d0e6957--></a><p class="title"><strong>表 7.4. 被&lt;set-locale&gt;影响的API</strong></p><div class="table-contents"><table summary="被&lt;set-locale&gt;影响的API" cellpadding="10" style="border: none;"><colgroup><col width="43%" class="c1"/><col width="57%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">API</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">LocaleUtil.getContext().getLocale()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="2">可以通过这两个方法取得当前线程的输出locale和charset。Webx框架中凡是要用到默认locale和charset的地方，都会从这里去取得值。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">LocaleUtil.getContext().getCharset()</code>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">StringEscapeUtil.escapeURL()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; " rowspan="2">Webx调用这两个方法进行URL编码、解码时，不需要指定charset（不同于JDK的<code class="code">URLEncoder</code>/<code class="code">URLDecoder</code>）。这两个函数将从<code class="code">LocaleUtil.getContext().getCharset()</code>中取得当前线程的输出charset。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">StringEscapeUtil.unescapeURL()</code>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">TemplateService</code>
                                </td><td style=""><code class="code">TemplateService</code>如果指定了<code class="code">searchLocalizedTemplates=true</code>参数，那么它会利用当前线程的locale来搜索本地化的模板，例如：
                                        <code class="code">screen/myTemplate_zh_CN.vm</code></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7022"><!--anchor d0e7022--></a>7.2.5.5. <code class="code">&lt;set-locale&gt;</code>的配置参数</h4></div></div></div><div class="example"><a id="d0e7027"><!--anchor d0e7027--></a><p class="title"><strong>例 7.10. <code class="code">&lt;set-locale&gt;</code>的配置参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;set-locale</strong> <span class="hl-attribute" style="color: #F5844C">defaultLocale</span>=<span class="hl-value" style="color: #993300">"..."</span>
            <span class="hl-attribute" style="color: #F5844C">defaultCharset</span>=<span class="hl-value" style="color: #993300">"..."</span>
            <span class="hl-attribute" style="color: #F5844C">inputCharsetParam</span>=<span class="hl-value" style="color: #993300">"_input_charset"</span>
            <span class="hl-attribute" style="color: #F5844C">outputCharsetParam</span>=<span class="hl-value" style="color: #993300">"_output_charset"</span>
            <span class="hl-attribute" style="color: #F5844C">paramKey</span>=<span class="hl-value" style="color: #993300">"_lang"</span>
            <span class="hl-attribute" style="color: #F5844C">sessionKey</span>=<span class="hl-value" style="color: #993300">"_lang"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><div class="table"><a id="d0e7034"><!--anchor d0e7034--></a><p class="title"><strong>表 7.5. <code class="code">&lt;set-locale&gt;</code>配置参数说明</strong></p><div class="table-contents"><table summary="&lt;set-locale&gt;配置参数说明" cellpadding="10" style="border: none;"><colgroup><col width="31%" class="c1"/><col width="69%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">defaultLocale</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">默认locale。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">defaultCharset</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">默认charset。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">inputCharsetParam</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">用来临时改变输入charset的参数名，支持多个名称，以“<code class="code">|</code>”分隔，例如“<code class="code">_input_charset|ie</code>”。
                                        默认值为“<code class="code">_input_charset</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">outputCharsetParam</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">用来临时改变输出charset的参数名，支持多个名称，以“<code class="code">|</code>”分隔，例如“<code class="code">_output_charset|oe</code>”。
                                        默认为“<code class="code">_output_charset</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">paramKey</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">用来持久改变输出locale和charset的参数名，默认为“<code class="code">_lang</code>”。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">sessionKey</code>
                                </td><td style="">用来在session中保存用户所选择的locale和charset的key，默认为“<code class="code">_lang</code>”。</td></tr></tbody></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.parser"><!--anchor webx3.requestcontexts.parser--></a>7.3. <code class="code">&lt;parser&gt;</code> - 解析参数</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7126"><!--anchor d0e7126--></a>7.3.1. 基本使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7129"><!--anchor d0e7129--></a>7.3.1.1. 基本配置</h4></div></div></div><div class="example"><a id="d0e7132"><!--anchor d0e7132--></a><p class="title"><strong>例 7.11. <code class="code">&lt;parser&gt;</code>基本配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;parser /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span> <span class="hl-attribute" style="color: #F5844C">fileSizeMax</span>=<span class="hl-value" style="color: #993300">"2M"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>绝大多数情况，你只需要上面的配置就足够了 ── <code class="code">&lt;parser&gt;</code>会自动解析所有类型的请求，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GET请求</p></li><li class="listitem"><p>普通的POST请求（Content
                                    Type：<code class="code">application/x-www-form-urlencoded</code>）</p></li><li class="listitem"><p>可上传文件的POST请求（Content Type：<code class="code">multipart/form-data</code>）</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7160"><!--anchor d0e7160--></a>7.3.1.2. 通过<code class="code">HttpServletRequest</code>接口访问参数</h4></div></div></div><p><code class="code">&lt;parser&gt;</code>对于大部分应用是透明的。也就是说，你不需要知道<code class="code">&lt;parser&gt;</code>的存在，就可以访问所有的参数，包括访问<code class="code">multipart/form-data</code>请求的参数。</p><div class="example"><a id="d0e7176"><!--anchor d0e7176--></a><p class="title"><strong>例 7.12. 通过<code class="code">HttpServletRequest</code>接口访问参数</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
HttpServletRequest request;

...
String s = request.getParameter(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7184"><!--anchor d0e7184--></a>7.3.1.3. 通过<code class="code">ParserRequestContext</code>接口访问参数</h4></div></div></div><p>你也可以选择使用<code class="code">ParserRequestContext</code>接口。</p><div class="example"><a id="d0e7195"><!--anchor d0e7195--></a><p class="title"><strong>例 7.13. 通过<code class="code">ParserRequestContext</code>接口访问参数</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
ParserRequestContext parser;

...
String s = parser.getParameters().getString(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div><p>和<code class="code">HttpServletRequest</code>接口相比，<code class="code">ParserRequestContext</code>提供了如下便利：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">直接取得指定类型的参数，例如：直接取得<code class="code">int</code>、<code class="code">boolean</code>值等。</span></dt><dd><div class="example"><a id="d0e7222"><!--anchor d0e7222--></a><p class="title"><strong>例 7.14. 直接取得指定类型的参数</strong></p><div class="example-contents"><pre class="programlisting"><em class="hl-comment" style="color: green">// myparam=true, myparam=false</em>
parser.getParameters().getBoolean(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);

<em class="hl-comment" style="color: green">// myparam=123</em>
parser.getParameters().getInt(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>);</pre></div></div></dd><dt><span class="term">如果参数值未提供，或者值为空，则返回指定默认值。</span></dt><dd><div class="example"><a id="d0e7231"><!--anchor d0e7231--></a><p class="title"><strong>例 7.15. 取得参数的默认值</strong></p><div class="example-contents"><pre class="programlisting">parser.getParameters().getBoolean(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, false);
parser.getParameters().getString(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, <strong class="hl-string"><em style="color:navy">"no_value"</em></strong>);
parser.getParameters().getInt(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, -<span class="hl-number">1</span>);</pre></div></div></dd><dt><span class="term">取得上传文件的<code class="code">FileItem</code>对象（这是Apache Jakarta
                                项目commons-fileupload所定义的接口）。</span></dt><dd><div class="example"><a id="d0e7243"><!--anchor d0e7243--></a><p class="title"><strong>例 7.16. 取得<code class="code">FileItem</code>上传文件</strong></p><div class="example-contents"><pre class="programlisting">FileItem fileItem = parser.getParameters().getFileItem(<strong class="hl-string"><em style="color:navy">"myfile"</em></strong>);
FileItem[] fileItems = parser.getParameters().getFileItems(<strong class="hl-string"><em style="color:navy">"myfile"</em></strong>);</pre></div></div></dd><dt><span class="term"><code class="code">ParserRequestContext</code>还提供了比较方便的访问cookie值的方法。</span></dt><dd><div class="example"><a id="d0e7257"><!--anchor d0e7257--></a><p class="title"><strong>例 7.17. 访问cookie值</strong></p><div class="example-contents"><pre class="programlisting">parser.getCookies().getString(<strong class="hl-string"><em style="color:navy">"mycookie"</em></strong>);</pre></div></div></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7262"><!--anchor d0e7262--></a>7.3.2. 上传文件</h3></div></div></div><p>用于上传文件的请求是一种叫作<code class="code">multipart/form-data</code>的特殊请求，它的格式类似于富文本电子邮件的样子。下面HTML创建了一个支持上传文件的表单：</p><div class="example"><a id="d0e7270"><!--anchor d0e7270--></a><p class="title"><strong>例 7.18. 创建<code class="code">multipart/form-data</code>表单</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;form</strong> <span class="hl-attribute" style="color: #F5844C">action</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">method</span>=<span class="hl-value" style="color: #993300">"post"</span> <span class="hl-attribute" style="color: #F5844C">enctype</span>=<span class="hl-value" style="color: #993300">"multipart/form-data"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;input</strong> <span class="hl-attribute" style="color: #F5844C">type</span>=<span class="hl-value" style="color: #993300">"file"</span> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myfile"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">""</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/form&gt;</strong></pre></div></div><p>提示：不是只有需要上传文件时，才可以用<code class="code">multipart/form-data</code>表单。<span class="emphasis"><em>假如你的表单中包含富文本字段（即字段的内容是以
                        HTML或类似的技术描述的），特别是当字段的内容比较长的时候，用<code class="code">multipart/form-data</code>比用普通的表单更高效，生成的HTTP请求也更短</em></span>。</p><p>只要upload服务存在，那么<code class="code">&lt;parser&gt;</code>就可以解析<code class="code">multipart/form-data</code>（即上传文件）的请求。Upload服务扩展于Apache
                Jakarta的一个项目：commons-fileupload。 </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7297"><!--anchor d0e7297--></a>7.3.2.1. 配置Upload服务</h4></div></div></div><div class="example"><a id="d0e7300"><!--anchor d0e7300--></a><p class="title"><strong>例 7.19. Upload服务的配置参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:upload</strong> <span class="hl-attribute" style="color: #F5844C">sizeMax</span>=<span class="hl-value" style="color: #993300">"5M"</span>
                 <span class="hl-attribute" style="color: #F5844C">fileSizeMax</span>=<span class="hl-value" style="color: #993300">"2M"</span>
                 <span class="hl-attribute" style="color: #F5844C">repository</span>=<span class="hl-value" style="color: #993300">"/tmp"</span>
                 <span class="hl-attribute" style="color: #F5844C">sizeThreshold</span>=<span class="hl-value" style="color: #993300">"10K"</span>
                 <span class="hl-attribute" style="color: #F5844C">keepFormFieldInMemory</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>各参数的说明如下：</p><div class="table"><a id="d0e7307"><!--anchor d0e7307--></a><p class="title"><strong>表 7.6. Upload服务配置参数说明</strong></p><div class="table-contents"><table summary="Upload服务配置参数说明" cellpadding="10" style="border: none;"><colgroup><col width="33%" class="c1"/><col width="67%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数名称</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">sizeMax</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">HTTP请求的最大尺寸（字节，支持K/M/G），超过此尺寸的请求将被抛弃。值<code class="code">-1</code>表示没有限制。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">fileSizeMax</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">单个文件允许的最大尺寸（字节，支持K/M/G），超过此尺寸的文件将被抛弃。值<code class="code">-1</code>表示没有限制。
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">repository</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">暂存上传文件的目录。 注意，这个目录是用Spring
                                        <code class="code">ResourceLoader</code>装载的，而不是一个物理路径。关于<code class="code">ResourceLoader</code>，详见ResourceLoading服务的文档。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">sizeThreshold</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">将文件放在内存中的阈值（字节，支持K/M/G），小于此值的文件被保存在内存中。 </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">keepFormFieldInMemory</code>
                                </td><td style="">是否将普通的form field保持在内存里？
                                        默认为<code class="code">false</code>，但当<code class="code">sizeThreshold</code>为<code class="code">0</code>时，默认为<code class="code">true</code>。</td></tr></tbody></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"/></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>当上传文件的请求的总尺寸超过<code class="code">sizeMax</code>的值时，整个请求将被抛弃 ——
                            这意味着你不可能读到请求中的其它任何参数。而当某个上传文件的尺寸超出<code class="code">fileSizeMax</code>的限制，但请求的总尺寸仍然在<code class="code">sizeMax</code>的范围内时，只有超出该尺寸的单个上传文件被抛弃，而你还是可以读到其余的参数。</p></td></tr></table></div><p>假如有多个upload服务（当然这种情况极少），你也可以明确指定<code class="code">&lt;parser&gt;</code>使用哪个upload服务：</p><div class="example"><a id="d0e7401"><!--anchor d0e7401--></a><p class="title"><strong>例 7.20. 明确指定upload服务</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">uploadServiceRef</span>=<span class="hl-value" style="color: #993300">"myUpload"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7406"><!--anchor d0e7406--></a>7.3.2.2. 手工解析上传请求</h4></div></div></div><p>在默认情况下，当<code class="code">&lt;parser&gt;</code>收到一个上传文件的请求时，会立即解析并取得所有的参数和文件。然而你可以延迟这个过程，在需要的时候，再手工解析上传请求。</p><div class="example"><a id="d0e7414"><!--anchor d0e7414--></a><p class="title"><strong>例 7.21. 手工解析upload请求</strong></p><div class="example-contents"><p>首先，你需要关闭自动上传</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">autoUpload</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre><p>可选参数<code class="code">autoUpload</code>默认值为<code class="code">true</code>，当你把它改成<code class="code">false</code>时，就可以实现延迟手工解析请求。在你需要解析请求时，只需要调用下面的语句即可：</p><pre class="programlisting">parser.getParameters().parseUpload();</pre><p>手工调用<code class="code">parseUpload</code>可以指定和默认不同的参数：</p><pre class="programlisting">UploadParameters params = <strong class="hl-keyword" style="color: maroon">new</strong> UploadParameters();
        
params.applyDefaultValues();
params.setSizeMax(<strong class="hl-keyword" style="color: maroon">new</strong> HumanReadableSize(<strong class="hl-string"><em style="color:navy">"10M"</em></strong>));
params.setFileSizeMax(<strong class="hl-keyword" style="color: maroon">new</strong> HumanReadableSize(<strong class="hl-string"><em style="color:navy">"1M"</em></strong>));
params.setRepository(<strong class="hl-keyword" style="color: maroon">new</strong> File(<strong class="hl-string"><em style="color:navy">"mydir"</em></strong>));
        
parser.getParameters().parseUpload(params);</pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7441"><!--anchor d0e7441--></a>7.3.3. 高级选项</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7444"><!--anchor d0e7444--></a>7.3.3.1. 参数名称大小写转换</h4></div></div></div><p>在默认情况下，假设有一个参数名为：<code class="code">myProductId</code>，那么你可以使用下列<span class="emphasis"><em>任意一种方法</em></span>来访问到它：</p><div class="example"><a id="d0e7455"><!--anchor d0e7455--></a><p class="title"><strong>例 7.22. 取得参数<code class="code">myProductId</code>的值的方法</strong></p><div class="example-contents"><pre class="programlisting">request.getParameter(<strong class="hl-string"><em style="color:navy">"MyProductId"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"myProductId"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"my_product_id"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"MY_PRODUCT_ID"</em></strong>);
request.getParameter(<strong class="hl-string"><em style="color:navy">"MY_productID"</em></strong>);</pre></div></div><p>假如你不希望具备这种灵活性，则需要修改配置以关闭大小写转换功能：</p><div class="example"><a id="d0e7465"><!--anchor d0e7465--></a><p class="title"><strong>例 7.23. 关闭大小写转换功能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">caseFolding</span>=<span class="hl-value" style="color: #993300">"none"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7470"><!--anchor d0e7470--></a>7.3.3.2. 参数值去空白</h4></div></div></div><p>在默认情况下，假设有一个参数：<code class="code">id=" 123
                        "</code>（两端有空白字符），那么<code class="code">&lt;parser&gt;</code>会把它转化成<code class="code">"123"</code>（两端没有空白字符）。
                        假如你不希望<code class="code">&lt;parser&gt;</code>做这件事，则需要修改配置： </p><div class="example"><a id="d0e7487"><!--anchor d0e7487--></a><p class="title"><strong>例 7.24. 关闭参数值去空白功能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">trimming</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div><p>这样，所有的参数值将会保持原状，不会被去除空白。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7494"><!--anchor d0e7494--></a>7.3.3.3. 参数值entity解码</h4></div></div></div><p>浏览器在提交表单时，如果发现被提交的字符不能以当前的charset来编码，浏览器就会把该字符转换成<code class="code">&amp;#unicode;</code>这样的形式。例如，假设一个表单页面的content
                            type为：<span class="emphasis"><em><code class="code">text/html;
                        charset=ISO-8859-1</code></em></span>。在这个页面的输入框中输入汉字“你好”，然后提交。你会发现，提交的汉字变成了这个样子：<code class="code">param=</code><span class="emphasis"><em><code class="code">"&amp;#20320;&amp;#22909;"</code></em></span>。 </p><p>在默认情况下，<code class="code">&lt;parser&gt;</code>会对上述参数进行entity解码，使之恢复成“你好”。但是，其它的entity如“<code class="code">&amp;lt;</code>”、“<code class="code">&amp;amp;</code>”等并不会被转换。
                        如果你不希望<code class="code">&lt;parser&gt;</code>还原上述内容，则需要修改配置：</p><div class="example"><a id="d0e7526"><!--anchor d0e7526--></a><p class="title"><strong>例 7.25. 关闭参数值entity解码功能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">unescapeParameters</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7531"><!--anchor d0e7531--></a>7.3.3.4. 取得任意类型的参数值</h4></div></div></div><p>前面提到，<code class="code">ParserRequestContext</code>支持直接取得<code class="code">boolean</code>、<code class="code">int</code>等类型的参数值。事实上，它还支持取得任意类型的参数值
                    —— 只要Spring中有相应的<code class="code">PropertyEditor</code>支持即可。</p><p>假设<code class="code">MyEnum</code>是一个<code class="code">enum</code>类型，这是Spring原生支持的一种类型。你可以用下面的代码来取得它：</p><div class="example"><a id="d0e7556"><!--anchor d0e7556--></a><p class="title"><strong>例 7.26. 将参数值转换成<code class="code">enum</code>类型</strong></p><div class="example-contents"><pre class="programlisting">MyEnum myEnum = params.getObjectOfType(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, MyEnum.<strong class="hl-keyword" style="color: maroon">class</strong>);</pre></div></div><p>但是，下面的语句就不是那么顺利了 ——
                        因为Spring不知道怎么把一个参数值，例如：“<code class="code">1975-12-15</code>”，转换成<code class="code">java.util.Date</code>类型。</p><div class="example"><a id="d0e7572"><!--anchor d0e7572--></a><p class="title"><strong>例 7.27. 将参数值转换成<code class="code">java.util.Date</code>类型</strong></p><div class="example-contents"><pre class="programlisting">Date birthday = params.getObjectOfType(<strong class="hl-string"><em style="color:navy">"birthday"</em></strong>, Date.<strong class="hl-keyword" style="color: maroon">class</strong>);</pre><p>好在<code class="code">&lt;parser&gt;</code>提供了一种扩展机制，可以添加新的类型转换机制。对于<code class="code">Date</code>类型，你只需要添加下面的配置，就可以被支持了。</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;property-editor-registrar</strong>
        <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.configuration.support.CustomDateRegistrar"</span>
        <span class="hl-attribute" style="color: #F5844C">p:format</span>=<span class="hl-value" style="color: #993300">"yyyy-MM-dd"</span> <span class="hl-attribute" style="color: #F5844C">p:locale</span>=<span class="hl-value" style="color: #993300">"zh_CN"</span> <span class="hl-attribute" style="color: #F5844C">p:timeZone</span>=<span class="hl-value" style="color: #993300">"GMT+8"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.propedit.date"><!--anchor co.propedit.date--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/parser&gt;</strong></pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.propedit.date"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><code class="code">PropertyEditorRegistrar</code>是Spring提供的一种类型注册机制，其细节详见Spring的文档。</p></td></tr></table></div></div></div><p>另一个问题是，如果类型转换失败怎么办？<code class="code">&lt;parser&gt;</code>支持两种方法。默认情况下，类型转换失败会“保持安静”（不抛异常），然后返回默认值。但你也可以选择让类型转换失败的异常被抛出来，以便应用程序处理。</p><div class="example"><a id="d0e7603"><!--anchor d0e7603--></a><p class="title"><strong>例 7.28. 设置“非安静”模式：当类型转换失败时，抛出异常</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">converterQuiet</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre><p>程序里这样写：</p><pre class="programlisting">MyEnum myEnum = null;

<strong class="hl-keyword" style="color: maroon">try</strong> {
    myEnum = params.getObjectOfType(<strong class="hl-string"><em style="color:navy">"myparam"</em></strong>, MyEnum.<strong class="hl-keyword" style="color: maroon">class</strong>);
} <strong class="hl-keyword" style="color: maroon">catch</strong> (TypeMismatchException e) {
    ...
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7612"><!--anchor d0e7612--></a>7.3.3.5. 解析GET请求的参数</h4></div></div></div><p>GET请求是最简单的请求方式。它的参数以URL编码的方式包含在URL中。当你在浏览器地址栏中敲入“<code class="code">http://localhost:8081/user/login.htm?name=%E5%90%8D%E5%AD%97&amp;password=password</code>”这样一个址址的时候，浏览器就会向<code class="code">localhost:8081</code>服务器出如下HTTP请求：</p><pre class="screen">GET /user/login.htm?name=%E5%90%8D%E5%AD%97&amp;password=password HTTP/1.1
Host: localhost:8081</pre><p>GET请求中的参数是以<code class="code">application/x-www-form-urlencoded</code>方式和特定的charset编码的。假如用来编码URL参数的charset与应用的默认charset不同，那么你必须通过特殊的参数来指定charset（参见<a class="xref" href="requestcontexts.html#webx3.requestcontexts.setlocale" title="7.2. &lt;set-locale&gt; -设置locale区域和charset字符集编码">第 7.2 节 “<code class="code">&lt;set-locale&gt;</code> -设置locale区域和charset字符集编码”</a>）：</p><pre class="screen">GET /user/login.htm?<span class="emphasis"><em>_input_charset=UTF-8</em></span>&amp;name=%E5%90%8D%E5%AD%97&amp;password=password HTTP/1.1</pre><p>可是，上面的请求在不同的Servlet引擎中，会产生不确定的结果。这是怎么回事呢？</p><p>原来，尽管<code class="code">&lt;set-locale&gt;</code>会调用<code class="code">request.setCharacterEncoding(charset)</code>这个方法来设置input
                    charset编码，然而根据Servlet API的规范，这个设定只能对request
                        content生效，而不对URL生效。换句话说，<code class="code">request.setCharacterEncoding(charset)</code>方法只能用来解析POST请求的参数，而不是GET请求的参数。</p><p>那么，应该怎样处理GET请求的参数呢？根据URL规范，URL中非US-ASCII的字符必须进行基于<code class="code">UTF-8</code>的URL编码。然而实际上，从浏览器到服务器，没有人完全遵守这些规范，于是便造成了一些混乱。目前应用服务器端，我们所遇到的，有下面几种不同的解码方案：</p><div class="table"><a id="d0e7655"><!--anchor d0e7655--></a><p class="title"><strong>表 7.7. 服务器对参数进行解码的逻辑</strong></p><div class="table-contents"><table summary="服务器对参数进行解码的逻辑" cellpadding="10" style="border: none;"><colgroup><col width="50%" class="c1"/><col width="50%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务器</th><th style="border-bottom: 0.5pt solid #6666cc; ">解码的逻辑</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Tomcat 4</td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>根据<code class="code">request.setCharacterEncoding(charset)</code>所设置的值来解码GET参数；</p></li><li class="listitem"><p>如果未特别指定charset，则默认采用<code class="code">ISO-8859-1</code>来解码参数。
                                            </p></li></ul></div>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">Tomcat 5及更新版 以及搭载Tomcat 5以上版本的JBoss </td><td style="border-bottom: 0.5pt solid #6666cc; ">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>如果Tomcat配置文件<code class="filename">conf/server.xml</code>中设置了：
                                                  <code class="code">&lt;Connector
                                                  useBodyEncodingForURI="true"&gt;</code>那么根据<code class="code">request.setCharacterEncoding(charset)</code>所设置的值来解码GET参数。</p></li><li class="listitem"><p>如未设置<code class="code">useBodyEncodingForURI</code>，或其值为<code class="code">false</code>，则根据<code class="filename">conf/server.xml</code>中的配置<code class="code">&lt;Connector
                                                  URIEncoding="xxx"&gt;</code>所指定的编码，来解码GET请求的参数。</p></li><li class="listitem"><p>如未配置<code class="code">URIEncoding</code>，默认采用<code class="code">ISO-8859-1</code>。
                                            </p></li></ul></div>
                                </td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">Jetty Server</td><td style="">
                                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Jetty总是以<code class="code">UTF-8</code>来解码GET请求的参数。</p></li></ul></div>
                                </td></tr></tbody></table></div></div><p>综上所述，所有的应用服务器对于POST请求的参数的处理方法是没有差别的，然而对于GET请求的参数处理方法各有不同。</p><p>如果不加任何特别的设置，Tomcat最新版是以<code class="code">ISO-8859-1</code>来解码GET请求的参数，而Jetty却是以<code class="code">UTF-8</code>来解码的。因此，无论你以哪一种charset来编码GET请求的参数，都不可能在所有服务器上取得相同的结果
                    ──
                        除非修改服务器的配置，但这是一件既麻烦又容易出错的事情。为了使应用程序对服务器的配置依赖较少，且可以灵活地处理GET请求的解码，<code class="code">&lt;parser&gt;</code>对GET请求进行了手工解码，从而解决了应用服务器解码的不确定性。</p><p><code class="code">&lt;parser&gt;</code>完全解决了上面的问题。<span class="emphasis"><em>依据默认值，<code class="code">&lt;parser&gt;</code>会以<code class="code">&lt;set-locale&gt;</code>中设定的input
                        charset为准，来解码所有类型的请求</em></span>，包括GET和POST请求，以及<code class="code">multipart/form-data</code>（上传文件）类型的请求。</p><p>然而<code class="code">&lt;parser&gt;</code>仍保留了一些可选方案，以备不时之需。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">保留Servlet引擎的解码机制</span></dt><dd><div class="example"><a id="d0e7782"><!--anchor d0e7782--></a><p class="title"><strong>例 7.29. 使用Servlet引擎原来的解码机制</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">useServletEngineParser</span>=<span class="hl-value" style="color: #993300">"true"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p><span class="emphasis"><em>这个选项在用HttpUnit进行单元测试时非常有用</em></span>。因为HttpUnit单元测试工具并没有完全遵循Servlet
                                API的规范 ── 目前版本的HttpUnit不能正确取得query
                                    string，从而导致<code class="code">&lt;parser&gt;</code>解析GET参数错误。</p></dd><dt><span class="term">使用固定的charset来解码GET请求</span></dt><dd><div class="example"><a id="d0e7798"><!--anchor d0e7798--></a><p class="title"><strong>例 7.30. 使用固定的charset来解码GET请求</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser</strong> <span class="hl-attribute" style="color: #F5844C">URIEncoding</span>=<span class="hl-value" style="color: #993300">"UTF-8"</span> <span class="hl-attribute" style="color: #F5844C">useBodyEncodingForURI</span>=<span class="hl-value" style="color: #993300">"false"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong></pre></div></div><p>上面的配置强制所有的GET请求均使用<code class="code">UTF-8</code>作为固定的charset编码。这段逻辑和tomcat的完全相同，但你却不需要去修改tomcat的<code class="filename">conf/server.xml</code>就可以实现上面的逻辑。
                                事实上，使用固定的charset来解码GET请求的参数是符合Servlet
                                    API规范以及URL的规范的。而根据情况设置charset是一种对现实的妥协。然而<span class="emphasis"><em>你有选择的自由 ──
                                        无论你选择何种风格，<code class="code">&lt;parser&gt;</code>都支持你</em></span>。 </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7817"><!--anchor d0e7817--></a>7.3.3.6. 过滤参数</h4></div></div></div><p>出于安全的考虑，<code class="code">&lt;parser&gt;</code>还支持对输入参数进行过滤。请看示例：</p><div class="example"><a id="d0e7825"><!--anchor d0e7825--></a><p class="title"><strong>例 7.31. 配置过滤参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;parser&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;filters&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parser-filters:uploaded-file-whitelist</strong> <span class="hl-attribute" style="color: #F5844C">extensions</span>=<span class="hl-value" style="color: #993300">"jpg, gif, png"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/filters&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/parser&gt;</strong></pre></div></div><p>上面的配置将会禁止文件名后缀不在列表中的文件被上传到服务器上。如果做得更好一点，你甚至可以对上传文件进行病毒扫描。</p><p>目前，<code class="code">&lt;parser&gt;</code>支持两种过滤器接口：<code class="code">ParameterValueFilter</code>和<code class="code">UploadedFileFilter</code>。前者用来对普通的参数值进行过滤（例如排除可能造成攻击的HTML代码）；后者用来对上传文件的file
                        item对象进行过滤，就像刚才的<code class="code">uploaded-file-whitelist</code>的例子。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.buffered"><!--anchor webx3.requestcontexts.buffered--></a>7.4. <code class="code">&lt;buffered&gt;</code> - 缓存response中的内容</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7851"><!--anchor d0e7851--></a>7.4.1. 实现原理</h3></div></div></div><p>Webx
                Turbine支持用layout/screen/control等部件共同购成一个页面。其中，每个layout可包含一个screen和多个control，每个screen可包含多个control，每个control还可以再包含其它的control。Screen和control的内容都可以用程序代码直接生成：</p><div class="example"><a id="d0e7856"><!--anchor d0e7856--></a><p class="title"><strong>例 7.32. 在Screen中直接输出页面内容</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyScreenOrControl {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute() <strong class="hl-keyword" style="color: maroon">throws</strong> IOException {
        PrintWriter out = response.getWriter();

        out.println(<strong class="hl-string"><em style="color:navy">"&lt;p&gt;hello world&lt;/p&gt;"</em></strong>);
    }
}</pre></div></div><p>上面的代码是非常直观、易理解的。事实上，如果你写一个简单的servlet来生成页面，代码也是和上面的类似。</p><p>但是，在简单的代码后面有一个玄机 ——
                那就是这段代码可被用于生成嵌套的页面部件，它所生成的内容可被上一层嵌套的部件所利用。例如，一个screen中包含了一个control，那么screen可以获得它所调用的control的完整的渲染内容。</p><p>这个玄机就是靠<code class="code">&lt;buffered&gt;</code>来实现的。<code class="code">&lt;buffered&gt;</code>改变了response的输出流，包括output
                stream（二进制流）和writer（文本流），使写到输出流中的内容被暂存在内存中。当需要时，可以取得缓存中的所有内容。</p><div class="figure"><a id="d0e7873"><!--anchor d0e7873--></a><div class="figure-contents"><div class="mediaobject"><img src="images/requestcontexts/buffered-rc.png" alt="Webx利用&lt;buffered&gt;机制生成嵌套式页面的过程"/></div></div><p class="title"><strong>图 7.2. Webx利用<code class="code">&lt;buffered&gt;</code>机制生成嵌套式页面的过程</strong></p></div><p>如图所示。<code class="code">BufferedRequestContext</code>主要包括了两条用来操作buffer栈的指令：push和pop。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>每次push就会在栈顶创建一个新的buffer。</p></li><li class="listitem"><p>每次pop就会弹出栈顶buffer，并返回其内容。当最后一个buffer被弹出时，就会自动push一个新的buffer，从而确保任何时候栈都非空。</p></li><li class="listitem"><p>所有写入<code class="code">response.getWriter()</code>和<code class="code">response.getOutputStream()</code>输出流的数据，将被保存在栈顶的buffer中。</p></li><li class="listitem"><p>Push和pop必须成对出现。如果在commit时发现栈内有两个或两个以上的buffer存在，说明有push/pop未匹配，则报错。</p></li><li class="listitem"><p>Commit时，将仅存的栈顶buffer提交给浏览器。</p></li></ul></div><p><code class="code">&lt;buffered&gt;</code>还有一个重要的作用，就是可以用来支持基于cookie的session机制（参见：<a class="xref" href="session.html" title="第 8 章 Request Context之Session指南">第 8 章 <em>Request Context之Session指南</em></a>）。因为cookie是response
                    header的一部分，根据HTTP协议，headers出现在content的前面。一旦content开始向浏览器输出，headers就不可能再被改变了。这会导致基于cookie的session无法保存的问题。<code class="code">&lt;buffered&gt;</code>将所有的输出内容缓存在内存中，从而避免了response过早地提交给浏览器，也就解决了cookie无法保存的问题。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7918"><!--anchor d0e7918--></a>7.4.2. 使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7921"><!--anchor d0e7921--></a>7.4.2.1. 配置</h4></div></div></div><p><code class="code">&lt;buffered&gt;</code>的配置比较简单，没有任何额外的参数。只要像下面这样写就可以了：</p><div class="example"><a id="d0e7928"><!--anchor d0e7928--></a><p class="title"><strong>例 7.33. 配置<code class="code">&lt;buffered&gt;</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;buffered /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7939"><!--anchor d0e7939--></a>7.4.2.2. 操作buffer栈</h4></div></div></div><div class="example"><a id="d0e7942"><!--anchor d0e7942--></a><p class="title"><strong>例 7.34. 操作buffer栈</strong></p><div class="example-contents"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
BufferedRequestContext buffered;

<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
HttpServletResponse response;

...

PrintWriter out = response.getWriter();

buffered.pushBuffer(); <em class="hl-comment" style="color: green">// 创建新buffer，并压入栈顶</em>
out.print(<strong class="hl-string"><em style="color:navy">"world"</em></strong>);  <em class="hl-comment" style="color: green">// 在新buffer中写入</em>

String content = buffered.popCharBuffer(); <em class="hl-comment" style="color: green">// 弹出顶层buffer</em>

out.print(<strong class="hl-string"><em style="color:navy">"hello, "</em></strong>);
out.print(content); <em class="hl-comment" style="color: green">// 写入较低层的buffer</em></pre></div></div><p>需要注意的是，response中有两种输出流：二进制流<code class="code">response.getOutputStream()</code>和文本流<code class="code">response.getWriter()</code>。与之对应的，<code class="code">BufferedRequestContext</code>也会创建两种类型的buffer。这两种buffer类型是互斥的：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>假如你的应用使用了<code class="code">response.getWriter()</code>，那么，你必须使用<code class="code">buffered.popCharBuffer()</code>以取得文本buffer的内容；</p></li><li class="listitem"><p>假如你的应用使用了<code class="code">response.getOutputStream()</code>，那么，你必须使用<code class="code">buffered.popByteBuffer()</code>以取得二进制buffer的内容。</p></li><li class="listitem"><p>如果用错，则抛<code class="code">IllegalStateException</code>。 </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e7983"><!--anchor d0e7983--></a>7.4.2.3. 关闭buffer机制</h4></div></div></div><p>Buffer机制会延迟服务器对用户的响应。在大部分情况下，这不会造成明显的问题。但在某些情况下会产生严重的问题。此时，你需要把buffer机制关闭。</p><p>例如，动态生成excel文件、PDF文件以及图片文件。这样的需求有如下特点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>数据量大 —— 有可能达到几兆。如果把这样大的数据放在内存中，势必导致服务器性能的下降。</p></li><li class="listitem"><p>没有layout/screen/control这样的嵌套页面的需求，因此不需要buffer这样的机制来帮倒忙。</p></li><li class="listitem"><p>无状态，不需要修改session，因此也不需要buffer机制来帮助延迟提交。反过来，对于这样的大文件，提交越早越好 ——
                                甚至可以在文档还未完全生成的时候，就开始向用户浏览器输出，边生成边下载，从而节省大量的下载时间。</p></li></ul></div><p>下面的程序代码模拟了一种情况 ——
                    生成一个120M的PDF文件。每生成1M内容，就故意暂停半秒。这样一来，120M的文件需要大约一分钟才能生成完毕。</p><div class="example"><a id="d0e8002"><!--anchor d0e8002--></a><p class="title"><strong>例 7.35. 模拟生成PDF文档，关闭buffer以提高性能</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">class</strong> MyDocument {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> BufferedRequestContext buffered;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword" style="color: maroon">private</strong> HttpServletResponse response;

    <strong class="hl-keyword" style="color: maroon">public</strong> <strong class="hl-keyword" style="color: maroon">void</strong> execute() <strong class="hl-keyword" style="color: maroon">throws</strong> Exception {
        buffered.setBuffering(false);

        response.setContentType(<strong class="hl-string"><em style="color:navy">"application/pdf"</em></strong>);
        response.setHeader(<strong class="hl-string"><em style="color:navy">"Content-Disposition"</em></strong>, <strong class="hl-string"><em style="color:navy">"attachment; filename=\"mydocument.pdf\""</em></strong>);

        OutputStream out = response.getOutputStream();

        <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> m = <span class="hl-number">0</span>; m &lt; <span class="hl-number">120</span>; m++) {
            <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> k = <span class="hl-number">0</span>; k &lt; <span class="hl-number">1024</span>; k++) {
                <strong class="hl-keyword" style="color: maroon">for</strong> (<strong class="hl-keyword" style="color: maroon">int</strong> b = <span class="hl-number">0</span>; b &lt; <span class="hl-number">1024</span>; b++) {
                    out.write((<strong class="hl-keyword" style="color: maroon">byte</strong>) b);
                }
            }

            <em class="hl-comment" style="color: green">// 每生成1M，暂停半秒</em>
            Thread.sleep(<span class="hl-number">500</span>);
        }
    }
}</pre></div></div><p>把上述类代码，放在screen目录中。然后访问URL：<code class="code">http://localhost:8081/myapp/my_document.do</code>，就可以启动下载。</p><p>假如不关闭buffer机制，从用户点击下载，到浏览器提示保存文件，中间会相隔一分钟。这种用户体验是不可接受的。更糟糕的是，文件会占用至少120M的服务器内存，这也是几乎不可接受的。关闭buffer机制以后，以上两个问题就没有了：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>用户点击下载链接，浏览器立即提示保存文件。</p></li><li class="listitem"><p>边下载边生成数据，生成数据的时间是一分钟，下载所需的时间也是一分钟左右。</p></li><li class="listitem"><p>生成的数据立即输出，不会占用过多的内存。 </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.lazycommit"><!--anchor webx3.requestcontexts.lazycommit--></a>7.5. <code class="code">&lt;lazy-commit&gt;</code> - 延迟提交response</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8029"><!--anchor d0e8029--></a>7.5.1. 什么是提交</h3></div></div></div><p>当浏览器向服务器发出请求，服务器就会返回一个response响应。每个response分成两部分：headers和content。下面是一个HTTP响应的例子：</p><div class="example"><a id="d0e8034"><!--anchor d0e8034--></a><p class="title"><strong>例 7.36. HTTP请求的headers和content</strong></p><div class="example-contents"><pre class="screen">HTTP/1.0 200 OK
Date: Sat, 08 Jan 2011 23:19:52 GMT
Server: Apache/2.0.63 (Unix)
...

&lt;html&gt;...</pre></div></div><p>在服务器应用响应request的全过程中，都可以向浏览器输出response的内容。然而，已经输出到浏览器上的内容，是不可更改的；还没有输出的内容，还有改变的余地。这个输出的过程，被称为提交（commit）。</p><p>Servlet API中有一个方法，可以判定当前的response是否已经被提交。</p><div class="example"><a id="d0e8043"><!--anchor d0e8043--></a><p class="title"><strong>例 7.37. 判断response是否已经被提交</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-keyword" style="color: maroon">if</strong> (response.isCommitted()) {
    ...
}</pre></div></div><p>在Servlet API中，有下列操作可能导致response被提交：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">response.sendError()</code></p></li><li class="listitem"><p><code class="code">response.sendRedirect()</code></p></li><li class="listitem"><p><code class="code">response.flushBuffer()</code></p></li><li class="listitem"><p><code class="code">response.setContentLength()</code>
                                或者<code class="code">response.setHeader("Content-Length", length)</code></p></li><li class="listitem"><p>response输出流被写入并达到内部buffer的最大值（例如：8KB）</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8073"><!--anchor d0e8073--></a>7.5.2. 实现原理</h3></div></div></div><p>当response被提交以后，一切headers都不可再改变。这对于某些应用（例如cookie-based session）的实现是一个问题。</p><p><code class="code">&lt;lazy-commit&gt;</code>通过拦截response中的某些方法，来将可能导致提交的操作延迟到请求处理结束的时候，也就是request
                context本身被提交的时候。</p><p><code class="code">&lt;lazy-commit&gt;</code>必须和<code class="code">&lt;buffered&gt;</code>配合，才能完全实现延迟提交。如前所述，<code class="code">&lt;buffered&gt;</code>将所有的输出暂存在内存里，从而避免了因输出流达到内部buffer的最大值（例如：8KB）而引起的提交。
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8092"><!--anchor d0e8092--></a>7.5.3. 使用方法</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8095"><!--anchor d0e8095--></a>7.5.3.1. 配置</h4></div></div></div><p><code class="code">&lt;lazy-commit&gt;</code>的配置比较简单，没有任何额外的参数。只要像下面这样写就可以了：</p><div class="example"><a id="d0e8102"><!--anchor d0e8102--></a><p class="title"><strong>例 7.38. 配置<code class="code">&lt;lazy-commit&gt;</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;lazy-commit /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8113"><!--anchor d0e8113--></a>7.5.3.2. 取得当前response的状态</h4></div></div></div><p>通过<code class="code">LazyCommitRequestContext</code>接口，你可以访问当前response的一些状态：</p><div class="table"><a id="d0e8121"><!--anchor d0e8121--></a><p class="title"><strong>表 7.8. 通过<code class="code">LazyCommitRequestContext</code>访问response状态</strong></p><div class="table-contents"><table summary="通过LazyCommitRequestContext访问response状态" cellpadding="10" style="border: none;"><colgroup><col width="36%" class="c1"/><col width="64%" class="c2"/></colgroup><thead><tr><th style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; "><code class="code">LazyCommitRequestContext</code>方法名</th><th style="border-bottom: 0.5pt solid #6666cc; ">说明</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">isError()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前请求是否已出错</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">getErrorStatus()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">如果<code class="code">sendError()</code>方法曾被调用，则该方法返回一个error状态值。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">getErrorMessage()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">如果<code class="code">sendError()</code>方法曾被调用，则该方法返回一个error信息。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">isRedirected()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">判断当前请求是否已被重定向。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                    <code class="code">getRedirectLocation()</code>
                                </td><td style="border-bottom: 0.5pt solid #6666cc; ">取得重定向的URI。</td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                    <code class="code">getStatus()</code>
                                </td><td style="">取得最近设置的HTTP status</td></tr></tbody></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="webx3.requestcontexts.rewrite"><!--anchor webx3.requestcontexts.rewrite--></a>7.6. <code class="code">&lt;rewrite&gt;</code> -重写请求的URL和参数</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8198"><!--anchor d0e8198--></a>7.6.1. 概述</h3></div></div></div><p>&lt;rewrite&gt;的功能和设计完全类似于Apache HTTPD
                Server所提供的mod_rewrite模块。它可以根据规则，在运行时修改URL和参数。</p><div class="figure"><a id="d0e8203"><!--anchor d0e8203--></a><div class="figure-contents"><div class="mediaobject"><img src="images/requestcontexts/rewrite-rc.png" alt="Rewrite工作原理"/></div></div><p class="title"><strong>图 7.3. Rewrite工作原理</strong></p></div><p>当一个请求进入<code class="code">&lt;rewrite&gt;</code>以后，它的处理过程如上图所示。过程可分为两个大的步骤，即：匹配和执行。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>匹配</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>取得URL中的path路径。</p></li><li class="listitem"><p>用所取得的path，依次匹配rule1、rule2、rule3中的pattern，直到找到第一个匹配。</p></li><li class="listitem"><p>假如rule中包含conditions，则测试conditions。如果condtions不满足，则当前的rule匹配失败，回到第2步，继续匹配下一个rules。</p></li><li class="listitem"><p>假如rule不包含conditions，或者conditions被满足，则当前的rule匹配成功，进入“执行”阶段。 </p></li></ol></div></li><li class="listitem"><p>执行</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>执行substitution替换。这可能导致path和参数的改变。</p></li><li class="listitem"><p>执行所有的handlers。这为编程者提供了更灵活的手段来改变request中的数据。</p></li><li class="listitem"><p>根据substitution中的指示，结束<code class="code">&lt;rewrite&gt;</code>的执行、或者回到匹配阶段，用新的path和参数继续匹配后续的rules。</p></li><li class="listitem"><p><code class="code">&lt;rewrite&gt;</code>结束时，根据substitution中的指示，改写request或者重定向到新的URL。
                            </p></li></ol></div></li></ul></div><p>下面是一个<code class="code">&lt;rewrite&gt;</code>配置的模板：</p><div class="example"><a id="d0e8257"><!--anchor d0e8257--></a><p class="title"><strong>例 7.39. 配置<code class="code">&lt;rewrite&gt;</code>（<code class="filename">/WEB-INF/webx.xml</code>）</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;services:request-contexts</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.alibaba.com/schema/services/request-contexts"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;rewrite&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- rule 1 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/substitution&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;handlers&gt;</strong>
                <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;/handlers&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- rule 2 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>

        <em class="hl-comment" style="color: green">&lt;!-- rule 3 --&gt;</em>
        <strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;/rewrite&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/services:request-contexts&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8268"><!--anchor d0e8268--></a>7.6.2. 取得路径</h3></div></div></div><p>和Apache mod_rewrite不同，用来匹配rules的路径并不是URL的整个路径，而是由<code class="code">servletPath +
                    pathInfo</code>两部分组成，其中并不包含<code class="code">contextPath</code>。</p><p>这是因为<code class="code">&lt;rewrite&gt;</code>是属于WEB应用的，它只能匹配当前应用中的路径。在基于servlet的WEB应用中，一个完整的URL路径是由<code class="code">contextPath
                    + servletPath +
                    pathInfo</code>三部分组成的。其中<code class="code">contextPath</code>是用来区分应用的，所以对<code class="code">&lt;rewrite&gt;</code>没有意义。</p><p>例如，URL是<code class="code">http://localhost:8081/myapp</code><span class="emphasis"><em><code class="code">/myservlet/path/path</code></em></span>，那么<code class="code">&lt;rewrite&gt;</code>用来匹配rules的路径是：<span class="emphasis"><em><code class="code">/myservlet/path/path</code></em></span>。
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8308"><!--anchor d0e8308--></a>7.6.3. 匹配rules</h3></div></div></div><p>下面是一个简单的rule。</p><div class="example"><a id="d0e8313"><!--anchor d0e8313--></a><p class="title"><strong>例 7.40. 匹配规则的配置</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/test1/hello\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>其中，rule pattern是一个正则表达式。特别需要注意的是，<span class="emphasis"><em>这个正则表达式是部分匹配的</em></span>。如上例pattern可以匹配下面的路径：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span></p></li><li class="listitem"><p><code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span></p></li><li class="listitem"><p><code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span><code class="code">/mypath
                            </code></p></li></ul></div><p>如果你希望匹配整个path，请使用正则表达式的“<code class="code">^</code>”和“<code class="code">$</code>”标记。例如：</p><div class="example"><a id="d0e8353"><!--anchor d0e8353--></a><p class="title"><strong>例 7.41. 匹配整个path</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/test1/hello\.htm$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div><p>部分匹配的正则表达式为你提供了较灵活的匹配能力，例如，下面的rule可以用来匹配所有以jpg为后缀的URL。</p><div class="example"><a id="d0e8360"><!--anchor d0e8360--></a><p class="title"><strong>例 7.42. 后缀匹配</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"\.jpg$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div><p>此外，rules pattern还支持否定的pattern ——
                即在正常的pattern前加上“<code class="code">!</code>”即可。例如下面的rule匹配所有不以jpg为后缀的URL：</p><div class="example"><a id="d0e8370"><!--anchor d0e8370--></a><p class="title"><strong>例 7.43. 否定匹配</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"!\.jpg$"</span><strong class="hl-tag" style="color: #000096">&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8375"><!--anchor d0e8375--></a>7.6.4. 匹配conditions</h3></div></div></div><p>每个rule都可以包含多个额外的conditions。Conditions提供了除path匹配以外的其它条件。下面是condition配置的基本格式：</p><div class="example"><a id="d0e8380"><!--anchor d0e8380--></a><p class="title"><strong>例 7.44. 配置conditions</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/path"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>每个condition由两个主要的参数：测试表达式和pattern。测试表达式中可以使用下面的变量：</p><div class="table"><a id="d0e8387"><!--anchor d0e8387--></a><p class="title"><strong>表 7.9. Condition变量</strong></p><div class="table-contents"><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">客户端信息</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REMOTE_HOST}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">客户端主机名。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRemoteHost()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REMOTE_ADDR}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">客户端地址。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRemoteAddr()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REMOTE_USER}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">用户名。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRemoteUser()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{AUTH_TYPE}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">验证用户的方法。例如BASIC、FORM、CLIENT_CERT、DIGEST等。</td><td style="">相当于<code class="code">request.getAuthType()</code></td></tr></tbody></table><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">服务端信息</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{SERVER_NAME}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务器主机名。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getServerName()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{SERVER_PORT}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">服务器端口。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getServerPort()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{SERVER_PROTOCOL}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">服务器协议。</td><td style="">相当于<code class="code">request.getProtocol()</code></td></tr></tbody></table><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">请求信息</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REQUEST_METHOD}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">HTTP方法名。例如GET、POST等。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getMethod()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{REQUEST_URI}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">所请求的URI，不包括主机名、端口和参数。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getRequestURI()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{QUERY_STRING}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">参数和值。注意，对于POST请求取得QUERY_STRING，可能会影响性能。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getQueryString()</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{QUERY:param}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">取得参数值。无论哪一种类型的请求（GET/POST/上传文件），都可以取得参数值。 </td><td style="">相当于<code class="code">request.getParameter("param")</code></td></tr></tbody></table><table summary="Condition变量" cellpadding="10" style="border: none;"><colgroup><col width="26%" class="c1"/><col width="39%" class="c2"/><col width="35%" class="c3"/></colgroup><thead><tr><th style="border-bottom: 0.5pt solid #6666cc; " colspan="3">HTTP headers</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_USER_AGENT}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">浏览器名称。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("User-Agent")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_REFERER}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">前一个URL。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("Referer")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_HOST}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">HTTP请求中的主机名，一般代表虚拟主机。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("Host")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_ACCEPT}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; border-bottom: 0.5pt solid #6666cc; ">浏览器可以接受的文档类型。</td><td style="border-bottom: 0.5pt solid #6666cc; ">相当于<code class="code">request.getHeader("Accept")</code></td></tr><tr><td style="border-right: 0.5pt solid #6666cc; ">
                                <code class="code">%{HTTP_COOKIE}</code>
                            </td><td style="border-right: 0.5pt solid #6666cc; ">浏览器发送过来的cookie。</td><td style="">相当于<code class="code">request.getHeader("Cookie")</code></td></tr></tbody></table></div></div><p>Condition pattern和rule
                pattern类似，也是<span class="emphasis"><em>部分匹配的正则表达式，并且支持否定的pattern</em></span>。举例说明：</p><div class="example"><a id="d0e8623"><!--anchor d0e8623--></a><p class="title"><strong>例 7.45. Condition patterns</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/path"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rewrite.conditions.rule1"><!--anchor co.rewrite.conditions.rule1--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{SERVER_NAME}:%{SERVER_PORT}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"www.(\w+).com:8080"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>  <a id="co.rewrite.conditions.c1"><!--anchor co.rewrite.conditions.c1--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:x}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"!1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c2"><!--anchor co.rewrite.conditions.c2--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:y}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"2"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c3"><!--anchor co.rewrite.conditions.c3--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>上面的rule匹配符合以下条件的请求：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.rule1"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>匹配路径<code class="code">/path</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c1"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>服务器名为<code class="code">www.*.com</code>，端口为<code class="code">8080</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c2"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>并且参数<code class="code">x!=1</code></p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c3"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>并且参数<code class="code">y=2</code></p></td></tr></table></div></div></div><p>默认情况下，必须所有的conditions条件都符合，rule才会继续执行下去。但是condition还支持一个选项：<code class="code">OR</code>或者<code class="code">ornext</code>。如果condtion带有这个选项，只要符合当前condition<span class="emphasis"><em>或者</em></span>后续的conditions，rule就会执行下去。例如：</p><div class="example"><a id="d0e8675"><!--anchor d0e8675--></a><p class="title"><strong>例 7.46. 部分匹配conditions</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/path"</span><strong class="hl-tag" style="color: #000096">&gt;</strong> <a id="co.rewrite.conditions.rule2"><!--anchor co.rewrite.conditions.rule2--></a><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:x}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"1"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"OR"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c4"><!--anchor co.rewrite.conditions.c4--></a><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:y}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"2"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"ornext"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c5"><!--anchor co.rewrite.conditions.c5--></a><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{QUERY:z}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"3"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong> <a id="co.rewrite.conditions.c6"><!--anchor co.rewrite.conditions.c6--></a><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>上例中，“<code class="code">OR</code>”和“<code class="code">ornext</code>”代表完全一样的意思。这个rule匹配符合以下条件的请求：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.rule2"><span class="calloutno"><img src="images/callouts/1.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>匹配路径<code class="code">/path</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c4"><span class="calloutno"><img src="images/callouts/2.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p>参数<code class="code">x=1</code>，</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c5"><span class="calloutno"><img src="images/callouts/3.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><span class="emphasis"><em>或者</em></span><code class="code">y=2</code>，</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co.rewrite.conditions.c6"><span class="calloutno"><img src="images/callouts/4.png" border="0"/></span></a> </p></td><td valign="top" align="left"><p><span class="emphasis"><em>或者</em></span><code class="code">z=3</code>。</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8723"><!--anchor d0e8723--></a>7.6.5. 替换路径</h3></div></div></div><p>当路径匹配，并且conditions也匹配（如果有的话），那么<code class="code">&lt;rewrite&gt;</code>就会执行所匹配的rule。</p><div class="example"><a id="d0e8731"><!--anchor d0e8731--></a><p class="title"><strong>例 7.47. 替换路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/test1/hello\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/test1/new_hello\.htm"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>上例中的rule将执行下面的替换（别忘了，rule支持部分匹配，只有匹配的部分被替换）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>将<span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span>替换成<span class="emphasis"><em><code class="code">/test1/new_hello.htm</code></em></span>。</p></li><li class="listitem"><p>将<code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span>替换成<code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/new_hello.htm</code></em></span>。</p></li><li class="listitem"><p>将<code class="code">/mypath</code><span class="emphasis"><em><code class="code">/test1/hello.htm</code></em></span><code class="code">/mypath</code>替换成<code class="code">/mypath</code><code class="code">/test1/new_hello.htm</code><code class="code">/mypath</code>。
                        </p></li></ul></div><p>路径替换时，还支持正则表达式变量。例如：</p><div class="example"><a id="d0e8785"><!--anchor d0e8785--></a><p class="title"><strong>例 7.48. 用正则表达式变量替换路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/(\w+)\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{SERVER_NAME}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"(\w+).blogs.com"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/%1/new_$1\.htm"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>需要注意的是，rule
                pattern中的匹配项，是用“<code class="code">$1</code>”、“<code class="code">$2</code>”、“<code class="code">$3</code>”表示的；而condition
                    pattern中的匹配项，是用“<code class="code">%1</code>”、“<code class="code">%2</code>”、“<code class="code">%3</code>”表示的。只有最后一个被匹配的condition中的匹配项，才被保留用于替换。</p><p>上面的rule将执行下面的替换：将<code class="code">http://</code><span class="emphasis"><em><code class="code">myname</code></em></span><code class="code">.blogs.com</code><span class="emphasis"><em><code class="code">/hello.htm</code></em></span>替换成同服务器上的路径：<span class="emphasis"><em><code class="code">/myname/new_hello.htm</code></em></span>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8827"><!--anchor d0e8827--></a>7.6.6. 替换参数</h3></div></div></div><p><code class="code">&lt;rewrite&gt;</code>不仅可以替换路径，还可以替换参数。</p><div class="example"><a id="d0e8834"><!--anchor d0e8834--></a><p class="title"><strong>例 7.49. 替换参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"/hello.(\w+)"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;condition</strong> <span class="hl-attribute" style="color: #F5844C">test</span>=<span class="hl-value" style="color: #993300">"%{SERVER_NAME}"</span> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"www.(\w+).com"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"ext"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"$1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"host"</span> <span class="hl-attribute" style="color: #F5844C">value</span>=<span class="hl-value" style="color: #993300">"%1"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;parameter</strong> <span class="hl-attribute" style="color: #F5844C">key</span>=<span class="hl-value" style="color: #993300">"count"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>1<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>2<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;value&gt;</strong>3<strong class="hl-tag" style="color: #000096">&lt;/value&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/parameter&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/substitution&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>替换参数和替换路径类似，也可以指定rule和condition pattern中的匹配项。参数支持多值，例如上例中的<code class="code">count</code>参数。 上面的例子将执行以下替换行为：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>对于请求：<code class="code">http://www.</code><span class="emphasis"><em><code class="code">myserver</code></em></span><code class="code">.com/hello.</code><span class="emphasis"><em><code class="code">htm</code></em></span>，不改变其路径，只改变其参数：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>创建单值参数：ext=<span class="emphasis"><em><code class="code">htm</code></em></span>（从rule
                                            pattern中取得<code class="code">$1</code>）</p></li><li class="listitem"><p>创建单值参数：host=<span class="emphasis"><em><code class="code">myserver</code></em></span>（从condition
                                            pattern中取得<code class="code">%1</code>）</p></li><li class="listitem"><p>创建多值参数：count=<span class="emphasis"><em><code class="code">[1, 2,
                                        3]</code></em></span></p></li><li class="listitem"><p><span class="emphasis"><em>删除其它所有参数</em></span>。 </p></li></ul></div></li></ul></div><p>如果你想保留原来所有参数，只是修改或添加一些参数，可以指定<code class="code">QSA</code>或<code class="code">qsappend</code>选项。</p><div class="example"><a id="d0e8899"><!--anchor d0e8899--></a><p class="title"><strong>例 7.50. 保留原来的参数</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"QSA"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    ...
<strong class="hl-tag" style="color: #000096">&lt;/substitution&gt;</strong></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8904"><!--anchor d0e8904--></a>7.6.7. 后续操作 </h3></div></div></div><p>当一个rule和其中的conditions被匹配时，<code class="code">&lt;rewrite&gt;</code>就会执行这个rule。执行的结果通常是改变请求的路径或参数。当一个rule执行完毕以后，接下来做什么呢？有几种可能的情况。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8912"><!--anchor d0e8912--></a>7.6.7.1. 继续匹配剩余的rules</h4></div></div></div><div class="example"><a id="d0e8915"><!--anchor d0e8915--></a><p class="title"><strong>例 7.51. 默认后续操作：继续匹配剩余的rules</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>上面第一个rule执行完以后，<code class="code">&lt;rewrite&gt;</code>会用改变过的路径和参数去继续匹配余下的规则。这是默认情况。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8925"><!--anchor d0e8925--></a>7.6.7.2. 停止匹配</h4></div></div></div><div class="example"><a id="d0e8928"><!--anchor d0e8928--></a><p class="title"><strong>例 7.52. 后续操作：停止匹配</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>当在substitution中指定<code class="code">L</code>或者<code class="code">last</code>选项时，rule匹配会到此中止。后续的rules不会再被匹配。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="d0e8941"><!--anchor d0e8941--></a>7.6.7.3. 串接rules</h4></div></div></div><div class="example"><a id="d0e8944"><!--anchor d0e8944--></a><p class="title"><strong>例 7.53. 后续操作：串接rules</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/common-prefix"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"C"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"\.jpg"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>当在substitution中指定<code class="code">C</code>或者<code class="code">chain</code>选项时，假如当前rule匹配，则会像默认情况一样继续匹配剩余的rules；否则，就像<code class="code">last</code>选项一样立即中止匹配。</p><p>串接rules在下面的情况下非常有用：即对一个路径进行匹配多个patterns。例如上面的例子中，第一个rule限定了路径前缀必须是“<code class="code">/common-prefix</code>”，接下来的rules在此基础上继续判断：后缀是“<code class="code">jpg</code>”还是“<code class="code">htm</code>”？</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8971"><!--anchor d0e8971--></a>7.6.8. 重定向</h3></div></div></div><div class="example"><a id="d0e8974"><!--anchor d0e8974--></a><p class="title"><strong>例 7.54. 重定向</strong></p><div class="example-contents"><p>永久重定向，status code=<code class="code">301</code></p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello1\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R=301"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>临时重定向，status code=<code class="code">302</code>，不保留参数</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello2\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>临时重定向，status code=<code class="code">302</code>，保留参数</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello3\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R,QSA"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre><p>绝对URL重定向，status code=<code class="code">302</code></p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"^/hello4\.htm"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;substitution</strong> <span class="hl-attribute" style="color: #F5844C">uri</span>=<span class="hl-value" style="color: #993300">"http://www.other-site.com/new_hello.htm"</span> <span class="hl-attribute" style="color: #F5844C">flags</span>=<span class="hl-value" style="color: #993300">"L,R"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>当在substitution中指定<code class="code">R</code>或者<code class="code">redirect</code>的时候，<code class="code">&lt;rewrite&gt;</code>会返回“重定向”的响应。
                    重定向有两种：<code class="code">301</code>永久重定向，和<code class="code">302</code>临时重定向。默认是<code class="code">302</code>临时重定向，但你可以指定<code class="code">301</code>来产生一个永久的重定向。</p><p>通常，<code class="code">R</code>标记会和<code class="code">L</code>标记一起使用，使<code class="code">&lt;rewrite&gt;</code>立即结束。</p><p>重定向和<code class="code">QSA</code>标记一起使用时，可以将当前请求的所有参数附加到重定向请求中。不过这里需要注意的是，假如当前请求是一个post请求，那么将参数附加到新的URL中，可能会导致URL过长而重定向失败的问题。</p><p>重定向可以指向另一个不同域名的网站 ——
                反过来说，<span class="emphasis"><em>假如你希望rewrite到另一个网站，那么你必须指定重定向的选项才行</em></span>。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9047"><!--anchor d0e9047--></a>7.6.9. 自定义处理器</h3></div></div></div><div class="example"><a id="d0e9050"><!--anchor d0e9050--></a><p class="title"><strong>例 7.55. 自定义处理器</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;handlers&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/handlers&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div><p>有时候，基于正则表达式替换的substitution不能满足较复杂的需求，好在<code class="code">&lt;rewrite&gt;</code>还提供了另一种机制：自定义处理器。</p><p>当rule和conditions被匹配的时候，所有的handlers将被执行。Webx提供了一个handler参考实现：</p><div class="example"><a id="d0e9062"><!--anchor d0e9062--></a><p class="title"><strong>例 7.56. 自定处理器参考实现：规格化路径</strong></p><div class="example-contents"><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;rule</strong> <span class="hl-attribute" style="color: #F5844C">pattern</span>=<span class="hl-value" style="color: #993300">"..."</span><strong class="hl-tag" style="color: #000096">&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;handlers&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;rewrite-handlers:handler</strong>
            <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"com.alibaba.citrus.service.requestcontext.rewrite.support.UrlNormalizer"</span><strong class="hl-tag" style="color: #000096">
        /&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/handlers&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/rule&gt;</strong></pre></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d0e9067"><!--anchor d0e9067--></a>7.7. 本章总结</h2></div></div></div><p>本文详细介绍了Request Contexts的功能。</p><p>Request
            Contexts服务是Webx框架的核心功能之一。它看似简单，但却提供了很多有用功能。相对于其它框架中的解决方案，RequestContexts显得更加优雅，因为其中大部分功能对应用程序是透明的
            —— 应用程序不需要知道它们的存在，就可以享受它们所提供的功能。 </p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="filter.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="pt02.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="session.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 6 章 Filter、Request Contexts和Pipeline </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 8 章 Request Context之Session指南</td></tr></table></div></body></html>